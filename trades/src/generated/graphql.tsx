import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  numeric: any;
  timestamptz: any;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: Maybe<Scalars['Boolean']>;
  _gt?: Maybe<Scalars['Boolean']>;
  _gte?: Maybe<Scalars['Boolean']>;
  _in?: Maybe<Array<Scalars['Boolean']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Boolean']>;
  _lte?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Scalars['Boolean']>;
  _nin?: Maybe<Array<Scalars['Boolean']>>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: Maybe<Scalars['Int']>;
  _gt?: Maybe<Scalars['Int']>;
  _gte?: Maybe<Scalars['Int']>;
  _in?: Maybe<Array<Scalars['Int']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Int']>;
  _lte?: Maybe<Scalars['Int']>;
  _neq?: Maybe<Scalars['Int']>;
  _nin?: Maybe<Array<Scalars['Int']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['String']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['String']>;
};

/** columns and relationships of "arbitrum.borrows" */
export type Arbitrum_Borrows = {
  __typename?: 'arbitrum_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "arbitrum.borrows". All fields are combined with a logical 'AND'. */
export type Arbitrum_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Borrows_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.borrows". */
export type Arbitrum_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.borrows" */
export enum Arbitrum_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Arbitrum_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Arbitrum_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Arbitrum_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "arbitrum.lending_market_daily_snapshots" */
export type Arbitrum_Lending_Market_Daily_Snapshots = {
  __typename?: 'arbitrum_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "arbitrum.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.lending_market_daily_snapshots". */
export type Arbitrum_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.lending_market_daily_snapshots" */
export enum Arbitrum_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "arbitrum.lending_market_user_count_tb" */
export type Arbitrum_Lending_Market_User_Count_Tb = {
  __typename?: 'arbitrum_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "arbitrum.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.lending_market_user_count_tb". */
export type Arbitrum_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.lending_market_user_count_tb" */
export enum Arbitrum_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "arbitrum.lending_supplies" */
export type Arbitrum_Lending_Supplies = {
  __typename?: 'arbitrum_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "arbitrum.lending_supplies". All fields are combined with a logical 'AND'. */
export type Arbitrum_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.lending_supplies". */
export type Arbitrum_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.lending_supplies" */
export enum Arbitrum_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "arbitrum.liquidity_changes" */
export type Arbitrum_Liquidity_Changes = {
  __typename?: 'arbitrum_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "arbitrum.liquidity_changes" */
export type Arbitrum_Liquidity_Changes_Aggregate = {
  __typename?: 'arbitrum_liquidity_changes_aggregate';
  aggregate?: Maybe<Arbitrum_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Arbitrum_Liquidity_Changes>;
};

/** aggregate fields of "arbitrum.liquidity_changes" */
export type Arbitrum_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'arbitrum_liquidity_changes_aggregate_fields';
  avg?: Maybe<Arbitrum_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Arbitrum_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Arbitrum_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "arbitrum.liquidity_changes" */
export type Arbitrum_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Liquidity_Changes_Avg_Fields = {
  __typename?: 'arbitrum_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Arbitrum_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Liquidity_Changes_Max_Fields = {
  __typename?: 'arbitrum_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Arbitrum_Liquidity_Changes_Min_Fields = {
  __typename?: 'arbitrum_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "arbitrum.liquidity_changes". */
export type Arbitrum_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.liquidity_changes" */
export enum Arbitrum_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Arbitrum_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'arbitrum_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Liquidity_Changes_Sum_Fields = {
  __typename?: 'arbitrum_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'arbitrum_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'arbitrum_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Liquidity_Changes_Variance_Fields = {
  __typename?: 'arbitrum_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.liquidity_with_prices" */
export type Arbitrum_Liquidity_With_Prices = {
  __typename?: 'arbitrum_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "arbitrum.liquidity_with_prices" */
export type Arbitrum_Liquidity_With_Prices_Aggregate = {
  __typename?: 'arbitrum_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Arbitrum_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Arbitrum_Liquidity_With_Prices>;
};

/** aggregate fields of "arbitrum.liquidity_with_prices" */
export type Arbitrum_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Arbitrum_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Arbitrum_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Arbitrum_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "arbitrum.liquidity_with_prices" */
export type Arbitrum_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Arbitrum_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Arbitrum_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "arbitrum.liquidity_with_prices". */
export type Arbitrum_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.liquidity_with_prices" */
export enum Arbitrum_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Arbitrum_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'arbitrum_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.loan_liquidations" */
export type Arbitrum_Loan_Liquidations = {
  __typename?: 'arbitrum_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "arbitrum.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Arbitrum_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.loan_liquidations". */
export type Arbitrum_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.loan_liquidations" */
export enum Arbitrum_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "arbitrum.pair_search" */
export type Arbitrum_Pair_Search = {
  __typename?: 'arbitrum_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Arbitrum_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Arbitrum_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "arbitrum.pair_search" */
export type Arbitrum_Pair_Search_Aggregate = {
  __typename?: 'arbitrum_pair_search_aggregate';
  aggregate?: Maybe<Arbitrum_Pair_Search_Aggregate_Fields>;
  nodes: Array<Arbitrum_Pair_Search>;
};

/** aggregate fields of "arbitrum.pair_search" */
export type Arbitrum_Pair_Search_Aggregate_Fields = {
  __typename?: 'arbitrum_pair_search_aggregate_fields';
  avg?: Maybe<Arbitrum_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Pair_Search_Max_Fields>;
  min?: Maybe<Arbitrum_Pair_Search_Min_Fields>;
  stddev?: Maybe<Arbitrum_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "arbitrum.pair_search" */
export type Arbitrum_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Pair_Search_Avg_Fields = {
  __typename?: 'arbitrum_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.pair_search". All fields are combined with a logical 'AND'. */
export type Arbitrum_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Pair_Search_Max_Fields = {
  __typename?: 'arbitrum_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Arbitrum_Pair_Search_Min_Fields = {
  __typename?: 'arbitrum_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "arbitrum.pair_search". */
export type Arbitrum_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Arbitrum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Arbitrum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.pair_search" */
export enum Arbitrum_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Arbitrum_Pair_Search_Stddev_Fields = {
  __typename?: 'arbitrum_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Pair_Search_Sum_Fields = {
  __typename?: 'arbitrum_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Pair_Search_Var_Pop_Fields = {
  __typename?: 'arbitrum_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Pair_Search_Var_Samp_Fields = {
  __typename?: 'arbitrum_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Pair_Search_Variance_Fields = {
  __typename?: 'arbitrum_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.pair_summary" */
export type Arbitrum_Pair_Summary = {
  __typename?: 'arbitrum_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Arbitrum_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Arbitrum_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "arbitrum.pair_summary" */
export type Arbitrum_Pair_Summary_Aggregate = {
  __typename?: 'arbitrum_pair_summary_aggregate';
  aggregate?: Maybe<Arbitrum_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Arbitrum_Pair_Summary>;
};

/** aggregate fields of "arbitrum.pair_summary" */
export type Arbitrum_Pair_Summary_Aggregate_Fields = {
  __typename?: 'arbitrum_pair_summary_aggregate_fields';
  avg?: Maybe<Arbitrum_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Pair_Summary_Max_Fields>;
  min?: Maybe<Arbitrum_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Arbitrum_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "arbitrum.pair_summary" */
export type Arbitrum_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Pair_Summary_Avg_Fields = {
  __typename?: 'arbitrum_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.pair_summary". All fields are combined with a logical 'AND'. */
export type Arbitrum_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Pair_Summary_Max_Fields = {
  __typename?: 'arbitrum_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Arbitrum_Pair_Summary_Min_Fields = {
  __typename?: 'arbitrum_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "arbitrum.pair_summary". */
export type Arbitrum_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Arbitrum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Arbitrum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.pair_summary" */
export enum Arbitrum_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Arbitrum_Pair_Summary_Stddev_Fields = {
  __typename?: 'arbitrum_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Pair_Summary_Sum_Fields = {
  __typename?: 'arbitrum_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'arbitrum_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'arbitrum_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Pair_Summary_Variance_Fields = {
  __typename?: 'arbitrum_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.pair_with_prices_tb" */
export type Arbitrum_Pair_With_Prices_Tb = {
  __typename?: 'arbitrum_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "arbitrum.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Arbitrum_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.pair_with_prices_tb". */
export type Arbitrum_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.pair_with_prices_tb" */
export enum Arbitrum_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "arbitrum.pairs" */
export type Arbitrum_Pairs = {
  __typename?: 'arbitrum_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Arbitrum_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Arbitrum_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "arbitrum.pairs". All fields are combined with a logical 'AND'. */
export type Arbitrum_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Pairs_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.pairs". */
export type Arbitrum_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Arbitrum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Arbitrum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.pairs" */
export enum Arbitrum_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "arbitrum.pairs_tx_count" */
export type Arbitrum_Pairs_Tx_Count = {
  __typename?: 'arbitrum_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "arbitrum.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Arbitrum_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.pairs_tx_count". */
export type Arbitrum_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.pairs_tx_count" */
export enum Arbitrum_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "arbitrum.protocols" */
export type Arbitrum_Protocols = {
  __typename?: 'arbitrum_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "arbitrum.protocols". All fields are combined with a logical 'AND'. */
export type Arbitrum_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Protocols_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.protocols". */
export type Arbitrum_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.protocols" */
export enum Arbitrum_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "arbitrum.swap_candles_cached" */
export type Arbitrum_Swap_Candles_Cached = {
  __typename?: 'arbitrum_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "arbitrum.swap_candles_cached" */
export type Arbitrum_Swap_Candles_Cached_Aggregate = {
  __typename?: 'arbitrum_swap_candles_cached_aggregate';
  aggregate?: Maybe<Arbitrum_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Arbitrum_Swap_Candles_Cached>;
};

/** aggregate fields of "arbitrum.swap_candles_cached" */
export type Arbitrum_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Arbitrum_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Arbitrum_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Arbitrum_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "arbitrum.swap_candles_cached" */
export type Arbitrum_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Arbitrum_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Arbitrum_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "arbitrum.swap_candles_cached". */
export type Arbitrum_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.swap_candles_cached" */
export enum Arbitrum_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Arbitrum_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'arbitrum_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.swap_candles_tb" */
export type Arbitrum_Swap_Candles_Tb = {
  __typename?: 'arbitrum_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "arbitrum.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Arbitrum_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.swap_candles_tb". */
export type Arbitrum_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.swap_candles_tb" */
export enum Arbitrum_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "arbitrum.tokens" */
export type Arbitrum_Tokens = {
  __typename?: 'arbitrum_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "arbitrum.tokens". All fields are combined with a logical 'AND'. */
export type Arbitrum_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Tokens_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.tokens". */
export type Arbitrum_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.tokens" */
export enum Arbitrum_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "arbitrum.tokenswaps_with_prices" */
export type Arbitrum_Tokenswaps_With_Prices = {
  __typename?: 'arbitrum_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "arbitrum.tokenswaps_with_prices" */
export type Arbitrum_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'arbitrum_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Arbitrum_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Arbitrum_Tokenswaps_With_Prices>;
};

/** aggregate fields of "arbitrum.tokenswaps_with_prices" */
export type Arbitrum_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Arbitrum_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Arbitrum_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Arbitrum_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Arbitrum_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Arbitrum_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arbitrum_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Arbitrum_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Arbitrum_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Arbitrum_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Arbitrum_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "arbitrum.tokenswaps_with_prices" */
export type Arbitrum_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Arbitrum_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "arbitrum.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Arbitrum_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Arbitrum_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Arbitrum_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "arbitrum.tokenswaps_with_prices". */
export type Arbitrum_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.tokenswaps_with_prices" */
export enum Arbitrum_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Arbitrum_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Arbitrum_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Arbitrum_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Arbitrum_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Arbitrum_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Arbitrum_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Arbitrum_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'arbitrum_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "arbitrum.usd_tokens" */
export type Arbitrum_Usd_Tokens = {
  __typename?: 'arbitrum_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "arbitrum.usd_tokens". All fields are combined with a logical 'AND'. */
export type Arbitrum_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Arbitrum_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Arbitrum_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Arbitrum_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "arbitrum.usd_tokens". */
export type Arbitrum_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "arbitrum.usd_tokens" */
export enum Arbitrum_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** columns and relationships of "avalanche.borrows" */
export type Avalanche_Borrows = {
  __typename?: 'avalanche_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "avalanche.borrows". All fields are combined with a logical 'AND'. */
export type Avalanche_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Borrows_Bool_Exp>>;
  _not?: Maybe<Avalanche_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.borrows". */
export type Avalanche_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "avalanche.borrows" */
export enum Avalanche_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Avalanche_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Avalanche_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Avalanche_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "avalanche.lending_market_daily_snapshots" */
export type Avalanche_Lending_Market_Daily_Snapshots = {
  __typename?: 'avalanche_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "avalanche.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.lending_market_daily_snapshots". */
export type Avalanche_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "avalanche.lending_market_daily_snapshots" */
export enum Avalanche_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "avalanche.lending_market_user_count_tb" */
export type Avalanche_Lending_Market_User_Count_Tb = {
  __typename?: 'avalanche_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "avalanche.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Avalanche_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.lending_market_user_count_tb". */
export type Avalanche_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "avalanche.lending_market_user_count_tb" */
export enum Avalanche_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "avalanche.lending_supplies" */
export type Avalanche_Lending_Supplies = {
  __typename?: 'avalanche_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "avalanche.lending_supplies". All fields are combined with a logical 'AND'. */
export type Avalanche_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Avalanche_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.lending_supplies". */
export type Avalanche_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "avalanche.lending_supplies" */
export enum Avalanche_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "avalanche.liquidity_changes" */
export type Avalanche_Liquidity_Changes = {
  __typename?: 'avalanche_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "avalanche.liquidity_changes" */
export type Avalanche_Liquidity_Changes_Aggregate = {
  __typename?: 'avalanche_liquidity_changes_aggregate';
  aggregate?: Maybe<Avalanche_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Avalanche_Liquidity_Changes>;
};

/** aggregate fields of "avalanche.liquidity_changes" */
export type Avalanche_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'avalanche_liquidity_changes_aggregate_fields';
  avg?: Maybe<Avalanche_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Avalanche_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Avalanche_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "avalanche.liquidity_changes" */
export type Avalanche_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Liquidity_Changes_Avg_Fields = {
  __typename?: 'avalanche_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Avalanche_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Avalanche_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Liquidity_Changes_Max_Fields = {
  __typename?: 'avalanche_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Avalanche_Liquidity_Changes_Min_Fields = {
  __typename?: 'avalanche_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "avalanche.liquidity_changes". */
export type Avalanche_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "avalanche.liquidity_changes" */
export enum Avalanche_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Avalanche_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'avalanche_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'avalanche_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'avalanche_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Liquidity_Changes_Sum_Fields = {
  __typename?: 'avalanche_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'avalanche_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'avalanche_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Liquidity_Changes_Variance_Fields = {
  __typename?: 'avalanche_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.liquidity_with_prices" */
export type Avalanche_Liquidity_With_Prices = {
  __typename?: 'avalanche_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "avalanche.liquidity_with_prices" */
export type Avalanche_Liquidity_With_Prices_Aggregate = {
  __typename?: 'avalanche_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Avalanche_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Avalanche_Liquidity_With_Prices>;
};

/** aggregate fields of "avalanche.liquidity_with_prices" */
export type Avalanche_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Avalanche_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Avalanche_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Avalanche_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "avalanche.liquidity_with_prices" */
export type Avalanche_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Avalanche_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Avalanche_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Avalanche_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "avalanche.liquidity_with_prices". */
export type Avalanche_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "avalanche.liquidity_with_prices" */
export enum Avalanche_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Avalanche_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'avalanche_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.loan_liquidations" */
export type Avalanche_Loan_Liquidations = {
  __typename?: 'avalanche_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "avalanche.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Avalanche_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Avalanche_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.loan_liquidations". */
export type Avalanche_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "avalanche.loan_liquidations" */
export enum Avalanche_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "avalanche.pair_search" */
export type Avalanche_Pair_Search = {
  __typename?: 'avalanche_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Avalanche_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Avalanche_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "avalanche.pair_search" */
export type Avalanche_Pair_Search_Aggregate = {
  __typename?: 'avalanche_pair_search_aggregate';
  aggregate?: Maybe<Avalanche_Pair_Search_Aggregate_Fields>;
  nodes: Array<Avalanche_Pair_Search>;
};

/** aggregate fields of "avalanche.pair_search" */
export type Avalanche_Pair_Search_Aggregate_Fields = {
  __typename?: 'avalanche_pair_search_aggregate_fields';
  avg?: Maybe<Avalanche_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Pair_Search_Max_Fields>;
  min?: Maybe<Avalanche_Pair_Search_Min_Fields>;
  stddev?: Maybe<Avalanche_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "avalanche.pair_search" */
export type Avalanche_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Pair_Search_Avg_Fields = {
  __typename?: 'avalanche_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.pair_search". All fields are combined with a logical 'AND'. */
export type Avalanche_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Avalanche_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Pair_Search_Max_Fields = {
  __typename?: 'avalanche_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Avalanche_Pair_Search_Min_Fields = {
  __typename?: 'avalanche_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "avalanche.pair_search". */
export type Avalanche_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Avalanche_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Avalanche_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "avalanche.pair_search" */
export enum Avalanche_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Avalanche_Pair_Search_Stddev_Fields = {
  __typename?: 'avalanche_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'avalanche_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'avalanche_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Pair_Search_Sum_Fields = {
  __typename?: 'avalanche_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Pair_Search_Var_Pop_Fields = {
  __typename?: 'avalanche_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Pair_Search_Var_Samp_Fields = {
  __typename?: 'avalanche_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Pair_Search_Variance_Fields = {
  __typename?: 'avalanche_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.pair_summary" */
export type Avalanche_Pair_Summary = {
  __typename?: 'avalanche_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Avalanche_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Avalanche_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "avalanche.pair_summary" */
export type Avalanche_Pair_Summary_Aggregate = {
  __typename?: 'avalanche_pair_summary_aggregate';
  aggregate?: Maybe<Avalanche_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Avalanche_Pair_Summary>;
};

/** aggregate fields of "avalanche.pair_summary" */
export type Avalanche_Pair_Summary_Aggregate_Fields = {
  __typename?: 'avalanche_pair_summary_aggregate_fields';
  avg?: Maybe<Avalanche_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Pair_Summary_Max_Fields>;
  min?: Maybe<Avalanche_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Avalanche_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "avalanche.pair_summary" */
export type Avalanche_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Pair_Summary_Avg_Fields = {
  __typename?: 'avalanche_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.pair_summary". All fields are combined with a logical 'AND'. */
export type Avalanche_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Avalanche_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Pair_Summary_Max_Fields = {
  __typename?: 'avalanche_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Avalanche_Pair_Summary_Min_Fields = {
  __typename?: 'avalanche_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "avalanche.pair_summary". */
export type Avalanche_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Avalanche_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Avalanche_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "avalanche.pair_summary" */
export enum Avalanche_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Avalanche_Pair_Summary_Stddev_Fields = {
  __typename?: 'avalanche_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'avalanche_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'avalanche_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Pair_Summary_Sum_Fields = {
  __typename?: 'avalanche_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'avalanche_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'avalanche_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Pair_Summary_Variance_Fields = {
  __typename?: 'avalanche_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.pair_with_prices_tb" */
export type Avalanche_Pair_With_Prices_Tb = {
  __typename?: 'avalanche_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "avalanche.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Avalanche_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Avalanche_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.pair_with_prices_tb". */
export type Avalanche_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "avalanche.pair_with_prices_tb" */
export enum Avalanche_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "avalanche.pairs" */
export type Avalanche_Pairs = {
  __typename?: 'avalanche_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Avalanche_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Avalanche_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "avalanche.pairs". All fields are combined with a logical 'AND'. */
export type Avalanche_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Pairs_Bool_Exp>>;
  _not?: Maybe<Avalanche_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Avalanche_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.pairs". */
export type Avalanche_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Avalanche_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Avalanche_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "avalanche.pairs" */
export enum Avalanche_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "avalanche.pairs_tx_count" */
export type Avalanche_Pairs_Tx_Count = {
  __typename?: 'avalanche_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "avalanche.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Avalanche_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Avalanche_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.pairs_tx_count". */
export type Avalanche_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "avalanche.pairs_tx_count" */
export enum Avalanche_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "avalanche.protocols" */
export type Avalanche_Protocols = {
  __typename?: 'avalanche_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "avalanche.protocols". All fields are combined with a logical 'AND'. */
export type Avalanche_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Protocols_Bool_Exp>>;
  _not?: Maybe<Avalanche_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.protocols". */
export type Avalanche_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "avalanche.protocols" */
export enum Avalanche_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "avalanche.swap_candles_cached" */
export type Avalanche_Swap_Candles_Cached = {
  __typename?: 'avalanche_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "avalanche.swap_candles_cached" */
export type Avalanche_Swap_Candles_Cached_Aggregate = {
  __typename?: 'avalanche_swap_candles_cached_aggregate';
  aggregate?: Maybe<Avalanche_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Avalanche_Swap_Candles_Cached>;
};

/** aggregate fields of "avalanche.swap_candles_cached" */
export type Avalanche_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'avalanche_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Avalanche_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Avalanche_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Avalanche_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "avalanche.swap_candles_cached" */
export type Avalanche_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'avalanche_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Avalanche_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Avalanche_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'avalanche_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Avalanche_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'avalanche_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "avalanche.swap_candles_cached". */
export type Avalanche_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "avalanche.swap_candles_cached" */
export enum Avalanche_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Avalanche_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'avalanche_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'avalanche_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'avalanche_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'avalanche_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'avalanche_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'avalanche_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'avalanche_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.swap_candles_tb" */
export type Avalanche_Swap_Candles_Tb = {
  __typename?: 'avalanche_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "avalanche.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Avalanche_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Avalanche_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.swap_candles_tb". */
export type Avalanche_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "avalanche.swap_candles_tb" */
export enum Avalanche_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "avalanche.tokens" */
export type Avalanche_Tokens = {
  __typename?: 'avalanche_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "avalanche.tokens". All fields are combined with a logical 'AND'. */
export type Avalanche_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Tokens_Bool_Exp>>;
  _not?: Maybe<Avalanche_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.tokens". */
export type Avalanche_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "avalanche.tokens" */
export enum Avalanche_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "avalanche.tokenswaps_with_prices" */
export type Avalanche_Tokenswaps_With_Prices = {
  __typename?: 'avalanche_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "avalanche.tokenswaps_with_prices" */
export type Avalanche_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'avalanche_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Avalanche_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Avalanche_Tokenswaps_With_Prices>;
};

/** aggregate fields of "avalanche.tokenswaps_with_prices" */
export type Avalanche_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Avalanche_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Avalanche_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Avalanche_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Avalanche_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Avalanche_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Avalanche_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Avalanche_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Avalanche_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Avalanche_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Avalanche_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "avalanche.tokenswaps_with_prices" */
export type Avalanche_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Avalanche_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "avalanche.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Avalanche_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Avalanche_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Avalanche_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Avalanche_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "avalanche.tokenswaps_with_prices". */
export type Avalanche_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "avalanche.tokenswaps_with_prices" */
export enum Avalanche_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Avalanche_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Avalanche_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Avalanche_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Avalanche_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Avalanche_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Avalanche_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Avalanche_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'avalanche_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "avalanche.usd_tokens" */
export type Avalanche_Usd_Tokens = {
  __typename?: 'avalanche_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "avalanche.usd_tokens". All fields are combined with a logical 'AND'. */
export type Avalanche_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Avalanche_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Avalanche_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Avalanche_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "avalanche.usd_tokens". */
export type Avalanche_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "avalanche.usd_tokens" */
export enum Avalanche_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: Maybe<Scalars['bigint']>;
  _gt?: Maybe<Scalars['bigint']>;
  _gte?: Maybe<Scalars['bigint']>;
  _in?: Maybe<Array<Scalars['bigint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['bigint']>;
  _lte?: Maybe<Scalars['bigint']>;
  _neq?: Maybe<Scalars['bigint']>;
  _nin?: Maybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "bsc.borrows" */
export type Bsc_Borrows = {
  __typename?: 'bsc_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "bsc.borrows". All fields are combined with a logical 'AND'. */
export type Bsc_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Borrows_Bool_Exp>>;
  _not?: Maybe<Bsc_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.borrows". */
export type Bsc_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "bsc.borrows" */
export enum Bsc_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Bsc_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Bsc_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Bsc_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "bsc.lending_market_daily_snapshots" */
export type Bsc_Lending_Market_Daily_Snapshots = {
  __typename?: 'bsc_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "bsc.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Bsc_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Bsc_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.lending_market_daily_snapshots". */
export type Bsc_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "bsc.lending_market_daily_snapshots" */
export enum Bsc_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "bsc.lending_market_user_count_tb" */
export type Bsc_Lending_Market_User_Count_Tb = {
  __typename?: 'bsc_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "bsc.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Bsc_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.lending_market_user_count_tb". */
export type Bsc_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "bsc.lending_market_user_count_tb" */
export enum Bsc_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "bsc.lending_supplies" */
export type Bsc_Lending_Supplies = {
  __typename?: 'bsc_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "bsc.lending_supplies". All fields are combined with a logical 'AND'. */
export type Bsc_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Bsc_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.lending_supplies". */
export type Bsc_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "bsc.lending_supplies" */
export enum Bsc_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "bsc.liquidity_changes" */
export type Bsc_Liquidity_Changes = {
  __typename?: 'bsc_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "bsc.liquidity_changes" */
export type Bsc_Liquidity_Changes_Aggregate = {
  __typename?: 'bsc_liquidity_changes_aggregate';
  aggregate?: Maybe<Bsc_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Bsc_Liquidity_Changes>;
};

/** aggregate fields of "bsc.liquidity_changes" */
export type Bsc_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'bsc_liquidity_changes_aggregate_fields';
  avg?: Maybe<Bsc_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Bsc_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Bsc_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Bsc_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Bsc_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bsc_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Bsc_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Bsc_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Bsc_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Bsc_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "bsc.liquidity_changes" */
export type Bsc_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Bsc_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Bsc_Liquidity_Changes_Avg_Fields = {
  __typename?: 'bsc_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "bsc.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Bsc_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Bsc_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Bsc_Liquidity_Changes_Max_Fields = {
  __typename?: 'bsc_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Bsc_Liquidity_Changes_Min_Fields = {
  __typename?: 'bsc_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "bsc.liquidity_changes". */
export type Bsc_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "bsc.liquidity_changes" */
export enum Bsc_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Bsc_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'bsc_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Bsc_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'bsc_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Bsc_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'bsc_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Bsc_Liquidity_Changes_Sum_Fields = {
  __typename?: 'bsc_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Bsc_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'bsc_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Bsc_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'bsc_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Bsc_Liquidity_Changes_Variance_Fields = {
  __typename?: 'bsc_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "bsc.liquidity_with_prices" */
export type Bsc_Liquidity_With_Prices = {
  __typename?: 'bsc_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "bsc.liquidity_with_prices" */
export type Bsc_Liquidity_With_Prices_Aggregate = {
  __typename?: 'bsc_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Bsc_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Bsc_Liquidity_With_Prices>;
};

/** aggregate fields of "bsc.liquidity_with_prices" */
export type Bsc_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'bsc_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Bsc_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Bsc_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Bsc_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Bsc_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Bsc_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bsc_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Bsc_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Bsc_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Bsc_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Bsc_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "bsc.liquidity_with_prices" */
export type Bsc_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Bsc_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Bsc_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'bsc_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "bsc.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Bsc_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Bsc_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Bsc_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'bsc_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Bsc_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'bsc_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "bsc.liquidity_with_prices". */
export type Bsc_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "bsc.liquidity_with_prices" */
export enum Bsc_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Bsc_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'bsc_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Bsc_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'bsc_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Bsc_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'bsc_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Bsc_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'bsc_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Bsc_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'bsc_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Bsc_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'bsc_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Bsc_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'bsc_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "bsc.loan_liquidations" */
export type Bsc_Loan_Liquidations = {
  __typename?: 'bsc_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "bsc.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Bsc_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Bsc_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.loan_liquidations". */
export type Bsc_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "bsc.loan_liquidations" */
export enum Bsc_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "bsc.pair_search" */
export type Bsc_Pair_Search = {
  __typename?: 'bsc_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Bsc_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Bsc_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "bsc.pair_search". All fields are combined with a logical 'AND'. */
export type Bsc_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Bsc_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Bsc_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Bsc_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.pair_search". */
export type Bsc_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Bsc_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Bsc_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "bsc.pair_search" */
export enum Bsc_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "bsc.pair_summary" */
export type Bsc_Pair_Summary = {
  __typename?: 'bsc_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Bsc_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Bsc_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "bsc.pair_summary". All fields are combined with a logical 'AND'. */
export type Bsc_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Bsc_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Bsc_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Bsc_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.pair_summary". */
export type Bsc_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Bsc_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Bsc_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "bsc.pair_summary" */
export enum Bsc_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "bsc.pair_with_prices_tb" */
export type Bsc_Pair_With_Prices_Tb = {
  __typename?: 'bsc_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "bsc.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Bsc_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Bsc_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.pair_with_prices_tb". */
export type Bsc_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "bsc.pair_with_prices_tb" */
export enum Bsc_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "bsc.pairs" */
export type Bsc_Pairs = {
  __typename?: 'bsc_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Bsc_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Bsc_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "bsc.pairs". All fields are combined with a logical 'AND'. */
export type Bsc_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Pairs_Bool_Exp>>;
  _not?: Maybe<Bsc_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Bsc_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Bsc_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.pairs". */
export type Bsc_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Bsc_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Bsc_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "bsc.pairs" */
export enum Bsc_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "bsc.pairs_tx_count" */
export type Bsc_Pairs_Tx_Count = {
  __typename?: 'bsc_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "bsc.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Bsc_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Bsc_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.pairs_tx_count". */
export type Bsc_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "bsc.pairs_tx_count" */
export enum Bsc_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "bsc.protocols" */
export type Bsc_Protocols = {
  __typename?: 'bsc_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "bsc.protocols". All fields are combined with a logical 'AND'. */
export type Bsc_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Protocols_Bool_Exp>>;
  _not?: Maybe<Bsc_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.protocols". */
export type Bsc_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "bsc.protocols" */
export enum Bsc_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "bsc.swap_candles_cached" */
export type Bsc_Swap_Candles_Cached = {
  __typename?: 'bsc_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "bsc.swap_candles_cached" */
export type Bsc_Swap_Candles_Cached_Aggregate = {
  __typename?: 'bsc_swap_candles_cached_aggregate';
  aggregate?: Maybe<Bsc_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Bsc_Swap_Candles_Cached>;
};

/** aggregate fields of "bsc.swap_candles_cached" */
export type Bsc_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'bsc_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Bsc_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Bsc_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Bsc_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Bsc_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Bsc_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bsc_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Bsc_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Bsc_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Bsc_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Bsc_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "bsc.swap_candles_cached" */
export type Bsc_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Bsc_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Bsc_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'bsc_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "bsc.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Bsc_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Bsc_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Bsc_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'bsc_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Bsc_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'bsc_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "bsc.swap_candles_cached". */
export type Bsc_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "bsc.swap_candles_cached" */
export enum Bsc_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Bsc_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'bsc_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Bsc_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'bsc_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Bsc_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'bsc_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Bsc_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'bsc_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Bsc_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'bsc_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Bsc_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'bsc_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Bsc_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'bsc_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "bsc.swap_candles_tb" */
export type Bsc_Swap_Candles_Tb = {
  __typename?: 'bsc_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "bsc.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Bsc_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Bsc_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.swap_candles_tb". */
export type Bsc_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "bsc.swap_candles_tb" */
export enum Bsc_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "bsc.tokens" */
export type Bsc_Tokens = {
  __typename?: 'bsc_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "bsc.tokens". All fields are combined with a logical 'AND'. */
export type Bsc_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Tokens_Bool_Exp>>;
  _not?: Maybe<Bsc_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "bsc.tokens". */
export type Bsc_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "bsc.tokens" */
export enum Bsc_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "bsc.tokenswaps_with_prices" */
export type Bsc_Tokenswaps_With_Prices = {
  __typename?: 'bsc_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "bsc.tokenswaps_with_prices" */
export type Bsc_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'bsc_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Bsc_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Bsc_Tokenswaps_With_Prices>;
};

/** aggregate fields of "bsc.tokenswaps_with_prices" */
export type Bsc_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Bsc_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Bsc_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Bsc_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Bsc_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Bsc_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Bsc_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Bsc_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Bsc_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Bsc_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Bsc_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "bsc.tokenswaps_with_prices" */
export type Bsc_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Bsc_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "bsc.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Bsc_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Bsc_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Bsc_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Bsc_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "bsc.tokenswaps_with_prices". */
export type Bsc_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "bsc.tokenswaps_with_prices" */
export enum Bsc_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Bsc_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Bsc_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Bsc_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Bsc_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Bsc_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Bsc_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Bsc_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'bsc_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.borrows" */
export type Dfk_Borrows = {
  __typename?: 'dfk_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "dfk.borrows". All fields are combined with a logical 'AND'. */
export type Dfk_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Borrows_Bool_Exp>>;
  _not?: Maybe<Dfk_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.borrows". */
export type Dfk_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "dfk.borrows" */
export enum Dfk_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Dfk_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Dfk_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Dfk_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "dfk.lending_market_daily_snapshots" */
export type Dfk_Lending_Market_Daily_Snapshots = {
  __typename?: 'dfk_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "dfk.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Dfk_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Dfk_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.lending_market_daily_snapshots". */
export type Dfk_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "dfk.lending_market_daily_snapshots" */
export enum Dfk_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "dfk.lending_market_user_count_tb" */
export type Dfk_Lending_Market_User_Count_Tb = {
  __typename?: 'dfk_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "dfk.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Dfk_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.lending_market_user_count_tb". */
export type Dfk_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "dfk.lending_market_user_count_tb" */
export enum Dfk_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "dfk.lending_supplies" */
export type Dfk_Lending_Supplies = {
  __typename?: 'dfk_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "dfk.lending_supplies". All fields are combined with a logical 'AND'. */
export type Dfk_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Dfk_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.lending_supplies". */
export type Dfk_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "dfk.lending_supplies" */
export enum Dfk_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "dfk.liquidity_changes" */
export type Dfk_Liquidity_Changes = {
  __typename?: 'dfk_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "dfk.liquidity_changes" */
export type Dfk_Liquidity_Changes_Aggregate = {
  __typename?: 'dfk_liquidity_changes_aggregate';
  aggregate?: Maybe<Dfk_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Dfk_Liquidity_Changes>;
};

/** aggregate fields of "dfk.liquidity_changes" */
export type Dfk_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'dfk_liquidity_changes_aggregate_fields';
  avg?: Maybe<Dfk_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Dfk_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Dfk_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Dfk_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "dfk.liquidity_changes" */
export type Dfk_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Liquidity_Changes_Avg_Fields = {
  __typename?: 'dfk_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Dfk_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Dfk_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Liquidity_Changes_Max_Fields = {
  __typename?: 'dfk_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Dfk_Liquidity_Changes_Min_Fields = {
  __typename?: 'dfk_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "dfk.liquidity_changes". */
export type Dfk_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "dfk.liquidity_changes" */
export enum Dfk_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Dfk_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'dfk_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'dfk_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'dfk_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Liquidity_Changes_Sum_Fields = {
  __typename?: 'dfk_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'dfk_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'dfk_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Liquidity_Changes_Variance_Fields = {
  __typename?: 'dfk_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.liquidity_with_prices" */
export type Dfk_Liquidity_With_Prices = {
  __typename?: 'dfk_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "dfk.liquidity_with_prices" */
export type Dfk_Liquidity_With_Prices_Aggregate = {
  __typename?: 'dfk_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Dfk_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Dfk_Liquidity_With_Prices>;
};

/** aggregate fields of "dfk.liquidity_with_prices" */
export type Dfk_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'dfk_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Dfk_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Dfk_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Dfk_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Dfk_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "dfk.liquidity_with_prices" */
export type Dfk_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'dfk_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Dfk_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Dfk_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'dfk_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Dfk_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'dfk_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "dfk.liquidity_with_prices". */
export type Dfk_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "dfk.liquidity_with_prices" */
export enum Dfk_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Dfk_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'dfk_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'dfk_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'dfk_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'dfk_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'dfk_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'dfk_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'dfk_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.loan_liquidations" */
export type Dfk_Loan_Liquidations = {
  __typename?: 'dfk_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "dfk.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Dfk_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Dfk_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.loan_liquidations". */
export type Dfk_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "dfk.loan_liquidations" */
export enum Dfk_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "dfk.pair_search" */
export type Dfk_Pair_Search = {
  __typename?: 'dfk_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Dfk_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Dfk_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "dfk.pair_search" */
export type Dfk_Pair_Search_Aggregate = {
  __typename?: 'dfk_pair_search_aggregate';
  aggregate?: Maybe<Dfk_Pair_Search_Aggregate_Fields>;
  nodes: Array<Dfk_Pair_Search>;
};

/** aggregate fields of "dfk.pair_search" */
export type Dfk_Pair_Search_Aggregate_Fields = {
  __typename?: 'dfk_pair_search_aggregate_fields';
  avg?: Maybe<Dfk_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Pair_Search_Max_Fields>;
  min?: Maybe<Dfk_Pair_Search_Min_Fields>;
  stddev?: Maybe<Dfk_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Dfk_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "dfk.pair_search" */
export type Dfk_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Pair_Search_Avg_Fields = {
  __typename?: 'dfk_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.pair_search". All fields are combined with a logical 'AND'. */
export type Dfk_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Dfk_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Dfk_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Dfk_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Pair_Search_Max_Fields = {
  __typename?: 'dfk_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Dfk_Pair_Search_Min_Fields = {
  __typename?: 'dfk_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "dfk.pair_search". */
export type Dfk_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Dfk_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Dfk_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "dfk.pair_search" */
export enum Dfk_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Dfk_Pair_Search_Stddev_Fields = {
  __typename?: 'dfk_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'dfk_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'dfk_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Pair_Search_Sum_Fields = {
  __typename?: 'dfk_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Pair_Search_Var_Pop_Fields = {
  __typename?: 'dfk_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Pair_Search_Var_Samp_Fields = {
  __typename?: 'dfk_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Pair_Search_Variance_Fields = {
  __typename?: 'dfk_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.pair_summary" */
export type Dfk_Pair_Summary = {
  __typename?: 'dfk_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Dfk_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Dfk_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "dfk.pair_summary" */
export type Dfk_Pair_Summary_Aggregate = {
  __typename?: 'dfk_pair_summary_aggregate';
  aggregate?: Maybe<Dfk_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Dfk_Pair_Summary>;
};

/** aggregate fields of "dfk.pair_summary" */
export type Dfk_Pair_Summary_Aggregate_Fields = {
  __typename?: 'dfk_pair_summary_aggregate_fields';
  avg?: Maybe<Dfk_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Pair_Summary_Max_Fields>;
  min?: Maybe<Dfk_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Dfk_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Dfk_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "dfk.pair_summary" */
export type Dfk_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Pair_Summary_Avg_Fields = {
  __typename?: 'dfk_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.pair_summary". All fields are combined with a logical 'AND'. */
export type Dfk_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Dfk_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Dfk_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Dfk_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Pair_Summary_Max_Fields = {
  __typename?: 'dfk_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Dfk_Pair_Summary_Min_Fields = {
  __typename?: 'dfk_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "dfk.pair_summary". */
export type Dfk_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Dfk_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Dfk_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "dfk.pair_summary" */
export enum Dfk_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Dfk_Pair_Summary_Stddev_Fields = {
  __typename?: 'dfk_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'dfk_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'dfk_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Pair_Summary_Sum_Fields = {
  __typename?: 'dfk_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'dfk_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'dfk_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Pair_Summary_Variance_Fields = {
  __typename?: 'dfk_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.pair_with_prices_tb" */
export type Dfk_Pair_With_Prices_Tb = {
  __typename?: 'dfk_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "dfk.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Dfk_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Dfk_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.pair_with_prices_tb". */
export type Dfk_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "dfk.pair_with_prices_tb" */
export enum Dfk_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "dfk.pairs" */
export type Dfk_Pairs = {
  __typename?: 'dfk_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Dfk_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Dfk_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "dfk.pairs". All fields are combined with a logical 'AND'. */
export type Dfk_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Pairs_Bool_Exp>>;
  _not?: Maybe<Dfk_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Dfk_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Dfk_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.pairs". */
export type Dfk_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Dfk_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Dfk_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "dfk.pairs" */
export enum Dfk_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "dfk.pairs_tx_count" */
export type Dfk_Pairs_Tx_Count = {
  __typename?: 'dfk_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "dfk.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Dfk_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Dfk_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.pairs_tx_count". */
export type Dfk_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "dfk.pairs_tx_count" */
export enum Dfk_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "dfk.protocols" */
export type Dfk_Protocols = {
  __typename?: 'dfk_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "dfk.protocols". All fields are combined with a logical 'AND'. */
export type Dfk_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Protocols_Bool_Exp>>;
  _not?: Maybe<Dfk_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.protocols". */
export type Dfk_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "dfk.protocols" */
export enum Dfk_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "dfk.swap_candles_cached" */
export type Dfk_Swap_Candles_Cached = {
  __typename?: 'dfk_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "dfk.swap_candles_cached" */
export type Dfk_Swap_Candles_Cached_Aggregate = {
  __typename?: 'dfk_swap_candles_cached_aggregate';
  aggregate?: Maybe<Dfk_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Dfk_Swap_Candles_Cached>;
};

/** aggregate fields of "dfk.swap_candles_cached" */
export type Dfk_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'dfk_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Dfk_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Dfk_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Dfk_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Dfk_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "dfk.swap_candles_cached" */
export type Dfk_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'dfk_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Dfk_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Dfk_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'dfk_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Dfk_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'dfk_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "dfk.swap_candles_cached". */
export type Dfk_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "dfk.swap_candles_cached" */
export enum Dfk_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Dfk_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'dfk_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'dfk_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'dfk_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'dfk_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'dfk_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'dfk_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'dfk_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.swap_candles_tb" */
export type Dfk_Swap_Candles_Tb = {
  __typename?: 'dfk_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "dfk.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Dfk_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Dfk_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.swap_candles_tb". */
export type Dfk_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "dfk.swap_candles_tb" */
export enum Dfk_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "dfk.tokens" */
export type Dfk_Tokens = {
  __typename?: 'dfk_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "dfk.tokens". All fields are combined with a logical 'AND'. */
export type Dfk_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Tokens_Bool_Exp>>;
  _not?: Maybe<Dfk_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.tokens". */
export type Dfk_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "dfk.tokens" */
export enum Dfk_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "dfk.tokenswaps_with_prices" */
export type Dfk_Tokenswaps_With_Prices = {
  __typename?: 'dfk_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "dfk.tokenswaps_with_prices" */
export type Dfk_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'dfk_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Dfk_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Dfk_Tokenswaps_With_Prices>;
};

/** aggregate fields of "dfk.tokenswaps_with_prices" */
export type Dfk_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Dfk_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dfk_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Dfk_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Dfk_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Dfk_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dfk_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Dfk_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Dfk_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Dfk_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Dfk_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "dfk.tokenswaps_with_prices" */
export type Dfk_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dfk_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dfk.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Dfk_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Dfk_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Dfk_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Dfk_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "dfk.tokenswaps_with_prices". */
export type Dfk_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "dfk.tokenswaps_with_prices" */
export enum Dfk_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Dfk_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dfk_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dfk_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Dfk_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Dfk_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dfk_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dfk_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'dfk_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "dfk.usd_tokens" */
export type Dfk_Usd_Tokens = {
  __typename?: 'dfk_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "dfk.usd_tokens". All fields are combined with a logical 'AND'. */
export type Dfk_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Dfk_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Dfk_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Dfk_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "dfk.usd_tokens". */
export type Dfk_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "dfk.usd_tokens" */
export enum Dfk_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** columns and relationships of "ethereum.borrows" */
export type Ethereum_Borrows = {
  __typename?: 'ethereum_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "ethereum.borrows". All fields are combined with a logical 'AND'. */
export type Ethereum_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Borrows_Bool_Exp>>;
  _not?: Maybe<Ethereum_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.borrows". */
export type Ethereum_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "ethereum.borrows" */
export enum Ethereum_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Ethereum_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Ethereum_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Ethereum_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "ethereum.lending_market_daily_snapshots" */
export type Ethereum_Lending_Market_Daily_Snapshots = {
  __typename?: 'ethereum_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "ethereum.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.lending_market_daily_snapshots". */
export type Ethereum_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "ethereum.lending_market_daily_snapshots" */
export enum Ethereum_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "ethereum.lending_market_user_count_tb" */
export type Ethereum_Lending_Market_User_Count_Tb = {
  __typename?: 'ethereum_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "ethereum.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Ethereum_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.lending_market_user_count_tb". */
export type Ethereum_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "ethereum.lending_market_user_count_tb" */
export enum Ethereum_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "ethereum.lending_supplies" */
export type Ethereum_Lending_Supplies = {
  __typename?: 'ethereum_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "ethereum.lending_supplies". All fields are combined with a logical 'AND'. */
export type Ethereum_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Ethereum_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.lending_supplies". */
export type Ethereum_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "ethereum.lending_supplies" */
export enum Ethereum_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "ethereum.liquidity_changes" */
export type Ethereum_Liquidity_Changes = {
  __typename?: 'ethereum_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "ethereum.liquidity_changes" */
export type Ethereum_Liquidity_Changes_Aggregate = {
  __typename?: 'ethereum_liquidity_changes_aggregate';
  aggregate?: Maybe<Ethereum_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Ethereum_Liquidity_Changes>;
};

/** aggregate fields of "ethereum.liquidity_changes" */
export type Ethereum_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'ethereum_liquidity_changes_aggregate_fields';
  avg?: Maybe<Ethereum_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Ethereum_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Ethereum_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "ethereum.liquidity_changes" */
export type Ethereum_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Liquidity_Changes_Avg_Fields = {
  __typename?: 'ethereum_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Ethereum_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Ethereum_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Liquidity_Changes_Max_Fields = {
  __typename?: 'ethereum_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Ethereum_Liquidity_Changes_Min_Fields = {
  __typename?: 'ethereum_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "ethereum.liquidity_changes". */
export type Ethereum_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "ethereum.liquidity_changes" */
export enum Ethereum_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Ethereum_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'ethereum_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'ethereum_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'ethereum_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Liquidity_Changes_Sum_Fields = {
  __typename?: 'ethereum_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'ethereum_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'ethereum_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Liquidity_Changes_Variance_Fields = {
  __typename?: 'ethereum_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.liquidity_with_prices" */
export type Ethereum_Liquidity_With_Prices = {
  __typename?: 'ethereum_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ethereum.liquidity_with_prices" */
export type Ethereum_Liquidity_With_Prices_Aggregate = {
  __typename?: 'ethereum_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Ethereum_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Ethereum_Liquidity_With_Prices>;
};

/** aggregate fields of "ethereum.liquidity_with_prices" */
export type Ethereum_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Ethereum_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Ethereum_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Ethereum_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "ethereum.liquidity_with_prices" */
export type Ethereum_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Ethereum_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Ethereum_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Ethereum_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "ethereum.liquidity_with_prices". */
export type Ethereum_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "ethereum.liquidity_with_prices" */
export enum Ethereum_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Ethereum_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'ethereum_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.loan_liquidations" */
export type Ethereum_Loan_Liquidations = {
  __typename?: 'ethereum_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "ethereum.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Ethereum_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Ethereum_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.loan_liquidations". */
export type Ethereum_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "ethereum.loan_liquidations" */
export enum Ethereum_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "ethereum.pair_search" */
export type Ethereum_Pair_Search = {
  __typename?: 'ethereum_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Ethereum_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Ethereum_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "ethereum.pair_search" */
export type Ethereum_Pair_Search_Aggregate = {
  __typename?: 'ethereum_pair_search_aggregate';
  aggregate?: Maybe<Ethereum_Pair_Search_Aggregate_Fields>;
  nodes: Array<Ethereum_Pair_Search>;
};

/** aggregate fields of "ethereum.pair_search" */
export type Ethereum_Pair_Search_Aggregate_Fields = {
  __typename?: 'ethereum_pair_search_aggregate_fields';
  avg?: Maybe<Ethereum_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Pair_Search_Max_Fields>;
  min?: Maybe<Ethereum_Pair_Search_Min_Fields>;
  stddev?: Maybe<Ethereum_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "ethereum.pair_search" */
export type Ethereum_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Pair_Search_Avg_Fields = {
  __typename?: 'ethereum_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.pair_search". All fields are combined with a logical 'AND'. */
export type Ethereum_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Ethereum_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Pair_Search_Max_Fields = {
  __typename?: 'ethereum_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Ethereum_Pair_Search_Min_Fields = {
  __typename?: 'ethereum_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "ethereum.pair_search". */
export type Ethereum_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Ethereum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Ethereum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "ethereum.pair_search" */
export enum Ethereum_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Ethereum_Pair_Search_Stddev_Fields = {
  __typename?: 'ethereum_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'ethereum_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'ethereum_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Pair_Search_Sum_Fields = {
  __typename?: 'ethereum_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Pair_Search_Var_Pop_Fields = {
  __typename?: 'ethereum_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Pair_Search_Var_Samp_Fields = {
  __typename?: 'ethereum_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Pair_Search_Variance_Fields = {
  __typename?: 'ethereum_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.pair_summary" */
export type Ethereum_Pair_Summary = {
  __typename?: 'ethereum_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Ethereum_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Ethereum_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "ethereum.pair_summary" */
export type Ethereum_Pair_Summary_Aggregate = {
  __typename?: 'ethereum_pair_summary_aggregate';
  aggregate?: Maybe<Ethereum_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Ethereum_Pair_Summary>;
};

/** aggregate fields of "ethereum.pair_summary" */
export type Ethereum_Pair_Summary_Aggregate_Fields = {
  __typename?: 'ethereum_pair_summary_aggregate_fields';
  avg?: Maybe<Ethereum_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Pair_Summary_Max_Fields>;
  min?: Maybe<Ethereum_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Ethereum_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "ethereum.pair_summary" */
export type Ethereum_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Pair_Summary_Avg_Fields = {
  __typename?: 'ethereum_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.pair_summary". All fields are combined with a logical 'AND'. */
export type Ethereum_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Ethereum_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Pair_Summary_Max_Fields = {
  __typename?: 'ethereum_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Ethereum_Pair_Summary_Min_Fields = {
  __typename?: 'ethereum_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "ethereum.pair_summary". */
export type Ethereum_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Ethereum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Ethereum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "ethereum.pair_summary" */
export enum Ethereum_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Ethereum_Pair_Summary_Stddev_Fields = {
  __typename?: 'ethereum_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'ethereum_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'ethereum_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Pair_Summary_Sum_Fields = {
  __typename?: 'ethereum_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'ethereum_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'ethereum_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Pair_Summary_Variance_Fields = {
  __typename?: 'ethereum_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.pair_with_prices_tb" */
export type Ethereum_Pair_With_Prices_Tb = {
  __typename?: 'ethereum_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "ethereum.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Ethereum_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Ethereum_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.pair_with_prices_tb". */
export type Ethereum_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "ethereum.pair_with_prices_tb" */
export enum Ethereum_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "ethereum.pairs" */
export type Ethereum_Pairs = {
  __typename?: 'ethereum_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Ethereum_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Ethereum_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "ethereum.pairs". All fields are combined with a logical 'AND'. */
export type Ethereum_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Pairs_Bool_Exp>>;
  _not?: Maybe<Ethereum_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Ethereum_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.pairs". */
export type Ethereum_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Ethereum_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Ethereum_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "ethereum.pairs" */
export enum Ethereum_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "ethereum.pairs_tx_count" */
export type Ethereum_Pairs_Tx_Count = {
  __typename?: 'ethereum_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "ethereum.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Ethereum_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Ethereum_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.pairs_tx_count". */
export type Ethereum_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "ethereum.pairs_tx_count" */
export enum Ethereum_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "ethereum.protocols" */
export type Ethereum_Protocols = {
  __typename?: 'ethereum_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "ethereum.protocols". All fields are combined with a logical 'AND'. */
export type Ethereum_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Protocols_Bool_Exp>>;
  _not?: Maybe<Ethereum_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.protocols". */
export type Ethereum_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "ethereum.protocols" */
export enum Ethereum_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "ethereum.swap_candles_cached" */
export type Ethereum_Swap_Candles_Cached = {
  __typename?: 'ethereum_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "ethereum.swap_candles_cached" */
export type Ethereum_Swap_Candles_Cached_Aggregate = {
  __typename?: 'ethereum_swap_candles_cached_aggregate';
  aggregate?: Maybe<Ethereum_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Ethereum_Swap_Candles_Cached>;
};

/** aggregate fields of "ethereum.swap_candles_cached" */
export type Ethereum_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'ethereum_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Ethereum_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Ethereum_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Ethereum_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "ethereum.swap_candles_cached" */
export type Ethereum_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'ethereum_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Ethereum_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Ethereum_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'ethereum_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Ethereum_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'ethereum_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "ethereum.swap_candles_cached". */
export type Ethereum_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "ethereum.swap_candles_cached" */
export enum Ethereum_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Ethereum_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'ethereum_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'ethereum_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'ethereum_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'ethereum_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'ethereum_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'ethereum_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'ethereum_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.swap_candles_tb" */
export type Ethereum_Swap_Candles_Tb = {
  __typename?: 'ethereum_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "ethereum.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Ethereum_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Ethereum_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.swap_candles_tb". */
export type Ethereum_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "ethereum.swap_candles_tb" */
export enum Ethereum_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "ethereum.tokens" */
export type Ethereum_Tokens = {
  __typename?: 'ethereum_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "ethereum.tokens". All fields are combined with a logical 'AND'. */
export type Ethereum_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Tokens_Bool_Exp>>;
  _not?: Maybe<Ethereum_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.tokens". */
export type Ethereum_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "ethereum.tokens" */
export enum Ethereum_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "ethereum.tokenswaps_with_prices" */
export type Ethereum_Tokenswaps_With_Prices = {
  __typename?: 'ethereum_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "ethereum.tokenswaps_with_prices" */
export type Ethereum_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'ethereum_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Ethereum_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Ethereum_Tokenswaps_With_Prices>;
};

/** aggregate fields of "ethereum.tokenswaps_with_prices" */
export type Ethereum_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Ethereum_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ethereum_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Ethereum_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Ethereum_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Ethereum_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ethereum_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Ethereum_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Ethereum_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Ethereum_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Ethereum_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "ethereum.tokenswaps_with_prices" */
export type Ethereum_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ethereum_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "ethereum.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Ethereum_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Ethereum_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Ethereum_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Ethereum_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "ethereum.tokenswaps_with_prices". */
export type Ethereum_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "ethereum.tokenswaps_with_prices" */
export enum Ethereum_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Ethereum_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ethereum_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ethereum_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Ethereum_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Ethereum_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ethereum_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ethereum_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'ethereum_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ethereum.usd_tokens" */
export type Ethereum_Usd_Tokens = {
  __typename?: 'ethereum_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "ethereum.usd_tokens". All fields are combined with a logical 'AND'. */
export type Ethereum_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Ethereum_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Ethereum_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Ethereum_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "ethereum.usd_tokens". */
export type Ethereum_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "ethereum.usd_tokens" */
export enum Ethereum_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** columns and relationships of "metis.borrows" */
export type Metis_Borrows = {
  __typename?: 'metis_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "metis.borrows". All fields are combined with a logical 'AND'. */
export type Metis_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Metis_Borrows_Bool_Exp>>;
  _not?: Maybe<Metis_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Metis_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.borrows". */
export type Metis_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "metis.borrows" */
export enum Metis_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Metis_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Metis_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Metis_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "metis.lending_market_daily_snapshots" */
export type Metis_Lending_Market_Daily_Snapshots = {
  __typename?: 'metis_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "metis.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Metis_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Metis_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.lending_market_daily_snapshots". */
export type Metis_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "metis.lending_market_daily_snapshots" */
export enum Metis_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "metis.lending_market_user_count_tb" */
export type Metis_Lending_Market_User_Count_Tb = {
  __typename?: 'metis_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "metis.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Metis_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Metis_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.lending_market_user_count_tb". */
export type Metis_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "metis.lending_market_user_count_tb" */
export enum Metis_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "metis.lending_supplies" */
export type Metis_Lending_Supplies = {
  __typename?: 'metis_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "metis.lending_supplies". All fields are combined with a logical 'AND'. */
export type Metis_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Metis_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Metis_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Metis_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.lending_supplies". */
export type Metis_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "metis.lending_supplies" */
export enum Metis_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "metis.liquidity_changes" */
export type Metis_Liquidity_Changes = {
  __typename?: 'metis_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "metis.liquidity_changes" */
export type Metis_Liquidity_Changes_Aggregate = {
  __typename?: 'metis_liquidity_changes_aggregate';
  aggregate?: Maybe<Metis_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Metis_Liquidity_Changes>;
};

/** aggregate fields of "metis.liquidity_changes" */
export type Metis_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'metis_liquidity_changes_aggregate_fields';
  avg?: Maybe<Metis_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Metis_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Metis_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Metis_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Metis_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "metis.liquidity_changes" */
export type Metis_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Liquidity_Changes_Avg_Fields = {
  __typename?: 'metis_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Metis_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Metis_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Metis_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Metis_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Liquidity_Changes_Max_Fields = {
  __typename?: 'metis_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Metis_Liquidity_Changes_Min_Fields = {
  __typename?: 'metis_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "metis.liquidity_changes". */
export type Metis_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "metis.liquidity_changes" */
export enum Metis_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Metis_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'metis_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'metis_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'metis_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Liquidity_Changes_Sum_Fields = {
  __typename?: 'metis_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'metis_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'metis_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Liquidity_Changes_Variance_Fields = {
  __typename?: 'metis_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.liquidity_with_prices" */
export type Metis_Liquidity_With_Prices = {
  __typename?: 'metis_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "metis.liquidity_with_prices" */
export type Metis_Liquidity_With_Prices_Aggregate = {
  __typename?: 'metis_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Metis_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Metis_Liquidity_With_Prices>;
};

/** aggregate fields of "metis.liquidity_with_prices" */
export type Metis_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'metis_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Metis_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Metis_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Metis_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Metis_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Metis_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "metis.liquidity_with_prices" */
export type Metis_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'metis_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Metis_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Metis_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Metis_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Metis_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'metis_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Metis_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'metis_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "metis.liquidity_with_prices". */
export type Metis_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "metis.liquidity_with_prices" */
export enum Metis_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Metis_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'metis_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'metis_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'metis_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'metis_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'metis_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'metis_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'metis_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.loan_liquidations" */
export type Metis_Loan_Liquidations = {
  __typename?: 'metis_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "metis.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Metis_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Metis_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Metis_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Metis_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.loan_liquidations". */
export type Metis_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "metis.loan_liquidations" */
export enum Metis_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "metis.pair_search" */
export type Metis_Pair_Search = {
  __typename?: 'metis_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Metis_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Metis_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "metis.pair_search" */
export type Metis_Pair_Search_Aggregate = {
  __typename?: 'metis_pair_search_aggregate';
  aggregate?: Maybe<Metis_Pair_Search_Aggregate_Fields>;
  nodes: Array<Metis_Pair_Search>;
};

/** aggregate fields of "metis.pair_search" */
export type Metis_Pair_Search_Aggregate_Fields = {
  __typename?: 'metis_pair_search_aggregate_fields';
  avg?: Maybe<Metis_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Pair_Search_Max_Fields>;
  min?: Maybe<Metis_Pair_Search_Min_Fields>;
  stddev?: Maybe<Metis_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Metis_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Metis_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "metis.pair_search" */
export type Metis_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Pair_Search_Avg_Fields = {
  __typename?: 'metis_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.pair_search". All fields are combined with a logical 'AND'. */
export type Metis_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Metis_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Metis_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Metis_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Metis_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Metis_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Pair_Search_Max_Fields = {
  __typename?: 'metis_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Metis_Pair_Search_Min_Fields = {
  __typename?: 'metis_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "metis.pair_search". */
export type Metis_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Metis_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Metis_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "metis.pair_search" */
export enum Metis_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Metis_Pair_Search_Stddev_Fields = {
  __typename?: 'metis_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'metis_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'metis_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Pair_Search_Sum_Fields = {
  __typename?: 'metis_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Pair_Search_Var_Pop_Fields = {
  __typename?: 'metis_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Pair_Search_Var_Samp_Fields = {
  __typename?: 'metis_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Pair_Search_Variance_Fields = {
  __typename?: 'metis_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.pair_summary" */
export type Metis_Pair_Summary = {
  __typename?: 'metis_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Metis_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Metis_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "metis.pair_summary" */
export type Metis_Pair_Summary_Aggregate = {
  __typename?: 'metis_pair_summary_aggregate';
  aggregate?: Maybe<Metis_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Metis_Pair_Summary>;
};

/** aggregate fields of "metis.pair_summary" */
export type Metis_Pair_Summary_Aggregate_Fields = {
  __typename?: 'metis_pair_summary_aggregate_fields';
  avg?: Maybe<Metis_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Pair_Summary_Max_Fields>;
  min?: Maybe<Metis_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Metis_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Metis_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Metis_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "metis.pair_summary" */
export type Metis_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Pair_Summary_Avg_Fields = {
  __typename?: 'metis_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.pair_summary". All fields are combined with a logical 'AND'. */
export type Metis_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Metis_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Metis_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Metis_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Metis_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Metis_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Pair_Summary_Max_Fields = {
  __typename?: 'metis_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Metis_Pair_Summary_Min_Fields = {
  __typename?: 'metis_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "metis.pair_summary". */
export type Metis_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Metis_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Metis_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "metis.pair_summary" */
export enum Metis_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Metis_Pair_Summary_Stddev_Fields = {
  __typename?: 'metis_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'metis_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'metis_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Pair_Summary_Sum_Fields = {
  __typename?: 'metis_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'metis_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'metis_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Pair_Summary_Variance_Fields = {
  __typename?: 'metis_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.pair_with_prices_tb" */
export type Metis_Pair_With_Prices_Tb = {
  __typename?: 'metis_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "metis.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Metis_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Metis_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Metis_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Metis_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.pair_with_prices_tb". */
export type Metis_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "metis.pair_with_prices_tb" */
export enum Metis_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "metis.pairs" */
export type Metis_Pairs = {
  __typename?: 'metis_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Metis_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Metis_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "metis.pairs". All fields are combined with a logical 'AND'. */
export type Metis_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Metis_Pairs_Bool_Exp>>;
  _not?: Maybe<Metis_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Metis_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Metis_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Metis_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.pairs". */
export type Metis_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Metis_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Metis_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "metis.pairs" */
export enum Metis_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "metis.pairs_tx_count" */
export type Metis_Pairs_Tx_Count = {
  __typename?: 'metis_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "metis.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Metis_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Metis_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Metis_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Metis_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.pairs_tx_count". */
export type Metis_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "metis.pairs_tx_count" */
export enum Metis_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "metis.protocols" */
export type Metis_Protocols = {
  __typename?: 'metis_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "metis.protocols". All fields are combined with a logical 'AND'. */
export type Metis_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Metis_Protocols_Bool_Exp>>;
  _not?: Maybe<Metis_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Metis_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.protocols". */
export type Metis_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "metis.protocols" */
export enum Metis_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "metis.swap_candles_cached" */
export type Metis_Swap_Candles_Cached = {
  __typename?: 'metis_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "metis.swap_candles_cached" */
export type Metis_Swap_Candles_Cached_Aggregate = {
  __typename?: 'metis_swap_candles_cached_aggregate';
  aggregate?: Maybe<Metis_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Metis_Swap_Candles_Cached>;
};

/** aggregate fields of "metis.swap_candles_cached" */
export type Metis_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'metis_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Metis_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Metis_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Metis_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Metis_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Metis_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "metis.swap_candles_cached" */
export type Metis_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'metis_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Metis_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Metis_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Metis_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Metis_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'metis_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Metis_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'metis_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "metis.swap_candles_cached". */
export type Metis_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "metis.swap_candles_cached" */
export enum Metis_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Metis_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'metis_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'metis_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'metis_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'metis_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'metis_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'metis_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'metis_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.swap_candles_tb" */
export type Metis_Swap_Candles_Tb = {
  __typename?: 'metis_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "metis.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Metis_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Metis_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Metis_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Metis_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.swap_candles_tb". */
export type Metis_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "metis.swap_candles_tb" */
export enum Metis_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "metis.tokens" */
export type Metis_Tokens = {
  __typename?: 'metis_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "metis.tokens". All fields are combined with a logical 'AND'. */
export type Metis_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Metis_Tokens_Bool_Exp>>;
  _not?: Maybe<Metis_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Metis_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.tokens". */
export type Metis_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "metis.tokens" */
export enum Metis_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "metis.tokenswaps_with_prices" */
export type Metis_Tokenswaps_With_Prices = {
  __typename?: 'metis_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "metis.tokenswaps_with_prices" */
export type Metis_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'metis_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Metis_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Metis_Tokenswaps_With_Prices>;
};

/** aggregate fields of "metis.tokenswaps_with_prices" */
export type Metis_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Metis_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Metis_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Metis_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Metis_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Metis_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Metis_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Metis_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Metis_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Metis_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Metis_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "metis.tokenswaps_with_prices" */
export type Metis_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Metis_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Metis_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "metis.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Metis_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Metis_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Metis_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Metis_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Metis_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Metis_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "metis.tokenswaps_with_prices". */
export type Metis_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "metis.tokenswaps_with_prices" */
export enum Metis_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Metis_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Metis_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Metis_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Metis_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Metis_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Metis_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Metis_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'metis_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "metis.usd_tokens" */
export type Metis_Usd_Tokens = {
  __typename?: 'metis_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "metis.usd_tokens". All fields are combined with a logical 'AND'. */
export type Metis_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Metis_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Metis_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Metis_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "metis.usd_tokens". */
export type Metis_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "metis.usd_tokens" */
export enum Metis_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** columns and relationships of "moonbeam.borrows" */
export type Moonbeam_Borrows = {
  __typename?: 'moonbeam_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonbeam.borrows". All fields are combined with a logical 'AND'. */
export type Moonbeam_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Borrows_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.borrows". */
export type Moonbeam_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.borrows" */
export enum Moonbeam_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Moonbeam_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Moonbeam_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Moonbeam_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "moonbeam.lending_market_daily_snapshots" */
export type Moonbeam_Lending_Market_Daily_Snapshots = {
  __typename?: 'moonbeam_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "moonbeam.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.lending_market_daily_snapshots". */
export type Moonbeam_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.lending_market_daily_snapshots" */
export enum Moonbeam_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "moonbeam.lending_market_user_count_tb" */
export type Moonbeam_Lending_Market_User_Count_Tb = {
  __typename?: 'moonbeam_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "moonbeam.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.lending_market_user_count_tb". */
export type Moonbeam_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.lending_market_user_count_tb" */
export enum Moonbeam_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "moonbeam.lending_supplies" */
export type Moonbeam_Lending_Supplies = {
  __typename?: 'moonbeam_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "moonbeam.lending_supplies". All fields are combined with a logical 'AND'. */
export type Moonbeam_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.lending_supplies". */
export type Moonbeam_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.lending_supplies" */
export enum Moonbeam_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "moonbeam.liquidity_changes" */
export type Moonbeam_Liquidity_Changes = {
  __typename?: 'moonbeam_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "moonbeam.liquidity_changes" */
export type Moonbeam_Liquidity_Changes_Aggregate = {
  __typename?: 'moonbeam_liquidity_changes_aggregate';
  aggregate?: Maybe<Moonbeam_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Moonbeam_Liquidity_Changes>;
};

/** aggregate fields of "moonbeam.liquidity_changes" */
export type Moonbeam_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'moonbeam_liquidity_changes_aggregate_fields';
  avg?: Maybe<Moonbeam_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonbeam_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Moonbeam_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Moonbeam_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Moonbeam_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonbeam_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Moonbeam_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Moonbeam_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Moonbeam_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Moonbeam_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "moonbeam.liquidity_changes" */
export type Moonbeam_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonbeam_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonbeam_Liquidity_Changes_Avg_Fields = {
  __typename?: 'moonbeam_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonbeam.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Moonbeam_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonbeam_Liquidity_Changes_Max_Fields = {
  __typename?: 'moonbeam_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Moonbeam_Liquidity_Changes_Min_Fields = {
  __typename?: 'moonbeam_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "moonbeam.liquidity_changes". */
export type Moonbeam_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.liquidity_changes" */
export enum Moonbeam_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Moonbeam_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'moonbeam_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonbeam_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'moonbeam_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonbeam_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'moonbeam_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonbeam_Liquidity_Changes_Sum_Fields = {
  __typename?: 'moonbeam_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonbeam_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'moonbeam_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonbeam_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'moonbeam_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonbeam_Liquidity_Changes_Variance_Fields = {
  __typename?: 'moonbeam_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonbeam.liquidity_with_prices" */
export type Moonbeam_Liquidity_With_Prices = {
  __typename?: 'moonbeam_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "moonbeam.liquidity_with_prices" */
export type Moonbeam_Liquidity_With_Prices_Aggregate = {
  __typename?: 'moonbeam_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Moonbeam_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Moonbeam_Liquidity_With_Prices>;
};

/** aggregate fields of "moonbeam.liquidity_with_prices" */
export type Moonbeam_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Moonbeam_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonbeam_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Moonbeam_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Moonbeam_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Moonbeam_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonbeam_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Moonbeam_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Moonbeam_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Moonbeam_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Moonbeam_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "moonbeam.liquidity_with_prices" */
export type Moonbeam_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonbeam_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonbeam.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Moonbeam_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonbeam_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Moonbeam_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "moonbeam.liquidity_with_prices". */
export type Moonbeam_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.liquidity_with_prices" */
export enum Moonbeam_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Moonbeam_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonbeam_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonbeam_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonbeam_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonbeam_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonbeam_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonbeam_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'moonbeam_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonbeam.loan_liquidations" */
export type Moonbeam_Loan_Liquidations = {
  __typename?: 'moonbeam_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonbeam.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Moonbeam_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.loan_liquidations". */
export type Moonbeam_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.loan_liquidations" */
export enum Moonbeam_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonbeam.pair_search" */
export type Moonbeam_Pair_Search = {
  __typename?: 'moonbeam_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Moonbeam_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonbeam_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonbeam.pair_search". All fields are combined with a logical 'AND'. */
export type Moonbeam_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.pair_search". */
export type Moonbeam_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Moonbeam_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Moonbeam_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.pair_search" */
export enum Moonbeam_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "moonbeam.pair_summary" */
export type Moonbeam_Pair_Summary = {
  __typename?: 'moonbeam_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Moonbeam_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonbeam_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonbeam.pair_summary". All fields are combined with a logical 'AND'. */
export type Moonbeam_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.pair_summary". */
export type Moonbeam_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Moonbeam_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Moonbeam_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.pair_summary" */
export enum Moonbeam_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "moonbeam.pair_with_prices_tb" */
export type Moonbeam_Pair_With_Prices_Tb = {
  __typename?: 'moonbeam_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "moonbeam.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Moonbeam_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.pair_with_prices_tb". */
export type Moonbeam_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.pair_with_prices_tb" */
export enum Moonbeam_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "moonbeam.pairs" */
export type Moonbeam_Pairs = {
  __typename?: 'moonbeam_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Moonbeam_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonbeam_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonbeam.pairs". All fields are combined with a logical 'AND'. */
export type Moonbeam_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Pairs_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.pairs". */
export type Moonbeam_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Moonbeam_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Moonbeam_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.pairs" */
export enum Moonbeam_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonbeam.pairs_tx_count" */
export type Moonbeam_Pairs_Tx_Count = {
  __typename?: 'moonbeam_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "moonbeam.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Moonbeam_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.pairs_tx_count". */
export type Moonbeam_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.pairs_tx_count" */
export enum Moonbeam_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "moonbeam.protocols" */
export type Moonbeam_Protocols = {
  __typename?: 'moonbeam_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "moonbeam.protocols". All fields are combined with a logical 'AND'. */
export type Moonbeam_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Protocols_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.protocols". */
export type Moonbeam_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.protocols" */
export enum Moonbeam_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "moonbeam.swap_candles_cached" */
export type Moonbeam_Swap_Candles_Cached = {
  __typename?: 'moonbeam_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "moonbeam.swap_candles_cached" */
export type Moonbeam_Swap_Candles_Cached_Aggregate = {
  __typename?: 'moonbeam_swap_candles_cached_aggregate';
  aggregate?: Maybe<Moonbeam_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Moonbeam_Swap_Candles_Cached>;
};

/** aggregate fields of "moonbeam.swap_candles_cached" */
export type Moonbeam_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Moonbeam_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonbeam_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Moonbeam_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Moonbeam_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Moonbeam_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonbeam_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Moonbeam_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Moonbeam_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Moonbeam_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Moonbeam_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "moonbeam.swap_candles_cached" */
export type Moonbeam_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonbeam_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonbeam.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Moonbeam_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonbeam_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Moonbeam_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "moonbeam.swap_candles_cached". */
export type Moonbeam_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.swap_candles_cached" */
export enum Moonbeam_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Moonbeam_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonbeam_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonbeam_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonbeam_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonbeam_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonbeam_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonbeam_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'moonbeam_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonbeam.swap_candles_tb" */
export type Moonbeam_Swap_Candles_Tb = {
  __typename?: 'moonbeam_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonbeam.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Moonbeam_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.swap_candles_tb". */
export type Moonbeam_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.swap_candles_tb" */
export enum Moonbeam_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "moonbeam.tokens" */
export type Moonbeam_Tokens = {
  __typename?: 'moonbeam_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonbeam.tokens". All fields are combined with a logical 'AND'. */
export type Moonbeam_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Tokens_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonbeam.tokens". */
export type Moonbeam_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.tokens" */
export enum Moonbeam_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonbeam.tokenswaps_with_prices" */
export type Moonbeam_Tokenswaps_With_Prices = {
  __typename?: 'moonbeam_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "moonbeam.tokenswaps_with_prices" */
export type Moonbeam_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'moonbeam_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Moonbeam_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Moonbeam_Tokenswaps_With_Prices>;
};

/** aggregate fields of "moonbeam.tokenswaps_with_prices" */
export type Moonbeam_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Moonbeam_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonbeam_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Moonbeam_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Moonbeam_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Moonbeam_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonbeam_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Moonbeam_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Moonbeam_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Moonbeam_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Moonbeam_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "moonbeam.tokenswaps_with_prices" */
export type Moonbeam_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonbeam_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonbeam.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Moonbeam_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonbeam_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Moonbeam_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "moonbeam.tokenswaps_with_prices". */
export type Moonbeam_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "moonbeam.tokenswaps_with_prices" */
export enum Moonbeam_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Moonbeam_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonbeam_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonbeam_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonbeam_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonbeam_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonbeam_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonbeam_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'moonbeam_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonriver.borrows" */
export type Moonriver_Borrows = {
  __typename?: 'moonriver_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonriver.borrows". All fields are combined with a logical 'AND'. */
export type Moonriver_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Borrows_Bool_Exp>>;
  _not?: Maybe<Moonriver_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.borrows". */
export type Moonriver_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonriver.borrows" */
export enum Moonriver_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Moonriver_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Moonriver_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Moonriver_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "moonriver.lending_market_daily_snapshots" */
export type Moonriver_Lending_Market_Daily_Snapshots = {
  __typename?: 'moonriver_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "moonriver.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.lending_market_daily_snapshots". */
export type Moonriver_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "moonriver.lending_market_daily_snapshots" */
export enum Moonriver_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "moonriver.lending_market_user_count_tb" */
export type Moonriver_Lending_Market_User_Count_Tb = {
  __typename?: 'moonriver_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "moonriver.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Moonriver_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.lending_market_user_count_tb". */
export type Moonriver_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "moonriver.lending_market_user_count_tb" */
export enum Moonriver_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "moonriver.lending_supplies" */
export type Moonriver_Lending_Supplies = {
  __typename?: 'moonriver_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "moonriver.lending_supplies". All fields are combined with a logical 'AND'. */
export type Moonriver_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Moonriver_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.lending_supplies". */
export type Moonriver_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "moonriver.lending_supplies" */
export enum Moonriver_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "moonriver.liquidity_changes" */
export type Moonriver_Liquidity_Changes = {
  __typename?: 'moonriver_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "moonriver.liquidity_changes" */
export type Moonriver_Liquidity_Changes_Aggregate = {
  __typename?: 'moonriver_liquidity_changes_aggregate';
  aggregate?: Maybe<Moonriver_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Moonriver_Liquidity_Changes>;
};

/** aggregate fields of "moonriver.liquidity_changes" */
export type Moonriver_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'moonriver_liquidity_changes_aggregate_fields';
  avg?: Maybe<Moonriver_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonriver_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Moonriver_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Moonriver_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Moonriver_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonriver_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Moonriver_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Moonriver_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Moonriver_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Moonriver_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "moonriver.liquidity_changes" */
export type Moonriver_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonriver_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonriver_Liquidity_Changes_Avg_Fields = {
  __typename?: 'moonriver_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonriver.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Moonriver_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Moonriver_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonriver_Liquidity_Changes_Max_Fields = {
  __typename?: 'moonriver_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Moonriver_Liquidity_Changes_Min_Fields = {
  __typename?: 'moonriver_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "moonriver.liquidity_changes". */
export type Moonriver_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonriver.liquidity_changes" */
export enum Moonriver_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Moonriver_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'moonriver_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonriver_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'moonriver_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonriver_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'moonriver_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonriver_Liquidity_Changes_Sum_Fields = {
  __typename?: 'moonriver_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonriver_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'moonriver_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonriver_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'moonriver_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonriver_Liquidity_Changes_Variance_Fields = {
  __typename?: 'moonriver_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonriver.liquidity_with_prices" */
export type Moonriver_Liquidity_With_Prices = {
  __typename?: 'moonriver_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "moonriver.liquidity_with_prices" */
export type Moonriver_Liquidity_With_Prices_Aggregate = {
  __typename?: 'moonriver_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Moonriver_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Moonriver_Liquidity_With_Prices>;
};

/** aggregate fields of "moonriver.liquidity_with_prices" */
export type Moonriver_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Moonriver_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonriver_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Moonriver_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Moonriver_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Moonriver_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonriver_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Moonriver_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Moonriver_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Moonriver_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Moonriver_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "moonriver.liquidity_with_prices" */
export type Moonriver_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonriver_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonriver_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonriver.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Moonriver_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Moonriver_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonriver_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Moonriver_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "moonriver.liquidity_with_prices". */
export type Moonriver_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "moonriver.liquidity_with_prices" */
export enum Moonriver_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Moonriver_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonriver_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonriver_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonriver_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonriver_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonriver_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonriver_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'moonriver_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonriver.loan_liquidations" */
export type Moonriver_Loan_Liquidations = {
  __typename?: 'moonriver_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonriver.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Moonriver_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Moonriver_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.loan_liquidations". */
export type Moonriver_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonriver.loan_liquidations" */
export enum Moonriver_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonriver.pair_search" */
export type Moonriver_Pair_Search = {
  __typename?: 'moonriver_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Moonriver_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonriver_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonriver.pair_search". All fields are combined with a logical 'AND'. */
export type Moonriver_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Moonriver_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.pair_search". */
export type Moonriver_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Moonriver_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Moonriver_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "moonriver.pair_search" */
export enum Moonriver_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "moonriver.pair_summary" */
export type Moonriver_Pair_Summary = {
  __typename?: 'moonriver_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Moonriver_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonriver_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonriver.pair_summary". All fields are combined with a logical 'AND'. */
export type Moonriver_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Moonriver_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.pair_summary". */
export type Moonriver_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Moonriver_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Moonriver_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "moonriver.pair_summary" */
export enum Moonriver_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** columns and relationships of "moonriver.pair_with_prices_tb" */
export type Moonriver_Pair_With_Prices_Tb = {
  __typename?: 'moonriver_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "moonriver.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Moonriver_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Moonriver_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.pair_with_prices_tb". */
export type Moonriver_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "moonriver.pair_with_prices_tb" */
export enum Moonriver_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "moonriver.pairs" */
export type Moonriver_Pairs = {
  __typename?: 'moonriver_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Moonriver_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Moonriver_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonriver.pairs". All fields are combined with a logical 'AND'. */
export type Moonriver_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Pairs_Bool_Exp>>;
  _not?: Maybe<Moonriver_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Moonriver_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.pairs". */
export type Moonriver_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Moonriver_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Moonriver_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonriver.pairs" */
export enum Moonriver_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonriver.pairs_tx_count" */
export type Moonriver_Pairs_Tx_Count = {
  __typename?: 'moonriver_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "moonriver.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Moonriver_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Moonriver_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.pairs_tx_count". */
export type Moonriver_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "moonriver.pairs_tx_count" */
export enum Moonriver_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "moonriver.protocols" */
export type Moonriver_Protocols = {
  __typename?: 'moonriver_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "moonriver.protocols". All fields are combined with a logical 'AND'. */
export type Moonriver_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Protocols_Bool_Exp>>;
  _not?: Maybe<Moonriver_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.protocols". */
export type Moonriver_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "moonriver.protocols" */
export enum Moonriver_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "moonriver.swap_candles_cached" */
export type Moonriver_Swap_Candles_Cached = {
  __typename?: 'moonriver_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "moonriver.swap_candles_cached" */
export type Moonriver_Swap_Candles_Cached_Aggregate = {
  __typename?: 'moonriver_swap_candles_cached_aggregate';
  aggregate?: Maybe<Moonriver_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Moonriver_Swap_Candles_Cached>;
};

/** aggregate fields of "moonriver.swap_candles_cached" */
export type Moonriver_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'moonriver_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Moonriver_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonriver_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Moonriver_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Moonriver_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Moonriver_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonriver_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Moonriver_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Moonriver_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Moonriver_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Moonriver_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "moonriver.swap_candles_cached" */
export type Moonriver_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonriver_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonriver_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'moonriver_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonriver.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Moonriver_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Moonriver_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonriver_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'moonriver_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Moonriver_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'moonriver_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "moonriver.swap_candles_cached". */
export type Moonriver_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "moonriver.swap_candles_cached" */
export enum Moonriver_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Moonriver_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'moonriver_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonriver_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'moonriver_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonriver_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'moonriver_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonriver_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'moonriver_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonriver_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'moonriver_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonriver_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'moonriver_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonriver_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'moonriver_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "moonriver.swap_candles_tb" */
export type Moonriver_Swap_Candles_Tb = {
  __typename?: 'moonriver_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "moonriver.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Moonriver_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Moonriver_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.swap_candles_tb". */
export type Moonriver_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "moonriver.swap_candles_tb" */
export enum Moonriver_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "moonriver.tokens" */
export type Moonriver_Tokens = {
  __typename?: 'moonriver_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "moonriver.tokens". All fields are combined with a logical 'AND'. */
export type Moonriver_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Tokens_Bool_Exp>>;
  _not?: Maybe<Moonriver_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "moonriver.tokens". */
export type Moonriver_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "moonriver.tokens" */
export enum Moonriver_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "moonriver.tokenswaps_with_prices" */
export type Moonriver_Tokenswaps_With_Prices = {
  __typename?: 'moonriver_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "moonriver.tokenswaps_with_prices" */
export type Moonriver_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'moonriver_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Moonriver_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Moonriver_Tokenswaps_With_Prices>;
};

/** aggregate fields of "moonriver.tokenswaps_with_prices" */
export type Moonriver_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Moonriver_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Moonriver_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Moonriver_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Moonriver_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Moonriver_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Moonriver_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Moonriver_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Moonriver_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Moonriver_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Moonriver_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "moonriver.tokenswaps_with_prices" */
export type Moonriver_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Moonriver_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "moonriver.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Moonriver_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Moonriver_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Moonriver_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Moonriver_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "moonriver.tokenswaps_with_prices". */
export type Moonriver_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "moonriver.tokenswaps_with_prices" */
export enum Moonriver_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Moonriver_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Moonriver_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Moonriver_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Moonriver_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Moonriver_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Moonriver_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Moonriver_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'moonriver_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: Maybe<Scalars['numeric']>;
  _gt?: Maybe<Scalars['numeric']>;
  _gte?: Maybe<Scalars['numeric']>;
  _in?: Maybe<Array<Scalars['numeric']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['numeric']>;
  _lte?: Maybe<Scalars['numeric']>;
  _neq?: Maybe<Scalars['numeric']>;
  _nin?: Maybe<Array<Scalars['numeric']>>;
};

/** columns and relationships of "optimism.borrows" */
export type Optimism_Borrows = {
  __typename?: 'optimism_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "optimism.borrows". All fields are combined with a logical 'AND'. */
export type Optimism_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Borrows_Bool_Exp>>;
  _not?: Maybe<Optimism_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.borrows". */
export type Optimism_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "optimism.borrows" */
export enum Optimism_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Optimism_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Optimism_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Optimism_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "optimism.lending_market_daily_snapshots" */
export type Optimism_Lending_Market_Daily_Snapshots = {
  __typename?: 'optimism_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "optimism.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Optimism_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Optimism_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.lending_market_daily_snapshots". */
export type Optimism_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "optimism.lending_market_daily_snapshots" */
export enum Optimism_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "optimism.lending_market_user_count_tb" */
export type Optimism_Lending_Market_User_Count_Tb = {
  __typename?: 'optimism_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "optimism.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Optimism_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.lending_market_user_count_tb". */
export type Optimism_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "optimism.lending_market_user_count_tb" */
export enum Optimism_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "optimism.lending_supplies" */
export type Optimism_Lending_Supplies = {
  __typename?: 'optimism_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "optimism.lending_supplies". All fields are combined with a logical 'AND'. */
export type Optimism_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Optimism_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.lending_supplies". */
export type Optimism_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "optimism.lending_supplies" */
export enum Optimism_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "optimism.liquidity_changes" */
export type Optimism_Liquidity_Changes = {
  __typename?: 'optimism_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "optimism.liquidity_changes" */
export type Optimism_Liquidity_Changes_Aggregate = {
  __typename?: 'optimism_liquidity_changes_aggregate';
  aggregate?: Maybe<Optimism_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Optimism_Liquidity_Changes>;
};

/** aggregate fields of "optimism.liquidity_changes" */
export type Optimism_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'optimism_liquidity_changes_aggregate_fields';
  avg?: Maybe<Optimism_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Optimism_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Optimism_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Optimism_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "optimism.liquidity_changes" */
export type Optimism_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Liquidity_Changes_Avg_Fields = {
  __typename?: 'optimism_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Optimism_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Optimism_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Liquidity_Changes_Max_Fields = {
  __typename?: 'optimism_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Optimism_Liquidity_Changes_Min_Fields = {
  __typename?: 'optimism_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "optimism.liquidity_changes". */
export type Optimism_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "optimism.liquidity_changes" */
export enum Optimism_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Optimism_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'optimism_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'optimism_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'optimism_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Liquidity_Changes_Sum_Fields = {
  __typename?: 'optimism_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'optimism_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'optimism_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Liquidity_Changes_Variance_Fields = {
  __typename?: 'optimism_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.liquidity_with_prices" */
export type Optimism_Liquidity_With_Prices = {
  __typename?: 'optimism_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "optimism.liquidity_with_prices" */
export type Optimism_Liquidity_With_Prices_Aggregate = {
  __typename?: 'optimism_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Optimism_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Optimism_Liquidity_With_Prices>;
};

/** aggregate fields of "optimism.liquidity_with_prices" */
export type Optimism_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'optimism_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Optimism_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Optimism_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Optimism_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Optimism_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "optimism.liquidity_with_prices" */
export type Optimism_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'optimism_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Optimism_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Optimism_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'optimism_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Optimism_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'optimism_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "optimism.liquidity_with_prices". */
export type Optimism_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "optimism.liquidity_with_prices" */
export enum Optimism_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Optimism_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'optimism_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'optimism_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'optimism_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'optimism_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'optimism_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'optimism_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'optimism_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.loan_liquidations" */
export type Optimism_Loan_Liquidations = {
  __typename?: 'optimism_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "optimism.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Optimism_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Optimism_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.loan_liquidations". */
export type Optimism_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "optimism.loan_liquidations" */
export enum Optimism_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "optimism.pair_search" */
export type Optimism_Pair_Search = {
  __typename?: 'optimism_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Optimism_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Optimism_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "optimism.pair_search" */
export type Optimism_Pair_Search_Aggregate = {
  __typename?: 'optimism_pair_search_aggregate';
  aggregate?: Maybe<Optimism_Pair_Search_Aggregate_Fields>;
  nodes: Array<Optimism_Pair_Search>;
};

/** aggregate fields of "optimism.pair_search" */
export type Optimism_Pair_Search_Aggregate_Fields = {
  __typename?: 'optimism_pair_search_aggregate_fields';
  avg?: Maybe<Optimism_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Pair_Search_Max_Fields>;
  min?: Maybe<Optimism_Pair_Search_Min_Fields>;
  stddev?: Maybe<Optimism_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Optimism_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "optimism.pair_search" */
export type Optimism_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Pair_Search_Avg_Fields = {
  __typename?: 'optimism_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.pair_search". All fields are combined with a logical 'AND'. */
export type Optimism_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Optimism_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Optimism_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Optimism_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Pair_Search_Max_Fields = {
  __typename?: 'optimism_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Optimism_Pair_Search_Min_Fields = {
  __typename?: 'optimism_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "optimism.pair_search". */
export type Optimism_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Optimism_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Optimism_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "optimism.pair_search" */
export enum Optimism_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Optimism_Pair_Search_Stddev_Fields = {
  __typename?: 'optimism_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'optimism_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'optimism_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Pair_Search_Sum_Fields = {
  __typename?: 'optimism_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Pair_Search_Var_Pop_Fields = {
  __typename?: 'optimism_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Pair_Search_Var_Samp_Fields = {
  __typename?: 'optimism_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Pair_Search_Variance_Fields = {
  __typename?: 'optimism_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.pair_summary" */
export type Optimism_Pair_Summary = {
  __typename?: 'optimism_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Optimism_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Optimism_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "optimism.pair_summary" */
export type Optimism_Pair_Summary_Aggregate = {
  __typename?: 'optimism_pair_summary_aggregate';
  aggregate?: Maybe<Optimism_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Optimism_Pair_Summary>;
};

/** aggregate fields of "optimism.pair_summary" */
export type Optimism_Pair_Summary_Aggregate_Fields = {
  __typename?: 'optimism_pair_summary_aggregate_fields';
  avg?: Maybe<Optimism_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Pair_Summary_Max_Fields>;
  min?: Maybe<Optimism_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Optimism_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Optimism_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "optimism.pair_summary" */
export type Optimism_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Pair_Summary_Avg_Fields = {
  __typename?: 'optimism_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.pair_summary". All fields are combined with a logical 'AND'. */
export type Optimism_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Optimism_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Optimism_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Optimism_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Pair_Summary_Max_Fields = {
  __typename?: 'optimism_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Optimism_Pair_Summary_Min_Fields = {
  __typename?: 'optimism_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "optimism.pair_summary". */
export type Optimism_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Optimism_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Optimism_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "optimism.pair_summary" */
export enum Optimism_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Optimism_Pair_Summary_Stddev_Fields = {
  __typename?: 'optimism_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'optimism_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'optimism_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Pair_Summary_Sum_Fields = {
  __typename?: 'optimism_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'optimism_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'optimism_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Pair_Summary_Variance_Fields = {
  __typename?: 'optimism_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.pair_with_prices_tb" */
export type Optimism_Pair_With_Prices_Tb = {
  __typename?: 'optimism_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "optimism.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Optimism_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Optimism_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.pair_with_prices_tb". */
export type Optimism_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "optimism.pair_with_prices_tb" */
export enum Optimism_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "optimism.pairs" */
export type Optimism_Pairs = {
  __typename?: 'optimism_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Optimism_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Optimism_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "optimism.pairs". All fields are combined with a logical 'AND'. */
export type Optimism_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Pairs_Bool_Exp>>;
  _not?: Maybe<Optimism_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Optimism_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Optimism_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.pairs". */
export type Optimism_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Optimism_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Optimism_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "optimism.pairs" */
export enum Optimism_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "optimism.pairs_tx_count" */
export type Optimism_Pairs_Tx_Count = {
  __typename?: 'optimism_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "optimism.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Optimism_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Optimism_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.pairs_tx_count". */
export type Optimism_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "optimism.pairs_tx_count" */
export enum Optimism_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "optimism.protocols" */
export type Optimism_Protocols = {
  __typename?: 'optimism_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "optimism.protocols". All fields are combined with a logical 'AND'. */
export type Optimism_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Protocols_Bool_Exp>>;
  _not?: Maybe<Optimism_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.protocols". */
export type Optimism_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "optimism.protocols" */
export enum Optimism_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "optimism.swap_candles_cached" */
export type Optimism_Swap_Candles_Cached = {
  __typename?: 'optimism_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "optimism.swap_candles_cached" */
export type Optimism_Swap_Candles_Cached_Aggregate = {
  __typename?: 'optimism_swap_candles_cached_aggregate';
  aggregate?: Maybe<Optimism_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Optimism_Swap_Candles_Cached>;
};

/** aggregate fields of "optimism.swap_candles_cached" */
export type Optimism_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'optimism_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Optimism_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Optimism_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Optimism_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Optimism_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "optimism.swap_candles_cached" */
export type Optimism_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'optimism_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Optimism_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Optimism_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'optimism_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Optimism_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'optimism_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "optimism.swap_candles_cached". */
export type Optimism_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "optimism.swap_candles_cached" */
export enum Optimism_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Optimism_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'optimism_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'optimism_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'optimism_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'optimism_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'optimism_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'optimism_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'optimism_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.swap_candles_tb" */
export type Optimism_Swap_Candles_Tb = {
  __typename?: 'optimism_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "optimism.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Optimism_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Optimism_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.swap_candles_tb". */
export type Optimism_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "optimism.swap_candles_tb" */
export enum Optimism_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "optimism.tokens" */
export type Optimism_Tokens = {
  __typename?: 'optimism_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "optimism.tokens". All fields are combined with a logical 'AND'. */
export type Optimism_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Tokens_Bool_Exp>>;
  _not?: Maybe<Optimism_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.tokens". */
export type Optimism_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "optimism.tokens" */
export enum Optimism_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "optimism.tokenswaps_with_prices" */
export type Optimism_Tokenswaps_With_Prices = {
  __typename?: 'optimism_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "optimism.tokenswaps_with_prices" */
export type Optimism_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'optimism_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Optimism_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Optimism_Tokenswaps_With_Prices>;
};

/** aggregate fields of "optimism.tokenswaps_with_prices" */
export type Optimism_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Optimism_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Optimism_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Optimism_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Optimism_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Optimism_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Optimism_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Optimism_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Optimism_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Optimism_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Optimism_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "optimism.tokenswaps_with_prices" */
export type Optimism_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Optimism_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "optimism.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Optimism_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Optimism_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Optimism_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Optimism_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "optimism.tokenswaps_with_prices". */
export type Optimism_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "optimism.tokenswaps_with_prices" */
export enum Optimism_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Optimism_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Optimism_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Optimism_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Optimism_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Optimism_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Optimism_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Optimism_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'optimism_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "optimism.usd_tokens" */
export type Optimism_Usd_Tokens = {
  __typename?: 'optimism_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "optimism.usd_tokens". All fields are combined with a logical 'AND'. */
export type Optimism_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Optimism_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Optimism_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Optimism_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "optimism.usd_tokens". */
export type Optimism_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "optimism.usd_tokens" */
export enum Optimism_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "polygon.borrows" */
export type Polygon_Borrows = {
  __typename?: 'polygon_borrows';
  account_borrows: Scalars['numeric'];
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  payer?: Maybe<Scalars['String']>;
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  total_borrows: Scalars['numeric'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "polygon.borrows". All fields are combined with a logical 'AND'. */
export type Polygon_Borrows_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Borrows_Bool_Exp>>;
  _not?: Maybe<Polygon_Borrows_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Borrows_Bool_Exp>>;
  account_borrows?: Maybe<Numeric_Comparison_Exp>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  payer?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  total_borrows?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.borrows". */
export type Polygon_Borrows_Order_By = {
  account_borrows?: Maybe<Order_By>;
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  payer?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  total_borrows?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "polygon.borrows" */
export enum Polygon_Borrows_Select_Column {
  /** column name */
  AccountBorrows = 'account_borrows',
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Payer = 'payer',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TotalBorrows = 'total_borrows',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Polygon_Get_Lending_Market_User_Count_Args = {
  _market_address?: Maybe<Scalars['String']>;
  _protocol?: Maybe<Scalars['String']>;
};

export type Polygon_Get_Pair_Tx_Count_Args = {
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
};

export type Polygon_Get_Swap_Candles_Args = {
  _base_token?: Maybe<Scalars['String']>;
  _exchange?: Maybe<Scalars['String']>;
  _pair_address?: Maybe<Scalars['String']>;
  _quote_token?: Maybe<Scalars['String']>;
  _resolution?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "polygon.lending_market_daily_snapshots" */
export type Polygon_Lending_Market_Daily_Snapshots = {
  __typename?: 'polygon_lending_market_daily_snapshots';
  borrows?: Maybe<Scalars['numeric']>;
  date?: Maybe<Scalars['timestamptz']>;
  market_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  protocol?: Maybe<Scalars['String']>;
  supply?: Maybe<Scalars['numeric']>;
  underlying_token?: Maybe<Scalars['String']>;
};

/** Boolean expression to filter rows from the table "polygon.lending_market_daily_snapshots". All fields are combined with a logical 'AND'. */
export type Polygon_Lending_Market_Daily_Snapshots_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  _not?: Maybe<Polygon_Lending_Market_Daily_Snapshots_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Bool_Exp>>;
  borrows?: Maybe<Numeric_Comparison_Exp>;
  date?: Maybe<Timestamptz_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  supply?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.lending_market_daily_snapshots". */
export type Polygon_Lending_Market_Daily_Snapshots_Order_By = {
  borrows?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  supply?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
};

/** select columns of table "polygon.lending_market_daily_snapshots" */
export enum Polygon_Lending_Market_Daily_Snapshots_Select_Column {
  /** column name */
  Borrows = 'borrows',
  /** column name */
  Date = 'date',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Price = 'price',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Supply = 'supply',
  /** column name */
  UnderlyingToken = 'underlying_token'
}

/** columns and relationships of "polygon.lending_market_user_count_tb" */
export type Polygon_Lending_Market_User_Count_Tb = {
  __typename?: 'polygon_lending_market_user_count_tb';
  blocknumber?: Maybe<Scalars['String']>;
  borrowers?: Maybe<Scalars['numeric']>;
  market_address?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  suppliers?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
};

/** Boolean expression to filter rows from the table "polygon.lending_market_user_count_tb". All fields are combined with a logical 'AND'. */
export type Polygon_Lending_Market_User_Count_Tb_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>>;
  _not?: Maybe<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>>;
  blocknumber?: Maybe<String_Comparison_Exp>;
  borrowers?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  suppliers?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.lending_market_user_count_tb". */
export type Polygon_Lending_Market_User_Count_Tb_Order_By = {
  blocknumber?: Maybe<Order_By>;
  borrowers?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  suppliers?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
};

/** select columns of table "polygon.lending_market_user_count_tb" */
export enum Polygon_Lending_Market_User_Count_Tb_Select_Column {
  /** column name */
  Blocknumber = 'blocknumber',
  /** column name */
  Borrowers = 'borrowers',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Suppliers = 'suppliers',
  /** column name */
  Timestamp = 'timestamp'
}

/** columns and relationships of "polygon.lending_supplies" */
export type Polygon_Lending_Supplies = {
  __typename?: 'polygon_lending_supplies';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  market_token_amount: Scalars['numeric'];
  protocol: Scalars['String'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_amount: Scalars['numeric'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  user_address: Scalars['String'];
};

/** Boolean expression to filter rows from the table "polygon.lending_supplies". All fields are combined with a logical 'AND'. */
export type Polygon_Lending_Supplies_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Lending_Supplies_Bool_Exp>>;
  _not?: Maybe<Polygon_Lending_Supplies_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Lending_Supplies_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  market_token_amount?: Maybe<Numeric_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_amount?: Maybe<Numeric_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.lending_supplies". */
export type Polygon_Lending_Supplies_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  market_token_amount?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_amount?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "polygon.lending_supplies" */
export enum Polygon_Lending_Supplies_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  MarketTokenAmount = 'market_token_amount',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingAmount = 'underlying_amount',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserAddress = 'user_address'
}

/** columns and relationships of "polygon.liquidity_changes" */
export type Polygon_Liquidity_Changes = {
  __typename?: 'polygon_liquidity_changes';
  blockhash?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  direction?: Maybe<Scalars['String']>;
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "polygon.liquidity_changes" */
export type Polygon_Liquidity_Changes_Aggregate = {
  __typename?: 'polygon_liquidity_changes_aggregate';
  aggregate?: Maybe<Polygon_Liquidity_Changes_Aggregate_Fields>;
  nodes: Array<Polygon_Liquidity_Changes>;
};

/** aggregate fields of "polygon.liquidity_changes" */
export type Polygon_Liquidity_Changes_Aggregate_Fields = {
  __typename?: 'polygon_liquidity_changes_aggregate_fields';
  avg?: Maybe<Polygon_Liquidity_Changes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Liquidity_Changes_Max_Fields>;
  min?: Maybe<Polygon_Liquidity_Changes_Min_Fields>;
  stddev?: Maybe<Polygon_Liquidity_Changes_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Liquidity_Changes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Liquidity_Changes_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Liquidity_Changes_Sum_Fields>;
  var_pop?: Maybe<Polygon_Liquidity_Changes_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Liquidity_Changes_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Liquidity_Changes_Variance_Fields>;
};


/** aggregate fields of "polygon.liquidity_changes" */
export type Polygon_Liquidity_Changes_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Liquidity_Changes_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Liquidity_Changes_Avg_Fields = {
  __typename?: 'polygon_liquidity_changes_avg_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.liquidity_changes". All fields are combined with a logical 'AND'. */
export type Polygon_Liquidity_Changes_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Liquidity_Changes_Bool_Exp>>;
  _not?: Maybe<Polygon_Liquidity_Changes_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Liquidity_Changes_Bool_Exp>>;
  blockhash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Liquidity_Changes_Max_Fields = {
  __typename?: 'polygon_liquidity_changes_max_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Polygon_Liquidity_Changes_Min_Fields = {
  __typename?: 'polygon_liquidity_changes_min_fields';
  blockhash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Ordering options when selecting data from "polygon.liquidity_changes". */
export type Polygon_Liquidity_Changes_Order_By = {
  blockhash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "polygon.liquidity_changes" */
export enum Polygon_Liquidity_Changes_Select_Column {
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Polygon_Liquidity_Changes_Stddev_Fields = {
  __typename?: 'polygon_liquidity_changes_stddev_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Liquidity_Changes_Stddev_Pop_Fields = {
  __typename?: 'polygon_liquidity_changes_stddev_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Liquidity_Changes_Stddev_Samp_Fields = {
  __typename?: 'polygon_liquidity_changes_stddev_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Liquidity_Changes_Sum_Fields = {
  __typename?: 'polygon_liquidity_changes_sum_fields';
  eventindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Liquidity_Changes_Var_Pop_Fields = {
  __typename?: 'polygon_liquidity_changes_var_pop_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Liquidity_Changes_Var_Samp_Fields = {
  __typename?: 'polygon_liquidity_changes_var_samp_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Liquidity_Changes_Variance_Fields = {
  __typename?: 'polygon_liquidity_changes_variance_fields';
  eventindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.liquidity_with_prices" */
export type Polygon_Liquidity_With_Prices = {
  __typename?: 'polygon_liquidity_with_prices';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d: Scalars['numeric'];
  candle_1min: Scalars['numeric'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  timestamp: Scalars['Int'];
  token0_address: Scalars['String'];
  token0_amount: Scalars['numeric'];
  token0_decimals: Scalars['numeric'];
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  updated_at: Scalars['timestamptz'];
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregated selection of "polygon.liquidity_with_prices" */
export type Polygon_Liquidity_With_Prices_Aggregate = {
  __typename?: 'polygon_liquidity_with_prices_aggregate';
  aggregate?: Maybe<Polygon_Liquidity_With_Prices_Aggregate_Fields>;
  nodes: Array<Polygon_Liquidity_With_Prices>;
};

/** aggregate fields of "polygon.liquidity_with_prices" */
export type Polygon_Liquidity_With_Prices_Aggregate_Fields = {
  __typename?: 'polygon_liquidity_with_prices_aggregate_fields';
  avg?: Maybe<Polygon_Liquidity_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Liquidity_With_Prices_Max_Fields>;
  min?: Maybe<Polygon_Liquidity_With_Prices_Min_Fields>;
  stddev?: Maybe<Polygon_Liquidity_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Liquidity_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Liquidity_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Liquidity_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Polygon_Liquidity_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Liquidity_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Liquidity_With_Prices_Variance_Fields>;
};


/** aggregate fields of "polygon.liquidity_with_prices" */
export type Polygon_Liquidity_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Liquidity_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Liquidity_With_Prices_Avg_Fields = {
  __typename?: 'polygon_liquidity_with_prices_avg_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.liquidity_with_prices". All fields are combined with a logical 'AND'. */
export type Polygon_Liquidity_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Liquidity_With_Prices_Bool_Exp>>;
  _not?: Maybe<Polygon_Liquidity_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Liquidity_With_Prices_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  candle_1d?: Maybe<Numeric_Comparison_Exp>;
  candle_1min?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_amount?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Numeric_Comparison_Exp>;
  token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0totoken1ratio?: Maybe<Numeric_Comparison_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_amount?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Numeric_Comparison_Exp>;
  token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
  user_address?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Liquidity_With_Prices_Max_Fields = {
  __typename?: 'polygon_liquidity_with_prices_max_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Polygon_Liquidity_With_Prices_Min_Fields = {
  __typename?: 'polygon_liquidity_with_prices_min_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  native_volume?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  tx_sender?: Maybe<Scalars['String']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_volume?: Maybe<Scalars['numeric']>;
  user_address?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "polygon.liquidity_with_prices". */
export type Polygon_Liquidity_With_Prices_Order_By = {
  block_number?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_amount?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_native_price?: Maybe<Order_By>;
  token0_usd_price?: Maybe<Order_By>;
  token0totoken1ratio?: Maybe<Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_amount?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_native_price?: Maybe<Order_By>;
  token1_usd_price?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
  user_address?: Maybe<Order_By>;
};

/** select columns of table "polygon.liquidity_with_prices" */
export enum Polygon_Liquidity_With_Prices_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0Amount = 'token0_amount',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0NativePrice = 'token0_native_price',
  /** column name */
  Token0UsdPrice = 'token0_usd_price',
  /** column name */
  Token0totoken1ratio = 'token0totoken1ratio',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1Amount = 'token1_amount',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1NativePrice = 'token1_native_price',
  /** column name */
  Token1UsdPrice = 'token1_usd_price',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdVolume = 'usd_volume',
  /** column name */
  UserAddress = 'user_address'
}

/** aggregate stddev on columns */
export type Polygon_Liquidity_With_Prices_Stddev_Fields = {
  __typename?: 'polygon_liquidity_with_prices_stddev_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Liquidity_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'polygon_liquidity_with_prices_stddev_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Liquidity_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'polygon_liquidity_with_prices_stddev_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Liquidity_With_Prices_Sum_Fields = {
  __typename?: 'polygon_liquidity_with_prices_sum_fields';
  block_number?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['numeric']>;
  candle_1min?: Maybe<Scalars['numeric']>;
  eventindex?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  timestamp?: Maybe<Scalars['Int']>;
  token0_amount?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['numeric']>;
  token0_native_price?: Maybe<Scalars['numeric']>;
  token0_usd_price?: Maybe<Scalars['numeric']>;
  token0totoken1ratio?: Maybe<Scalars['numeric']>;
  token1_amount?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['numeric']>;
  token1_native_price?: Maybe<Scalars['numeric']>;
  token1_usd_price?: Maybe<Scalars['numeric']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Liquidity_With_Prices_Var_Pop_Fields = {
  __typename?: 'polygon_liquidity_with_prices_var_pop_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Liquidity_With_Prices_Var_Samp_Fields = {
  __typename?: 'polygon_liquidity_with_prices_var_samp_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Liquidity_With_Prices_Variance_Fields = {
  __typename?: 'polygon_liquidity_with_prices_variance_fields';
  block_number?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  token0_amount?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_native_price?: Maybe<Scalars['Float']>;
  token0_usd_price?: Maybe<Scalars['Float']>;
  token0totoken1ratio?: Maybe<Scalars['Float']>;
  token1_amount?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_native_price?: Maybe<Scalars['Float']>;
  token1_usd_price?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.loan_liquidations" */
export type Polygon_Loan_Liquidations = {
  __typename?: 'polygon_loan_liquidations';
  block_number?: Maybe<Scalars['Int']>;
  blockhash?: Maybe<Scalars['String']>;
  borrower: Scalars['String'];
  created_at: Scalars['timestamptz'];
  event_index: Scalars['numeric'];
  liquidator: Scalars['String'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  repay_amount: Scalars['numeric'];
  seized_collateral_address: Scalars['String'];
  seized_collateral_amount: Scalars['numeric'];
  timestamp: Scalars['Int'];
  tx_sender?: Maybe<Scalars['String']>;
  txhash: Scalars['String'];
  underlying_token: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "polygon.loan_liquidations". All fields are combined with a logical 'AND'. */
export type Polygon_Loan_Liquidations_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Loan_Liquidations_Bool_Exp>>;
  _not?: Maybe<Polygon_Loan_Liquidations_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Loan_Liquidations_Bool_Exp>>;
  block_number?: Maybe<Int_Comparison_Exp>;
  blockhash?: Maybe<String_Comparison_Exp>;
  borrower?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_index?: Maybe<Numeric_Comparison_Exp>;
  liquidator?: Maybe<String_Comparison_Exp>;
  market_address?: Maybe<String_Comparison_Exp>;
  protocol?: Maybe<String_Comparison_Exp>;
  repay_amount?: Maybe<Numeric_Comparison_Exp>;
  seized_collateral_address?: Maybe<String_Comparison_Exp>;
  seized_collateral_amount?: Maybe<Numeric_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  tx_sender?: Maybe<String_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  underlying_token?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.loan_liquidations". */
export type Polygon_Loan_Liquidations_Order_By = {
  block_number?: Maybe<Order_By>;
  blockhash?: Maybe<Order_By>;
  borrower?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_index?: Maybe<Order_By>;
  liquidator?: Maybe<Order_By>;
  market_address?: Maybe<Order_By>;
  protocol?: Maybe<Order_By>;
  repay_amount?: Maybe<Order_By>;
  seized_collateral_address?: Maybe<Order_By>;
  seized_collateral_amount?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  tx_sender?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  underlying_token?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "polygon.loan_liquidations" */
export enum Polygon_Loan_Liquidations_Select_Column {
  /** column name */
  BlockNumber = 'block_number',
  /** column name */
  Blockhash = 'blockhash',
  /** column name */
  Borrower = 'borrower',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventIndex = 'event_index',
  /** column name */
  Liquidator = 'liquidator',
  /** column name */
  MarketAddress = 'market_address',
  /** column name */
  Protocol = 'protocol',
  /** column name */
  RepayAmount = 'repay_amount',
  /** column name */
  SeizedCollateralAddress = 'seized_collateral_address',
  /** column name */
  SeizedCollateralAmount = 'seized_collateral_amount',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  TxSender = 'tx_sender',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UnderlyingToken = 'underlying_token',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "polygon.pair_search" */
export type Polygon_Pair_Search = {
  __typename?: 'polygon_pair_search';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Polygon_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Polygon_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "polygon.pair_search" */
export type Polygon_Pair_Search_Aggregate = {
  __typename?: 'polygon_pair_search_aggregate';
  aggregate?: Maybe<Polygon_Pair_Search_Aggregate_Fields>;
  nodes: Array<Polygon_Pair_Search>;
};

/** aggregate fields of "polygon.pair_search" */
export type Polygon_Pair_Search_Aggregate_Fields = {
  __typename?: 'polygon_pair_search_aggregate_fields';
  avg?: Maybe<Polygon_Pair_Search_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Pair_Search_Max_Fields>;
  min?: Maybe<Polygon_Pair_Search_Min_Fields>;
  stddev?: Maybe<Polygon_Pair_Search_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Pair_Search_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Pair_Search_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Pair_Search_Sum_Fields>;
  var_pop?: Maybe<Polygon_Pair_Search_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Pair_Search_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Pair_Search_Variance_Fields>;
};


/** aggregate fields of "polygon.pair_search" */
export type Polygon_Pair_Search_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Pair_Search_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Pair_Search_Avg_Fields = {
  __typename?: 'polygon_pair_search_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.pair_search". All fields are combined with a logical 'AND'. */
export type Polygon_Pair_Search_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Pair_Search_Bool_Exp>>;
  _not?: Maybe<Polygon_Pair_Search_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Pair_Search_Bool_Exp>>;
  concat_ws?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Polygon_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Polygon_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Pair_Search_Max_Fields = {
  __typename?: 'polygon_pair_search_max_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Polygon_Pair_Search_Min_Fields = {
  __typename?: 'polygon_pair_search_min_fields';
  concat_ws?: Maybe<Scalars['String']>;
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "polygon.pair_search". */
export type Polygon_Pair_Search_Order_By = {
  concat_ws?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Polygon_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Polygon_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "polygon.pair_search" */
export enum Polygon_Pair_Search_Select_Column {
  /** column name */
  ConcatWs = 'concat_ws',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Polygon_Pair_Search_Stddev_Fields = {
  __typename?: 'polygon_pair_search_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Pair_Search_Stddev_Pop_Fields = {
  __typename?: 'polygon_pair_search_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Pair_Search_Stddev_Samp_Fields = {
  __typename?: 'polygon_pair_search_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Pair_Search_Sum_Fields = {
  __typename?: 'polygon_pair_search_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Pair_Search_Var_Pop_Fields = {
  __typename?: 'polygon_pair_search_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Pair_Search_Var_Samp_Fields = {
  __typename?: 'polygon_pair_search_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Pair_Search_Variance_Fields = {
  __typename?: 'polygon_pair_search_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.pair_summary" */
export type Polygon_Pair_Summary = {
  __typename?: 'polygon_pair_summary';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token0?: Maybe<Polygon_Tokens>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Polygon_Tokens>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "polygon.pair_summary" */
export type Polygon_Pair_Summary_Aggregate = {
  __typename?: 'polygon_pair_summary_aggregate';
  aggregate?: Maybe<Polygon_Pair_Summary_Aggregate_Fields>;
  nodes: Array<Polygon_Pair_Summary>;
};

/** aggregate fields of "polygon.pair_summary" */
export type Polygon_Pair_Summary_Aggregate_Fields = {
  __typename?: 'polygon_pair_summary_aggregate_fields';
  avg?: Maybe<Polygon_Pair_Summary_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Pair_Summary_Max_Fields>;
  min?: Maybe<Polygon_Pair_Summary_Min_Fields>;
  stddev?: Maybe<Polygon_Pair_Summary_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Pair_Summary_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Pair_Summary_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Pair_Summary_Sum_Fields>;
  var_pop?: Maybe<Polygon_Pair_Summary_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Pair_Summary_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Pair_Summary_Variance_Fields>;
};


/** aggregate fields of "polygon.pair_summary" */
export type Polygon_Pair_Summary_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Pair_Summary_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Pair_Summary_Avg_Fields = {
  __typename?: 'polygon_pair_summary_avg_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.pair_summary". All fields are combined with a logical 'AND'. */
export type Polygon_Pair_Summary_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Pair_Summary_Bool_Exp>>;
  _not?: Maybe<Polygon_Pair_Summary_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Pair_Summary_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  last_24hour_native_volume?: Maybe<Numeric_Comparison_Exp>;
  last_24hour_usd_volume?: Maybe<Numeric_Comparison_Exp>;
  latest_pair_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  latest_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  start_pair_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token0_usd_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_native_price?: Maybe<Numeric_Comparison_Exp>;
  start_token1_usd_price?: Maybe<Numeric_Comparison_Exp>;
  token0?: Maybe<Polygon_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token0_decimals?: Maybe<Int_Comparison_Exp>;
  token0_name?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token0_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token0_symbol?: Maybe<String_Comparison_Exp>;
  token0_total_supply?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Polygon_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_circ_supply?: Maybe<Numeric_Comparison_Exp>;
  token1_decimals?: Maybe<Int_Comparison_Exp>;
  token1_name?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1_primary_img_uri?: Maybe<String_Comparison_Exp>;
  token1_symbol?: Maybe<String_Comparison_Exp>;
  token1_total_supply?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Pair_Summary_Max_Fields = {
  __typename?: 'polygon_pair_summary_max_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Polygon_Pair_Summary_Min_Fields = {
  __typename?: 'polygon_pair_summary_min_fields';
  exchange?: Maybe<Scalars['String']>;
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_address?: Maybe<Scalars['String']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_name?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_primary_img_uri?: Maybe<Scalars['String']>;
  token0_symbol?: Maybe<Scalars['String']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_address?: Maybe<Scalars['String']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_name?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_primary_img_uri?: Maybe<Scalars['String']>;
  token1_symbol?: Maybe<Scalars['String']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "polygon.pair_summary". */
export type Polygon_Pair_Summary_Order_By = {
  exchange?: Maybe<Order_By>;
  last_24hour_native_volume?: Maybe<Order_By>;
  last_24hour_usd_volume?: Maybe<Order_By>;
  latest_pair_price?: Maybe<Order_By>;
  latest_token0_native_price?: Maybe<Order_By>;
  latest_token0_usd_price?: Maybe<Order_By>;
  latest_token1_native_price?: Maybe<Order_By>;
  latest_token1_usd_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  start_pair_price?: Maybe<Order_By>;
  start_token0_native_price?: Maybe<Order_By>;
  start_token0_usd_price?: Maybe<Order_By>;
  start_token1_native_price?: Maybe<Order_By>;
  start_token1_usd_price?: Maybe<Order_By>;
  token0?: Maybe<Polygon_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_circ_supply?: Maybe<Order_By>;
  token0_decimals?: Maybe<Order_By>;
  token0_name?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token0_primary_img_uri?: Maybe<Order_By>;
  token0_symbol?: Maybe<Order_By>;
  token0_total_supply?: Maybe<Order_By>;
  token1?: Maybe<Polygon_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_circ_supply?: Maybe<Order_By>;
  token1_decimals?: Maybe<Order_By>;
  token1_name?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  token1_primary_img_uri?: Maybe<Order_By>;
  token1_symbol?: Maybe<Order_By>;
  token1_total_supply?: Maybe<Order_By>;
};

/** select columns of table "polygon.pair_summary" */
export enum Polygon_Pair_Summary_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Last_24hourNativeVolume = 'last_24hour_native_volume',
  /** column name */
  Last_24hourUsdVolume = 'last_24hour_usd_volume',
  /** column name */
  LatestPairPrice = 'latest_pair_price',
  /** column name */
  LatestToken0NativePrice = 'latest_token0_native_price',
  /** column name */
  LatestToken0UsdPrice = 'latest_token0_usd_price',
  /** column name */
  LatestToken1NativePrice = 'latest_token1_native_price',
  /** column name */
  LatestToken1UsdPrice = 'latest_token1_usd_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  StartPairPrice = 'start_pair_price',
  /** column name */
  StartToken0NativePrice = 'start_token0_native_price',
  /** column name */
  StartToken0UsdPrice = 'start_token0_usd_price',
  /** column name */
  StartToken1NativePrice = 'start_token1_native_price',
  /** column name */
  StartToken1UsdPrice = 'start_token1_usd_price',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0CircSupply = 'token0_circ_supply',
  /** column name */
  Token0Decimals = 'token0_decimals',
  /** column name */
  Token0Name = 'token0_name',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token0PrimaryImgUri = 'token0_primary_img_uri',
  /** column name */
  Token0Symbol = 'token0_symbol',
  /** column name */
  Token0TotalSupply = 'token0_total_supply',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1CircSupply = 'token1_circ_supply',
  /** column name */
  Token1Decimals = 'token1_decimals',
  /** column name */
  Token1Name = 'token1_name',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  Token1PrimaryImgUri = 'token1_primary_img_uri',
  /** column name */
  Token1Symbol = 'token1_symbol',
  /** column name */
  Token1TotalSupply = 'token1_total_supply'
}

/** aggregate stddev on columns */
export type Polygon_Pair_Summary_Stddev_Fields = {
  __typename?: 'polygon_pair_summary_stddev_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Pair_Summary_Stddev_Pop_Fields = {
  __typename?: 'polygon_pair_summary_stddev_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Pair_Summary_Stddev_Samp_Fields = {
  __typename?: 'polygon_pair_summary_stddev_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Pair_Summary_Sum_Fields = {
  __typename?: 'polygon_pair_summary_sum_fields';
  last_24hour_native_volume?: Maybe<Scalars['numeric']>;
  last_24hour_usd_volume?: Maybe<Scalars['numeric']>;
  latest_pair_price?: Maybe<Scalars['numeric']>;
  latest_token0_native_price?: Maybe<Scalars['numeric']>;
  latest_token0_usd_price?: Maybe<Scalars['numeric']>;
  latest_token1_native_price?: Maybe<Scalars['numeric']>;
  latest_token1_usd_price?: Maybe<Scalars['numeric']>;
  start_pair_price?: Maybe<Scalars['numeric']>;
  start_token0_native_price?: Maybe<Scalars['numeric']>;
  start_token0_usd_price?: Maybe<Scalars['numeric']>;
  start_token1_native_price?: Maybe<Scalars['numeric']>;
  start_token1_usd_price?: Maybe<Scalars['numeric']>;
  token0_circ_supply?: Maybe<Scalars['numeric']>;
  token0_decimals?: Maybe<Scalars['Int']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  token0_total_supply?: Maybe<Scalars['numeric']>;
  token1_circ_supply?: Maybe<Scalars['numeric']>;
  token1_decimals?: Maybe<Scalars['Int']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  token1_total_supply?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Pair_Summary_Var_Pop_Fields = {
  __typename?: 'polygon_pair_summary_var_pop_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Pair_Summary_Var_Samp_Fields = {
  __typename?: 'polygon_pair_summary_var_samp_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Pair_Summary_Variance_Fields = {
  __typename?: 'polygon_pair_summary_variance_fields';
  last_24hour_native_volume?: Maybe<Scalars['Float']>;
  last_24hour_usd_volume?: Maybe<Scalars['Float']>;
  latest_pair_price?: Maybe<Scalars['Float']>;
  latest_token0_native_price?: Maybe<Scalars['Float']>;
  latest_token0_usd_price?: Maybe<Scalars['Float']>;
  latest_token1_native_price?: Maybe<Scalars['Float']>;
  latest_token1_usd_price?: Maybe<Scalars['Float']>;
  start_pair_price?: Maybe<Scalars['Float']>;
  start_token0_native_price?: Maybe<Scalars['Float']>;
  start_token0_usd_price?: Maybe<Scalars['Float']>;
  start_token1_native_price?: Maybe<Scalars['Float']>;
  start_token1_usd_price?: Maybe<Scalars['Float']>;
  token0_circ_supply?: Maybe<Scalars['Float']>;
  token0_decimals?: Maybe<Scalars['Float']>;
  token0_pooled?: Maybe<Scalars['Float']>;
  token0_total_supply?: Maybe<Scalars['Float']>;
  token1_circ_supply?: Maybe<Scalars['Float']>;
  token1_decimals?: Maybe<Scalars['Float']>;
  token1_pooled?: Maybe<Scalars['Float']>;
  token1_total_supply?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.pair_with_prices_tb" */
export type Polygon_Pair_With_Prices_Tb = {
  __typename?: 'polygon_pair_with_prices_tb';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  direction: Scalars['String'];
  exchange: Scalars['String'];
  fixed_point_price: Scalars['numeric'];
  native_price: Scalars['numeric'];
  price: Scalars['numeric'];
  price_scalar: Scalars['numeric'];
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  usd_price: Scalars['numeric'];
};

/** Boolean expression to filter rows from the table "polygon.pair_with_prices_tb". All fields are combined with a logical 'AND'. */
export type Polygon_Pair_With_Prices_Tb_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Bool_Exp>>;
  _not?: Maybe<Polygon_Pair_With_Prices_Tb_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  fixed_point_price?: Maybe<Numeric_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  price_scalar?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.pair_with_prices_tb". */
export type Polygon_Pair_With_Prices_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  fixed_point_price?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  price_scalar?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "polygon.pair_with_prices_tb" */
export enum Polygon_Pair_With_Prices_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  Direction = 'direction',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  FixedPointPrice = 'fixed_point_price',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  Price = 'price',
  /** column name */
  PriceScalar = 'price_scalar',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  UsdPrice = 'usd_price'
}

/** columns and relationships of "polygon.pairs" */
export type Polygon_Pairs = {
  __typename?: 'polygon_pairs';
  created_at: Scalars['timestamptz'];
  exchange: Scalars['String'];
  id?: Maybe<Scalars['Int']>;
  pair_address: Scalars['String'];
  pair_creation_date?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  token0?: Maybe<Polygon_Tokens>;
  token0_address: Scalars['String'];
  token0_address_lc?: Maybe<Scalars['String']>;
  token0_pooled?: Maybe<Scalars['numeric']>;
  /** An object relationship */
  token1?: Maybe<Polygon_Tokens>;
  token1_address: Scalars['String'];
  token1_address_lc?: Maybe<Scalars['String']>;
  token1_pooled?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "polygon.pairs". All fields are combined with a logical 'AND'. */
export type Polygon_Pairs_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Pairs_Bool_Exp>>;
  _not?: Maybe<Polygon_Pairs_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Pairs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  pair_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  token0?: Maybe<Polygon_Tokens_Bool_Exp>;
  token0_address?: Maybe<String_Comparison_Exp>;
  token0_address_lc?: Maybe<String_Comparison_Exp>;
  token0_pooled?: Maybe<Numeric_Comparison_Exp>;
  token1?: Maybe<Polygon_Tokens_Bool_Exp>;
  token1_address?: Maybe<String_Comparison_Exp>;
  token1_address_lc?: Maybe<String_Comparison_Exp>;
  token1_pooled?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.pairs". */
export type Polygon_Pairs_Order_By = {
  created_at?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  pair_creation_date?: Maybe<Order_By>;
  token0?: Maybe<Polygon_Tokens_Order_By>;
  token0_address?: Maybe<Order_By>;
  token0_address_lc?: Maybe<Order_By>;
  token0_pooled?: Maybe<Order_By>;
  token1?: Maybe<Polygon_Tokens_Order_By>;
  token1_address?: Maybe<Order_By>;
  token1_address_lc?: Maybe<Order_By>;
  token1_pooled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "polygon.pairs" */
export enum Polygon_Pairs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  Id = 'id',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  PairCreationDate = 'pair_creation_date',
  /** column name */
  Token0Address = 'token0_address',
  /** column name */
  Token0AddressLc = 'token0_address_lc',
  /** column name */
  Token0Pooled = 'token0_pooled',
  /** column name */
  Token1Address = 'token1_address',
  /** column name */
  Token1AddressLc = 'token1_address_lc',
  /** column name */
  Token1Pooled = 'token1_pooled',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "polygon.pairs_tx_count" */
export type Polygon_Pairs_Tx_Count = {
  __typename?: 'polygon_pairs_tx_count';
  exchange: Scalars['String'];
  latest_timestamp: Scalars['Int'];
  pair_address: Scalars['String'];
  tx_count: Scalars['bigint'];
};

/** Boolean expression to filter rows from the table "polygon.pairs_tx_count". All fields are combined with a logical 'AND'. */
export type Polygon_Pairs_Tx_Count_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Pairs_Tx_Count_Bool_Exp>>;
  _not?: Maybe<Polygon_Pairs_Tx_Count_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Pairs_Tx_Count_Bool_Exp>>;
  exchange?: Maybe<String_Comparison_Exp>;
  latest_timestamp?: Maybe<Int_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  tx_count?: Maybe<Bigint_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.pairs_tx_count". */
export type Polygon_Pairs_Tx_Count_Order_By = {
  exchange?: Maybe<Order_By>;
  latest_timestamp?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  tx_count?: Maybe<Order_By>;
};

/** select columns of table "polygon.pairs_tx_count" */
export enum Polygon_Pairs_Tx_Count_Select_Column {
  /** column name */
  Exchange = 'exchange',
  /** column name */
  LatestTimestamp = 'latest_timestamp',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  TxCount = 'tx_count'
}

/** columns and relationships of "polygon.protocols" */
export type Polygon_Protocols = {
  __typename?: 'polygon_protocols';
  name: Scalars['String'];
  native_token: Scalars['String'];
  type: Scalars['String'];
};

/** Boolean expression to filter rows from the table "polygon.protocols". All fields are combined with a logical 'AND'. */
export type Polygon_Protocols_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Protocols_Bool_Exp>>;
  _not?: Maybe<Polygon_Protocols_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Protocols_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  native_token?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.protocols". */
export type Polygon_Protocols_Order_By = {
  name?: Maybe<Order_By>;
  native_token?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** select columns of table "polygon.protocols" */
export enum Polygon_Protocols_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  NativeToken = 'native_token',
  /** column name */
  Type = 'type'
}

/** columns and relationships of "polygon.swap_candles_cached" */
export type Polygon_Swap_Candles_Cached = {
  __typename?: 'polygon_swap_candles_cached';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange: Scalars['String'];
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address: Scalars['String'];
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "polygon.swap_candles_cached" */
export type Polygon_Swap_Candles_Cached_Aggregate = {
  __typename?: 'polygon_swap_candles_cached_aggregate';
  aggregate?: Maybe<Polygon_Swap_Candles_Cached_Aggregate_Fields>;
  nodes: Array<Polygon_Swap_Candles_Cached>;
};

/** aggregate fields of "polygon.swap_candles_cached" */
export type Polygon_Swap_Candles_Cached_Aggregate_Fields = {
  __typename?: 'polygon_swap_candles_cached_aggregate_fields';
  avg?: Maybe<Polygon_Swap_Candles_Cached_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Swap_Candles_Cached_Max_Fields>;
  min?: Maybe<Polygon_Swap_Candles_Cached_Min_Fields>;
  stddev?: Maybe<Polygon_Swap_Candles_Cached_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Swap_Candles_Cached_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Swap_Candles_Cached_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Swap_Candles_Cached_Sum_Fields>;
  var_pop?: Maybe<Polygon_Swap_Candles_Cached_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Swap_Candles_Cached_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Swap_Candles_Cached_Variance_Fields>;
};


/** aggregate fields of "polygon.swap_candles_cached" */
export type Polygon_Swap_Candles_Cached_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Swap_Candles_Cached_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Swap_Candles_Cached_Avg_Fields = {
  __typename?: 'polygon_swap_candles_cached_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.swap_candles_cached". All fields are combined with a logical 'AND'. */
export type Polygon_Swap_Candles_Cached_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Swap_Candles_Cached_Bool_Exp>>;
  _not?: Maybe<Polygon_Swap_Candles_Cached_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Swap_Candles_Cached_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  resolution_seconds?: Maybe<Int_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Swap_Candles_Cached_Max_Fields = {
  __typename?: 'polygon_swap_candles_cached_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Polygon_Swap_Candles_Cached_Min_Fields = {
  __typename?: 'polygon_swap_candles_cached_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  exchange?: Maybe<Scalars['String']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "polygon.swap_candles_cached". */
export type Polygon_Swap_Candles_Cached_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  resolution_seconds?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "polygon.swap_candles_cached" */
export enum Polygon_Swap_Candles_Cached_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  ResolutionSeconds = 'resolution_seconds',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** aggregate stddev on columns */
export type Polygon_Swap_Candles_Cached_Stddev_Fields = {
  __typename?: 'polygon_swap_candles_cached_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Swap_Candles_Cached_Stddev_Pop_Fields = {
  __typename?: 'polygon_swap_candles_cached_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Swap_Candles_Cached_Stddev_Samp_Fields = {
  __typename?: 'polygon_swap_candles_cached_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Swap_Candles_Cached_Sum_Fields = {
  __typename?: 'polygon_swap_candles_cached_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time?: Maybe<Scalars['Int']>;
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  resolution_seconds?: Maybe<Scalars['Int']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Swap_Candles_Cached_Var_Pop_Fields = {
  __typename?: 'polygon_swap_candles_cached_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Swap_Candles_Cached_Var_Samp_Fields = {
  __typename?: 'polygon_swap_candles_cached_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Swap_Candles_Cached_Variance_Fields = {
  __typename?: 'polygon_swap_candles_cached_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_start?: Maybe<Scalars['Float']>;
  close?: Maybe<Scalars['Float']>;
  close_native?: Maybe<Scalars['Float']>;
  close_usd?: Maybe<Scalars['Float']>;
  generation_time?: Maybe<Scalars['Float']>;
  high?: Maybe<Scalars['Float']>;
  high_native?: Maybe<Scalars['Float']>;
  high_usd?: Maybe<Scalars['Float']>;
  low?: Maybe<Scalars['Float']>;
  low_native?: Maybe<Scalars['Float']>;
  low_usd?: Maybe<Scalars['Float']>;
  native_volume?: Maybe<Scalars['Float']>;
  open?: Maybe<Scalars['Float']>;
  open_native?: Maybe<Scalars['Float']>;
  open_usd?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  resolution_seconds?: Maybe<Scalars['Float']>;
  usd_volume?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.swap_candles_tb" */
export type Polygon_Swap_Candles_Tb = {
  __typename?: 'polygon_swap_candles_tb';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_start?: Maybe<Scalars['Int']>;
  close?: Maybe<Scalars['numeric']>;
  close_native?: Maybe<Scalars['numeric']>;
  close_usd?: Maybe<Scalars['numeric']>;
  generation_time: Scalars['Int'];
  high?: Maybe<Scalars['numeric']>;
  high_native?: Maybe<Scalars['numeric']>;
  high_usd?: Maybe<Scalars['numeric']>;
  low?: Maybe<Scalars['numeric']>;
  low_native?: Maybe<Scalars['numeric']>;
  low_usd?: Maybe<Scalars['numeric']>;
  native_volume?: Maybe<Scalars['numeric']>;
  open?: Maybe<Scalars['numeric']>;
  open_native?: Maybe<Scalars['numeric']>;
  open_usd?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  usd_volume?: Maybe<Scalars['numeric']>;
};

/** Boolean expression to filter rows from the table "polygon.swap_candles_tb". All fields are combined with a logical 'AND'. */
export type Polygon_Swap_Candles_Tb_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Swap_Candles_Tb_Bool_Exp>>;
  _not?: Maybe<Polygon_Swap_Candles_Tb_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Swap_Candles_Tb_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_start?: Maybe<Int_Comparison_Exp>;
  close?: Maybe<Numeric_Comparison_Exp>;
  close_native?: Maybe<Numeric_Comparison_Exp>;
  close_usd?: Maybe<Numeric_Comparison_Exp>;
  generation_time?: Maybe<Int_Comparison_Exp>;
  high?: Maybe<Numeric_Comparison_Exp>;
  high_native?: Maybe<Numeric_Comparison_Exp>;
  high_usd?: Maybe<Numeric_Comparison_Exp>;
  low?: Maybe<Numeric_Comparison_Exp>;
  low_native?: Maybe<Numeric_Comparison_Exp>;
  low_usd?: Maybe<Numeric_Comparison_Exp>;
  native_volume?: Maybe<Numeric_Comparison_Exp>;
  open?: Maybe<Numeric_Comparison_Exp>;
  open_native?: Maybe<Numeric_Comparison_Exp>;
  open_usd?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  usd_volume?: Maybe<Numeric_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.swap_candles_tb". */
export type Polygon_Swap_Candles_Tb_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_start?: Maybe<Order_By>;
  close?: Maybe<Order_By>;
  close_native?: Maybe<Order_By>;
  close_usd?: Maybe<Order_By>;
  generation_time?: Maybe<Order_By>;
  high?: Maybe<Order_By>;
  high_native?: Maybe<Order_By>;
  high_usd?: Maybe<Order_By>;
  low?: Maybe<Order_By>;
  low_native?: Maybe<Order_By>;
  low_usd?: Maybe<Order_By>;
  native_volume?: Maybe<Order_By>;
  open?: Maybe<Order_By>;
  open_native?: Maybe<Order_By>;
  open_usd?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  usd_volume?: Maybe<Order_By>;
};

/** select columns of table "polygon.swap_candles_tb" */
export enum Polygon_Swap_Candles_Tb_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  CandleStart = 'candle_start',
  /** column name */
  Close = 'close',
  /** column name */
  CloseNative = 'close_native',
  /** column name */
  CloseUsd = 'close_usd',
  /** column name */
  GenerationTime = 'generation_time',
  /** column name */
  High = 'high',
  /** column name */
  HighNative = 'high_native',
  /** column name */
  HighUsd = 'high_usd',
  /** column name */
  Low = 'low',
  /** column name */
  LowNative = 'low_native',
  /** column name */
  LowUsd = 'low_usd',
  /** column name */
  NativeVolume = 'native_volume',
  /** column name */
  Open = 'open',
  /** column name */
  OpenNative = 'open_native',
  /** column name */
  OpenUsd = 'open_usd',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  UsdVolume = 'usd_volume'
}

/** columns and relationships of "polygon.tokens" */
export type Polygon_Tokens = {
  __typename?: 'polygon_tokens';
  address: Scalars['String'];
  circ_supply?: Maybe<Scalars['numeric']>;
  created_at: Scalars['timestamptz'];
  decimals?: Maybe<Scalars['Int']>;
  img_err?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  primary_img_uri?: Maybe<Scalars['String']>;
  symbol?: Maybe<Scalars['String']>;
  token_creation_date?: Maybe<Scalars['timestamptz']>;
  total_supply?: Maybe<Scalars['numeric']>;
  updated_at: Scalars['timestamptz'];
};

/** Boolean expression to filter rows from the table "polygon.tokens". All fields are combined with a logical 'AND'. */
export type Polygon_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Tokens_Bool_Exp>>;
  _not?: Maybe<Polygon_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Tokens_Bool_Exp>>;
  address?: Maybe<String_Comparison_Exp>;
  circ_supply?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  decimals?: Maybe<Int_Comparison_Exp>;
  img_err?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  primary_img_uri?: Maybe<String_Comparison_Exp>;
  symbol?: Maybe<String_Comparison_Exp>;
  token_creation_date?: Maybe<Timestamptz_Comparison_Exp>;
  total_supply?: Maybe<Numeric_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.tokens". */
export type Polygon_Tokens_Order_By = {
  address?: Maybe<Order_By>;
  circ_supply?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  decimals?: Maybe<Order_By>;
  img_err?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  primary_img_uri?: Maybe<Order_By>;
  symbol?: Maybe<Order_By>;
  token_creation_date?: Maybe<Order_By>;
  total_supply?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "polygon.tokens" */
export enum Polygon_Tokens_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  CircSupply = 'circ_supply',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Decimals = 'decimals',
  /** column name */
  ImgErr = 'img_err',
  /** column name */
  Name = 'name',
  /** column name */
  PrimaryImgUri = 'primary_img_uri',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  TokenCreationDate = 'token_creation_date',
  /** column name */
  TotalSupply = 'total_supply',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "polygon.tokenswaps_with_prices" */
export type Polygon_Tokenswaps_With_Prices = {
  __typename?: 'polygon_tokenswaps_with_prices';
  base_amount: Scalars['numeric'];
  base_decimals: Scalars['Int'];
  base_token: Scalars['String'];
  candle_1d: Scalars['Int'];
  candle_1min: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  direction: Scalars['String'];
  eventindex?: Maybe<Scalars['Int']>;
  exchange: Scalars['String'];
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount: Scalars['numeric'];
  quote_decimals: Scalars['Int'];
  quote_token: Scalars['String'];
  swapindex: Scalars['Int'];
  timestamp: Scalars['Int'];
  txhash: Scalars['String'];
  unusual: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregated selection of "polygon.tokenswaps_with_prices" */
export type Polygon_Tokenswaps_With_Prices_Aggregate = {
  __typename?: 'polygon_tokenswaps_with_prices_aggregate';
  aggregate?: Maybe<Polygon_Tokenswaps_With_Prices_Aggregate_Fields>;
  nodes: Array<Polygon_Tokenswaps_With_Prices>;
};

/** aggregate fields of "polygon.tokenswaps_with_prices" */
export type Polygon_Tokenswaps_With_Prices_Aggregate_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_aggregate_fields';
  avg?: Maybe<Polygon_Tokenswaps_With_Prices_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Polygon_Tokenswaps_With_Prices_Max_Fields>;
  min?: Maybe<Polygon_Tokenswaps_With_Prices_Min_Fields>;
  stddev?: Maybe<Polygon_Tokenswaps_With_Prices_Stddev_Fields>;
  stddev_pop?: Maybe<Polygon_Tokenswaps_With_Prices_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Polygon_Tokenswaps_With_Prices_Stddev_Samp_Fields>;
  sum?: Maybe<Polygon_Tokenswaps_With_Prices_Sum_Fields>;
  var_pop?: Maybe<Polygon_Tokenswaps_With_Prices_Var_Pop_Fields>;
  var_samp?: Maybe<Polygon_Tokenswaps_With_Prices_Var_Samp_Fields>;
  variance?: Maybe<Polygon_Tokenswaps_With_Prices_Variance_Fields>;
};


/** aggregate fields of "polygon.tokenswaps_with_prices" */
export type Polygon_Tokenswaps_With_Prices_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Polygon_Tokenswaps_With_Prices_Avg_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_avg_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "polygon.tokenswaps_with_prices". All fields are combined with a logical 'AND'. */
export type Polygon_Tokenswaps_With_Prices_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Bool_Exp>>;
  _not?: Maybe<Polygon_Tokenswaps_With_Prices_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Bool_Exp>>;
  base_amount?: Maybe<Numeric_Comparison_Exp>;
  base_decimals?: Maybe<Int_Comparison_Exp>;
  base_token?: Maybe<String_Comparison_Exp>;
  candle_1d?: Maybe<Int_Comparison_Exp>;
  candle_1min?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
  eventindex?: Maybe<Int_Comparison_Exp>;
  exchange?: Maybe<String_Comparison_Exp>;
  native_price?: Maybe<Numeric_Comparison_Exp>;
  pair_address?: Maybe<String_Comparison_Exp>;
  price?: Maybe<Numeric_Comparison_Exp>;
  quote_amount?: Maybe<Numeric_Comparison_Exp>;
  quote_decimals?: Maybe<Int_Comparison_Exp>;
  quote_token?: Maybe<String_Comparison_Exp>;
  swapindex?: Maybe<Int_Comparison_Exp>;
  timestamp?: Maybe<Int_Comparison_Exp>;
  txhash?: Maybe<String_Comparison_Exp>;
  unusual?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usd_price?: Maybe<Numeric_Comparison_Exp>;
};

/** aggregate max on columns */
export type Polygon_Tokenswaps_With_Prices_Max_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_max_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate min on columns */
export type Polygon_Tokenswaps_With_Prices_Min_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_min_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  base_token?: Maybe<Scalars['String']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  direction?: Maybe<Scalars['String']>;
  eventindex?: Maybe<Scalars['Int']>;
  exchange?: Maybe<Scalars['String']>;
  native_price?: Maybe<Scalars['numeric']>;
  pair_address?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  quote_token?: Maybe<Scalars['String']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  txhash?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** Ordering options when selecting data from "polygon.tokenswaps_with_prices". */
export type Polygon_Tokenswaps_With_Prices_Order_By = {
  base_amount?: Maybe<Order_By>;
  base_decimals?: Maybe<Order_By>;
  base_token?: Maybe<Order_By>;
  candle_1d?: Maybe<Order_By>;
  candle_1min?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  eventindex?: Maybe<Order_By>;
  exchange?: Maybe<Order_By>;
  native_price?: Maybe<Order_By>;
  pair_address?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  quote_amount?: Maybe<Order_By>;
  quote_decimals?: Maybe<Order_By>;
  quote_token?: Maybe<Order_By>;
  swapindex?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  txhash?: Maybe<Order_By>;
  unusual?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  usd_price?: Maybe<Order_By>;
};

/** select columns of table "polygon.tokenswaps_with_prices" */
export enum Polygon_Tokenswaps_With_Prices_Select_Column {
  /** column name */
  BaseAmount = 'base_amount',
  /** column name */
  BaseDecimals = 'base_decimals',
  /** column name */
  BaseToken = 'base_token',
  /** column name */
  Candle_1d = 'candle_1d',
  /** column name */
  Candle_1min = 'candle_1min',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Direction = 'direction',
  /** column name */
  Eventindex = 'eventindex',
  /** column name */
  Exchange = 'exchange',
  /** column name */
  NativePrice = 'native_price',
  /** column name */
  PairAddress = 'pair_address',
  /** column name */
  Price = 'price',
  /** column name */
  QuoteAmount = 'quote_amount',
  /** column name */
  QuoteDecimals = 'quote_decimals',
  /** column name */
  QuoteToken = 'quote_token',
  /** column name */
  Swapindex = 'swapindex',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  Txhash = 'txhash',
  /** column name */
  Unusual = 'unusual',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UsdPrice = 'usd_price'
}

/** aggregate stddev on columns */
export type Polygon_Tokenswaps_With_Prices_Stddev_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_stddev_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Polygon_Tokenswaps_With_Prices_Stddev_Pop_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_stddev_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Polygon_Tokenswaps_With_Prices_Stddev_Samp_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_stddev_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Polygon_Tokenswaps_With_Prices_Sum_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_sum_fields';
  base_amount?: Maybe<Scalars['numeric']>;
  base_decimals?: Maybe<Scalars['Int']>;
  candle_1d?: Maybe<Scalars['Int']>;
  candle_1min?: Maybe<Scalars['Int']>;
  eventindex?: Maybe<Scalars['Int']>;
  native_price?: Maybe<Scalars['numeric']>;
  price?: Maybe<Scalars['numeric']>;
  quote_amount?: Maybe<Scalars['numeric']>;
  quote_decimals?: Maybe<Scalars['Int']>;
  swapindex?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Int']>;
  usd_price?: Maybe<Scalars['numeric']>;
};

/** aggregate var_pop on columns */
export type Polygon_Tokenswaps_With_Prices_Var_Pop_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_var_pop_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Polygon_Tokenswaps_With_Prices_Var_Samp_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_var_samp_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Polygon_Tokenswaps_With_Prices_Variance_Fields = {
  __typename?: 'polygon_tokenswaps_with_prices_variance_fields';
  base_amount?: Maybe<Scalars['Float']>;
  base_decimals?: Maybe<Scalars['Float']>;
  candle_1d?: Maybe<Scalars['Float']>;
  candle_1min?: Maybe<Scalars['Float']>;
  eventindex?: Maybe<Scalars['Float']>;
  native_price?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quote_amount?: Maybe<Scalars['Float']>;
  quote_decimals?: Maybe<Scalars['Float']>;
  swapindex?: Maybe<Scalars['Float']>;
  timestamp?: Maybe<Scalars['Float']>;
  usd_price?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "polygon.usd_tokens" */
export type Polygon_Usd_Tokens = {
  __typename?: 'polygon_usd_tokens';
  usd_token: Scalars['String'];
};

/** Boolean expression to filter rows from the table "polygon.usd_tokens". All fields are combined with a logical 'AND'. */
export type Polygon_Usd_Tokens_Bool_Exp = {
  _and?: Maybe<Array<Polygon_Usd_Tokens_Bool_Exp>>;
  _not?: Maybe<Polygon_Usd_Tokens_Bool_Exp>;
  _or?: Maybe<Array<Polygon_Usd_Tokens_Bool_Exp>>;
  usd_token?: Maybe<String_Comparison_Exp>;
};

/** Ordering options when selecting data from "polygon.usd_tokens". */
export type Polygon_Usd_Tokens_Order_By = {
  usd_token?: Maybe<Order_By>;
};

/** select columns of table "polygon.usd_tokens" */
export enum Polygon_Usd_Tokens_Select_Column {
  /** column name */
  UsdToken = 'usd_token'
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "arbitrum.borrows" */
  arbitrum_borrows: Array<Arbitrum_Borrows>;
  /** fetch data from the table: "arbitrum.borrows" using primary key columns */
  arbitrum_borrows_by_pk?: Maybe<Arbitrum_Borrows>;
  /** execute function "arbitrum.get_lending_market_user_count" which returns "arbitrum.lending_market_user_count_tb" */
  arbitrum_get_lending_market_user_count: Array<Arbitrum_Lending_Market_User_Count_Tb>;
  /** execute function "arbitrum.get_pair_tx_count" which returns "arbitrum.pairs_tx_count" */
  arbitrum_get_pair_tx_count: Array<Arbitrum_Pairs_Tx_Count>;
  /** execute function "arbitrum.get_swap_candles" which returns "arbitrum.swap_candles_tb" */
  arbitrum_get_swap_candles: Array<Arbitrum_Swap_Candles_Tb>;
  /** fetch data from the table: "arbitrum.lending_market_daily_snapshots" */
  arbitrum_lending_market_daily_snapshots: Array<Arbitrum_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "arbitrum.lending_market_user_count_tb" */
  arbitrum_lending_market_user_count_tb: Array<Arbitrum_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "arbitrum.lending_supplies" */
  arbitrum_lending_supplies: Array<Arbitrum_Lending_Supplies>;
  /** fetch data from the table: "arbitrum.lending_supplies" using primary key columns */
  arbitrum_lending_supplies_by_pk?: Maybe<Arbitrum_Lending_Supplies>;
  /** fetch data from the table: "arbitrum.liquidity_changes" */
  arbitrum_liquidity_changes: Array<Arbitrum_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "arbitrum.liquidity_changes" */
  arbitrum_liquidity_changes_aggregate: Arbitrum_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "arbitrum.liquidity_changes" using primary key columns */
  arbitrum_liquidity_changes_by_pk?: Maybe<Arbitrum_Liquidity_Changes>;
  /** fetch data from the table: "arbitrum.liquidity_with_prices" */
  arbitrum_liquidity_with_prices: Array<Arbitrum_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "arbitrum.liquidity_with_prices" */
  arbitrum_liquidity_with_prices_aggregate: Arbitrum_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "arbitrum.liquidity_with_prices" using primary key columns */
  arbitrum_liquidity_with_prices_by_pk?: Maybe<Arbitrum_Liquidity_With_Prices>;
  /** fetch data from the table: "arbitrum.loan_liquidations" */
  arbitrum_loan_liquidations: Array<Arbitrum_Loan_Liquidations>;
  /** fetch data from the table: "arbitrum.loan_liquidations" using primary key columns */
  arbitrum_loan_liquidations_by_pk?: Maybe<Arbitrum_Loan_Liquidations>;
  /** fetch data from the table: "arbitrum.pair_search" */
  arbitrum_pair_search: Array<Arbitrum_Pair_Search>;
  /** fetch aggregated fields from the table: "arbitrum.pair_search" */
  arbitrum_pair_search_aggregate: Arbitrum_Pair_Search_Aggregate;
  /** fetch data from the table: "arbitrum.pair_summary" */
  arbitrum_pair_summary: Array<Arbitrum_Pair_Summary>;
  /** fetch aggregated fields from the table: "arbitrum.pair_summary" */
  arbitrum_pair_summary_aggregate: Arbitrum_Pair_Summary_Aggregate;
  /** fetch data from the table: "arbitrum.pair_with_prices_tb" */
  arbitrum_pair_with_prices_tb: Array<Arbitrum_Pair_With_Prices_Tb>;
  /** fetch data from the table: "arbitrum.pairs" */
  arbitrum_pairs: Array<Arbitrum_Pairs>;
  /** fetch data from the table: "arbitrum.pairs" using primary key columns */
  arbitrum_pairs_by_pk?: Maybe<Arbitrum_Pairs>;
  /** fetch data from the table: "arbitrum.pairs_tx_count" */
  arbitrum_pairs_tx_count: Array<Arbitrum_Pairs_Tx_Count>;
  /** fetch data from the table: "arbitrum.pairs_tx_count" using primary key columns */
  arbitrum_pairs_tx_count_by_pk?: Maybe<Arbitrum_Pairs_Tx_Count>;
  /** fetch data from the table: "arbitrum.protocols" */
  arbitrum_protocols: Array<Arbitrum_Protocols>;
  /** fetch data from the table: "arbitrum.protocols" using primary key columns */
  arbitrum_protocols_by_pk?: Maybe<Arbitrum_Protocols>;
  /** fetch data from the table: "arbitrum.swap_candles_cached" */
  arbitrum_swap_candles_cached: Array<Arbitrum_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "arbitrum.swap_candles_cached" */
  arbitrum_swap_candles_cached_aggregate: Arbitrum_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "arbitrum.swap_candles_cached" using primary key columns */
  arbitrum_swap_candles_cached_by_pk?: Maybe<Arbitrum_Swap_Candles_Cached>;
  /** fetch data from the table: "arbitrum.swap_candles_tb" */
  arbitrum_swap_candles_tb: Array<Arbitrum_Swap_Candles_Tb>;
  /** fetch data from the table: "arbitrum.tokens" */
  arbitrum_tokens: Array<Arbitrum_Tokens>;
  /** fetch data from the table: "arbitrum.tokens" using primary key columns */
  arbitrum_tokens_by_pk?: Maybe<Arbitrum_Tokens>;
  /** fetch data from the table: "arbitrum.tokenswaps_with_prices" */
  arbitrum_tokenswaps_with_prices: Array<Arbitrum_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "arbitrum.tokenswaps_with_prices" */
  arbitrum_tokenswaps_with_prices_aggregate: Arbitrum_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "arbitrum.tokenswaps_with_prices" using primary key columns */
  arbitrum_tokenswaps_with_prices_by_pk?: Maybe<Arbitrum_Tokenswaps_With_Prices>;
  /** fetch data from the table: "arbitrum.usd_tokens" */
  arbitrum_usd_tokens: Array<Arbitrum_Usd_Tokens>;
  /** fetch data from the table: "arbitrum.usd_tokens" using primary key columns */
  arbitrum_usd_tokens_by_pk?: Maybe<Arbitrum_Usd_Tokens>;
  /** fetch data from the table: "avalanche.borrows" */
  avalanche_borrows: Array<Avalanche_Borrows>;
  /** fetch data from the table: "avalanche.borrows" using primary key columns */
  avalanche_borrows_by_pk?: Maybe<Avalanche_Borrows>;
  /** execute function "avalanche.get_lending_market_user_count" which returns "avalanche.lending_market_user_count_tb" */
  avalanche_get_lending_market_user_count: Array<Avalanche_Lending_Market_User_Count_Tb>;
  /** execute function "avalanche.get_pair_tx_count" which returns "avalanche.pairs_tx_count" */
  avalanche_get_pair_tx_count: Array<Avalanche_Pairs_Tx_Count>;
  /** execute function "avalanche.get_swap_candles" which returns "avalanche.swap_candles_tb" */
  avalanche_get_swap_candles: Array<Avalanche_Swap_Candles_Tb>;
  /** fetch data from the table: "avalanche.lending_market_daily_snapshots" */
  avalanche_lending_market_daily_snapshots: Array<Avalanche_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "avalanche.lending_market_user_count_tb" */
  avalanche_lending_market_user_count_tb: Array<Avalanche_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "avalanche.lending_supplies" */
  avalanche_lending_supplies: Array<Avalanche_Lending_Supplies>;
  /** fetch data from the table: "avalanche.lending_supplies" using primary key columns */
  avalanche_lending_supplies_by_pk?: Maybe<Avalanche_Lending_Supplies>;
  /** fetch data from the table: "avalanche.liquidity_changes" */
  avalanche_liquidity_changes: Array<Avalanche_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "avalanche.liquidity_changes" */
  avalanche_liquidity_changes_aggregate: Avalanche_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "avalanche.liquidity_changes" using primary key columns */
  avalanche_liquidity_changes_by_pk?: Maybe<Avalanche_Liquidity_Changes>;
  /** fetch data from the table: "avalanche.liquidity_with_prices" */
  avalanche_liquidity_with_prices: Array<Avalanche_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "avalanche.liquidity_with_prices" */
  avalanche_liquidity_with_prices_aggregate: Avalanche_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "avalanche.liquidity_with_prices" using primary key columns */
  avalanche_liquidity_with_prices_by_pk?: Maybe<Avalanche_Liquidity_With_Prices>;
  /** fetch data from the table: "avalanche.loan_liquidations" */
  avalanche_loan_liquidations: Array<Avalanche_Loan_Liquidations>;
  /** fetch data from the table: "avalanche.loan_liquidations" using primary key columns */
  avalanche_loan_liquidations_by_pk?: Maybe<Avalanche_Loan_Liquidations>;
  /** fetch data from the table: "avalanche.pair_search" */
  avalanche_pair_search: Array<Avalanche_Pair_Search>;
  /** fetch aggregated fields from the table: "avalanche.pair_search" */
  avalanche_pair_search_aggregate: Avalanche_Pair_Search_Aggregate;
  /** fetch data from the table: "avalanche.pair_summary" */
  avalanche_pair_summary: Array<Avalanche_Pair_Summary>;
  /** fetch aggregated fields from the table: "avalanche.pair_summary" */
  avalanche_pair_summary_aggregate: Avalanche_Pair_Summary_Aggregate;
  /** fetch data from the table: "avalanche.pair_with_prices_tb" */
  avalanche_pair_with_prices_tb: Array<Avalanche_Pair_With_Prices_Tb>;
  /** fetch data from the table: "avalanche.pairs" */
  avalanche_pairs: Array<Avalanche_Pairs>;
  /** fetch data from the table: "avalanche.pairs" using primary key columns */
  avalanche_pairs_by_pk?: Maybe<Avalanche_Pairs>;
  /** fetch data from the table: "avalanche.pairs_tx_count" */
  avalanche_pairs_tx_count: Array<Avalanche_Pairs_Tx_Count>;
  /** fetch data from the table: "avalanche.pairs_tx_count" using primary key columns */
  avalanche_pairs_tx_count_by_pk?: Maybe<Avalanche_Pairs_Tx_Count>;
  /** fetch data from the table: "avalanche.protocols" */
  avalanche_protocols: Array<Avalanche_Protocols>;
  /** fetch data from the table: "avalanche.protocols" using primary key columns */
  avalanche_protocols_by_pk?: Maybe<Avalanche_Protocols>;
  /** fetch data from the table: "avalanche.swap_candles_cached" */
  avalanche_swap_candles_cached: Array<Avalanche_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "avalanche.swap_candles_cached" */
  avalanche_swap_candles_cached_aggregate: Avalanche_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "avalanche.swap_candles_cached" using primary key columns */
  avalanche_swap_candles_cached_by_pk?: Maybe<Avalanche_Swap_Candles_Cached>;
  /** fetch data from the table: "avalanche.swap_candles_tb" */
  avalanche_swap_candles_tb: Array<Avalanche_Swap_Candles_Tb>;
  /** fetch data from the table: "avalanche.tokens" */
  avalanche_tokens: Array<Avalanche_Tokens>;
  /** fetch data from the table: "avalanche.tokens" using primary key columns */
  avalanche_tokens_by_pk?: Maybe<Avalanche_Tokens>;
  /** fetch data from the table: "avalanche.tokenswaps_with_prices" */
  avalanche_tokenswaps_with_prices: Array<Avalanche_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "avalanche.tokenswaps_with_prices" */
  avalanche_tokenswaps_with_prices_aggregate: Avalanche_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "avalanche.tokenswaps_with_prices" using primary key columns */
  avalanche_tokenswaps_with_prices_by_pk?: Maybe<Avalanche_Tokenswaps_With_Prices>;
  /** fetch data from the table: "avalanche.usd_tokens" */
  avalanche_usd_tokens: Array<Avalanche_Usd_Tokens>;
  /** fetch data from the table: "avalanche.usd_tokens" using primary key columns */
  avalanche_usd_tokens_by_pk?: Maybe<Avalanche_Usd_Tokens>;
  /** fetch data from the table: "bsc.borrows" */
  bsc_borrows: Array<Bsc_Borrows>;
  /** fetch data from the table: "bsc.borrows" using primary key columns */
  bsc_borrows_by_pk?: Maybe<Bsc_Borrows>;
  /** execute function "bsc.get_lending_market_user_count" which returns "bsc.lending_market_user_count_tb" */
  bsc_get_lending_market_user_count: Array<Bsc_Lending_Market_User_Count_Tb>;
  /** execute function "bsc.get_pair_tx_count" which returns "bsc.pairs_tx_count" */
  bsc_get_pair_tx_count: Array<Bsc_Pairs_Tx_Count>;
  /** execute function "bsc.get_swap_candles" which returns "bsc.swap_candles_tb" */
  bsc_get_swap_candles: Array<Bsc_Swap_Candles_Tb>;
  /** fetch data from the table: "bsc.lending_market_daily_snapshots" */
  bsc_lending_market_daily_snapshots: Array<Bsc_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "bsc.lending_market_user_count_tb" */
  bsc_lending_market_user_count_tb: Array<Bsc_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "bsc.lending_supplies" */
  bsc_lending_supplies: Array<Bsc_Lending_Supplies>;
  /** fetch data from the table: "bsc.lending_supplies" using primary key columns */
  bsc_lending_supplies_by_pk?: Maybe<Bsc_Lending_Supplies>;
  /** fetch data from the table: "bsc.liquidity_changes" */
  bsc_liquidity_changes: Array<Bsc_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "bsc.liquidity_changes" */
  bsc_liquidity_changes_aggregate: Bsc_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "bsc.liquidity_changes" using primary key columns */
  bsc_liquidity_changes_by_pk?: Maybe<Bsc_Liquidity_Changes>;
  /** fetch data from the table: "bsc.liquidity_with_prices" */
  bsc_liquidity_with_prices: Array<Bsc_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "bsc.liquidity_with_prices" */
  bsc_liquidity_with_prices_aggregate: Bsc_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "bsc.liquidity_with_prices" using primary key columns */
  bsc_liquidity_with_prices_by_pk?: Maybe<Bsc_Liquidity_With_Prices>;
  /** fetch data from the table: "bsc.loan_liquidations" */
  bsc_loan_liquidations: Array<Bsc_Loan_Liquidations>;
  /** fetch data from the table: "bsc.loan_liquidations" using primary key columns */
  bsc_loan_liquidations_by_pk?: Maybe<Bsc_Loan_Liquidations>;
  /** fetch data from the table: "bsc.pair_search" */
  bsc_pair_search: Array<Bsc_Pair_Search>;
  /** fetch data from the table: "bsc.pair_summary" */
  bsc_pair_summary: Array<Bsc_Pair_Summary>;
  /** fetch data from the table: "bsc.pair_with_prices_tb" */
  bsc_pair_with_prices_tb: Array<Bsc_Pair_With_Prices_Tb>;
  /** fetch data from the table: "bsc.pairs" */
  bsc_pairs: Array<Bsc_Pairs>;
  /** fetch data from the table: "bsc.pairs" using primary key columns */
  bsc_pairs_by_pk?: Maybe<Bsc_Pairs>;
  /** fetch data from the table: "bsc.pairs_tx_count" */
  bsc_pairs_tx_count: Array<Bsc_Pairs_Tx_Count>;
  /** fetch data from the table: "bsc.pairs_tx_count" using primary key columns */
  bsc_pairs_tx_count_by_pk?: Maybe<Bsc_Pairs_Tx_Count>;
  /** fetch data from the table: "bsc.protocols" */
  bsc_protocols: Array<Bsc_Protocols>;
  /** fetch data from the table: "bsc.protocols" using primary key columns */
  bsc_protocols_by_pk?: Maybe<Bsc_Protocols>;
  /** fetch data from the table: "bsc.swap_candles_cached" */
  bsc_swap_candles_cached: Array<Bsc_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "bsc.swap_candles_cached" */
  bsc_swap_candles_cached_aggregate: Bsc_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "bsc.swap_candles_cached" using primary key columns */
  bsc_swap_candles_cached_by_pk?: Maybe<Bsc_Swap_Candles_Cached>;
  /** fetch data from the table: "bsc.swap_candles_tb" */
  bsc_swap_candles_tb: Array<Bsc_Swap_Candles_Tb>;
  /** fetch data from the table: "bsc.tokens" */
  bsc_tokens: Array<Bsc_Tokens>;
  /** fetch data from the table: "bsc.tokens" using primary key columns */
  bsc_tokens_by_pk?: Maybe<Bsc_Tokens>;
  /** fetch data from the table: "bsc.tokenswaps_with_prices" */
  bsc_tokenswaps_with_prices: Array<Bsc_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "bsc.tokenswaps_with_prices" */
  bsc_tokenswaps_with_prices_aggregate: Bsc_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "bsc.tokenswaps_with_prices" using primary key columns */
  bsc_tokenswaps_with_prices_by_pk?: Maybe<Bsc_Tokenswaps_With_Prices>;
  /** fetch data from the table: "dfk.borrows" */
  dfk_borrows: Array<Dfk_Borrows>;
  /** fetch data from the table: "dfk.borrows" using primary key columns */
  dfk_borrows_by_pk?: Maybe<Dfk_Borrows>;
  /** execute function "dfk.get_lending_market_user_count" which returns "dfk.lending_market_user_count_tb" */
  dfk_get_lending_market_user_count: Array<Dfk_Lending_Market_User_Count_Tb>;
  /** execute function "dfk.get_pair_tx_count" which returns "dfk.pairs_tx_count" */
  dfk_get_pair_tx_count: Array<Dfk_Pairs_Tx_Count>;
  /** execute function "dfk.get_swap_candles" which returns "dfk.swap_candles_tb" */
  dfk_get_swap_candles: Array<Dfk_Swap_Candles_Tb>;
  /** fetch data from the table: "dfk.lending_market_daily_snapshots" */
  dfk_lending_market_daily_snapshots: Array<Dfk_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "dfk.lending_market_user_count_tb" */
  dfk_lending_market_user_count_tb: Array<Dfk_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "dfk.lending_supplies" */
  dfk_lending_supplies: Array<Dfk_Lending_Supplies>;
  /** fetch data from the table: "dfk.lending_supplies" using primary key columns */
  dfk_lending_supplies_by_pk?: Maybe<Dfk_Lending_Supplies>;
  /** fetch data from the table: "dfk.liquidity_changes" */
  dfk_liquidity_changes: Array<Dfk_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "dfk.liquidity_changes" */
  dfk_liquidity_changes_aggregate: Dfk_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "dfk.liquidity_changes" using primary key columns */
  dfk_liquidity_changes_by_pk?: Maybe<Dfk_Liquidity_Changes>;
  /** fetch data from the table: "dfk.liquidity_with_prices" */
  dfk_liquidity_with_prices: Array<Dfk_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "dfk.liquidity_with_prices" */
  dfk_liquidity_with_prices_aggregate: Dfk_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "dfk.liquidity_with_prices" using primary key columns */
  dfk_liquidity_with_prices_by_pk?: Maybe<Dfk_Liquidity_With_Prices>;
  /** fetch data from the table: "dfk.loan_liquidations" */
  dfk_loan_liquidations: Array<Dfk_Loan_Liquidations>;
  /** fetch data from the table: "dfk.loan_liquidations" using primary key columns */
  dfk_loan_liquidations_by_pk?: Maybe<Dfk_Loan_Liquidations>;
  /** fetch data from the table: "dfk.pair_search" */
  dfk_pair_search: Array<Dfk_Pair_Search>;
  /** fetch aggregated fields from the table: "dfk.pair_search" */
  dfk_pair_search_aggregate: Dfk_Pair_Search_Aggregate;
  /** fetch data from the table: "dfk.pair_summary" */
  dfk_pair_summary: Array<Dfk_Pair_Summary>;
  /** fetch aggregated fields from the table: "dfk.pair_summary" */
  dfk_pair_summary_aggregate: Dfk_Pair_Summary_Aggregate;
  /** fetch data from the table: "dfk.pair_with_prices_tb" */
  dfk_pair_with_prices_tb: Array<Dfk_Pair_With_Prices_Tb>;
  /** fetch data from the table: "dfk.pairs" */
  dfk_pairs: Array<Dfk_Pairs>;
  /** fetch data from the table: "dfk.pairs" using primary key columns */
  dfk_pairs_by_pk?: Maybe<Dfk_Pairs>;
  /** fetch data from the table: "dfk.pairs_tx_count" */
  dfk_pairs_tx_count: Array<Dfk_Pairs_Tx_Count>;
  /** fetch data from the table: "dfk.pairs_tx_count" using primary key columns */
  dfk_pairs_tx_count_by_pk?: Maybe<Dfk_Pairs_Tx_Count>;
  /** fetch data from the table: "dfk.protocols" */
  dfk_protocols: Array<Dfk_Protocols>;
  /** fetch data from the table: "dfk.protocols" using primary key columns */
  dfk_protocols_by_pk?: Maybe<Dfk_Protocols>;
  /** fetch data from the table: "dfk.swap_candles_cached" */
  dfk_swap_candles_cached: Array<Dfk_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "dfk.swap_candles_cached" */
  dfk_swap_candles_cached_aggregate: Dfk_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "dfk.swap_candles_cached" using primary key columns */
  dfk_swap_candles_cached_by_pk?: Maybe<Dfk_Swap_Candles_Cached>;
  /** fetch data from the table: "dfk.swap_candles_tb" */
  dfk_swap_candles_tb: Array<Dfk_Swap_Candles_Tb>;
  /** fetch data from the table: "dfk.tokens" */
  dfk_tokens: Array<Dfk_Tokens>;
  /** fetch data from the table: "dfk.tokens" using primary key columns */
  dfk_tokens_by_pk?: Maybe<Dfk_Tokens>;
  /** fetch data from the table: "dfk.tokenswaps_with_prices" */
  dfk_tokenswaps_with_prices: Array<Dfk_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "dfk.tokenswaps_with_prices" */
  dfk_tokenswaps_with_prices_aggregate: Dfk_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "dfk.tokenswaps_with_prices" using primary key columns */
  dfk_tokenswaps_with_prices_by_pk?: Maybe<Dfk_Tokenswaps_With_Prices>;
  /** fetch data from the table: "dfk.usd_tokens" */
  dfk_usd_tokens: Array<Dfk_Usd_Tokens>;
  /** fetch data from the table: "dfk.usd_tokens" using primary key columns */
  dfk_usd_tokens_by_pk?: Maybe<Dfk_Usd_Tokens>;
  /** fetch data from the table: "ethereum.borrows" */
  ethereum_borrows: Array<Ethereum_Borrows>;
  /** fetch data from the table: "ethereum.borrows" using primary key columns */
  ethereum_borrows_by_pk?: Maybe<Ethereum_Borrows>;
  /** execute function "ethereum.get_lending_market_user_count" which returns "ethereum.lending_market_user_count_tb" */
  ethereum_get_lending_market_user_count: Array<Ethereum_Lending_Market_User_Count_Tb>;
  /** execute function "ethereum.get_pair_tx_count" which returns "ethereum.pairs_tx_count" */
  ethereum_get_pair_tx_count: Array<Ethereum_Pairs_Tx_Count>;
  /** execute function "ethereum.get_swap_candles" which returns "ethereum.swap_candles_tb" */
  ethereum_get_swap_candles: Array<Ethereum_Swap_Candles_Tb>;
  /** fetch data from the table: "ethereum.lending_market_daily_snapshots" */
  ethereum_lending_market_daily_snapshots: Array<Ethereum_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "ethereum.lending_market_user_count_tb" */
  ethereum_lending_market_user_count_tb: Array<Ethereum_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "ethereum.lending_supplies" */
  ethereum_lending_supplies: Array<Ethereum_Lending_Supplies>;
  /** fetch data from the table: "ethereum.lending_supplies" using primary key columns */
  ethereum_lending_supplies_by_pk?: Maybe<Ethereum_Lending_Supplies>;
  /** fetch data from the table: "ethereum.liquidity_changes" */
  ethereum_liquidity_changes: Array<Ethereum_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "ethereum.liquidity_changes" */
  ethereum_liquidity_changes_aggregate: Ethereum_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "ethereum.liquidity_changes" using primary key columns */
  ethereum_liquidity_changes_by_pk?: Maybe<Ethereum_Liquidity_Changes>;
  /** fetch data from the table: "ethereum.liquidity_with_prices" */
  ethereum_liquidity_with_prices: Array<Ethereum_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "ethereum.liquidity_with_prices" */
  ethereum_liquidity_with_prices_aggregate: Ethereum_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "ethereum.liquidity_with_prices" using primary key columns */
  ethereum_liquidity_with_prices_by_pk?: Maybe<Ethereum_Liquidity_With_Prices>;
  /** fetch data from the table: "ethereum.loan_liquidations" */
  ethereum_loan_liquidations: Array<Ethereum_Loan_Liquidations>;
  /** fetch data from the table: "ethereum.loan_liquidations" using primary key columns */
  ethereum_loan_liquidations_by_pk?: Maybe<Ethereum_Loan_Liquidations>;
  /** fetch data from the table: "ethereum.pair_search" */
  ethereum_pair_search: Array<Ethereum_Pair_Search>;
  /** fetch aggregated fields from the table: "ethereum.pair_search" */
  ethereum_pair_search_aggregate: Ethereum_Pair_Search_Aggregate;
  /** fetch data from the table: "ethereum.pair_summary" */
  ethereum_pair_summary: Array<Ethereum_Pair_Summary>;
  /** fetch aggregated fields from the table: "ethereum.pair_summary" */
  ethereum_pair_summary_aggregate: Ethereum_Pair_Summary_Aggregate;
  /** fetch data from the table: "ethereum.pair_with_prices_tb" */
  ethereum_pair_with_prices_tb: Array<Ethereum_Pair_With_Prices_Tb>;
  /** fetch data from the table: "ethereum.pairs" */
  ethereum_pairs: Array<Ethereum_Pairs>;
  /** fetch data from the table: "ethereum.pairs" using primary key columns */
  ethereum_pairs_by_pk?: Maybe<Ethereum_Pairs>;
  /** fetch data from the table: "ethereum.pairs_tx_count" */
  ethereum_pairs_tx_count: Array<Ethereum_Pairs_Tx_Count>;
  /** fetch data from the table: "ethereum.pairs_tx_count" using primary key columns */
  ethereum_pairs_tx_count_by_pk?: Maybe<Ethereum_Pairs_Tx_Count>;
  /** fetch data from the table: "ethereum.protocols" */
  ethereum_protocols: Array<Ethereum_Protocols>;
  /** fetch data from the table: "ethereum.protocols" using primary key columns */
  ethereum_protocols_by_pk?: Maybe<Ethereum_Protocols>;
  /** fetch data from the table: "ethereum.swap_candles_cached" */
  ethereum_swap_candles_cached: Array<Ethereum_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "ethereum.swap_candles_cached" */
  ethereum_swap_candles_cached_aggregate: Ethereum_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "ethereum.swap_candles_cached" using primary key columns */
  ethereum_swap_candles_cached_by_pk?: Maybe<Ethereum_Swap_Candles_Cached>;
  /** fetch data from the table: "ethereum.swap_candles_tb" */
  ethereum_swap_candles_tb: Array<Ethereum_Swap_Candles_Tb>;
  /** fetch data from the table: "ethereum.tokens" */
  ethereum_tokens: Array<Ethereum_Tokens>;
  /** fetch data from the table: "ethereum.tokens" using primary key columns */
  ethereum_tokens_by_pk?: Maybe<Ethereum_Tokens>;
  /** fetch data from the table: "ethereum.tokenswaps_with_prices" */
  ethereum_tokenswaps_with_prices: Array<Ethereum_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "ethereum.tokenswaps_with_prices" */
  ethereum_tokenswaps_with_prices_aggregate: Ethereum_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "ethereum.tokenswaps_with_prices" using primary key columns */
  ethereum_tokenswaps_with_prices_by_pk?: Maybe<Ethereum_Tokenswaps_With_Prices>;
  /** fetch data from the table: "ethereum.usd_tokens" */
  ethereum_usd_tokens: Array<Ethereum_Usd_Tokens>;
  /** fetch data from the table: "ethereum.usd_tokens" using primary key columns */
  ethereum_usd_tokens_by_pk?: Maybe<Ethereum_Usd_Tokens>;
  /** fetch data from the table: "metis.borrows" */
  metis_borrows: Array<Metis_Borrows>;
  /** fetch data from the table: "metis.borrows" using primary key columns */
  metis_borrows_by_pk?: Maybe<Metis_Borrows>;
  /** execute function "metis.get_lending_market_user_count" which returns "metis.lending_market_user_count_tb" */
  metis_get_lending_market_user_count: Array<Metis_Lending_Market_User_Count_Tb>;
  /** execute function "metis.get_pair_tx_count" which returns "metis.pairs_tx_count" */
  metis_get_pair_tx_count: Array<Metis_Pairs_Tx_Count>;
  /** execute function "metis.get_swap_candles" which returns "metis.swap_candles_tb" */
  metis_get_swap_candles: Array<Metis_Swap_Candles_Tb>;
  /** fetch data from the table: "metis.lending_market_daily_snapshots" */
  metis_lending_market_daily_snapshots: Array<Metis_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "metis.lending_market_user_count_tb" */
  metis_lending_market_user_count_tb: Array<Metis_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "metis.lending_supplies" */
  metis_lending_supplies: Array<Metis_Lending_Supplies>;
  /** fetch data from the table: "metis.lending_supplies" using primary key columns */
  metis_lending_supplies_by_pk?: Maybe<Metis_Lending_Supplies>;
  /** fetch data from the table: "metis.liquidity_changes" */
  metis_liquidity_changes: Array<Metis_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "metis.liquidity_changes" */
  metis_liquidity_changes_aggregate: Metis_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "metis.liquidity_changes" using primary key columns */
  metis_liquidity_changes_by_pk?: Maybe<Metis_Liquidity_Changes>;
  /** fetch data from the table: "metis.liquidity_with_prices" */
  metis_liquidity_with_prices: Array<Metis_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "metis.liquidity_with_prices" */
  metis_liquidity_with_prices_aggregate: Metis_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "metis.liquidity_with_prices" using primary key columns */
  metis_liquidity_with_prices_by_pk?: Maybe<Metis_Liquidity_With_Prices>;
  /** fetch data from the table: "metis.loan_liquidations" */
  metis_loan_liquidations: Array<Metis_Loan_Liquidations>;
  /** fetch data from the table: "metis.loan_liquidations" using primary key columns */
  metis_loan_liquidations_by_pk?: Maybe<Metis_Loan_Liquidations>;
  /** fetch data from the table: "metis.pair_search" */
  metis_pair_search: Array<Metis_Pair_Search>;
  /** fetch aggregated fields from the table: "metis.pair_search" */
  metis_pair_search_aggregate: Metis_Pair_Search_Aggregate;
  /** fetch data from the table: "metis.pair_summary" */
  metis_pair_summary: Array<Metis_Pair_Summary>;
  /** fetch aggregated fields from the table: "metis.pair_summary" */
  metis_pair_summary_aggregate: Metis_Pair_Summary_Aggregate;
  /** fetch data from the table: "metis.pair_with_prices_tb" */
  metis_pair_with_prices_tb: Array<Metis_Pair_With_Prices_Tb>;
  /** fetch data from the table: "metis.pairs" */
  metis_pairs: Array<Metis_Pairs>;
  /** fetch data from the table: "metis.pairs" using primary key columns */
  metis_pairs_by_pk?: Maybe<Metis_Pairs>;
  /** fetch data from the table: "metis.pairs_tx_count" */
  metis_pairs_tx_count: Array<Metis_Pairs_Tx_Count>;
  /** fetch data from the table: "metis.pairs_tx_count" using primary key columns */
  metis_pairs_tx_count_by_pk?: Maybe<Metis_Pairs_Tx_Count>;
  /** fetch data from the table: "metis.protocols" */
  metis_protocols: Array<Metis_Protocols>;
  /** fetch data from the table: "metis.protocols" using primary key columns */
  metis_protocols_by_pk?: Maybe<Metis_Protocols>;
  /** fetch data from the table: "metis.swap_candles_cached" */
  metis_swap_candles_cached: Array<Metis_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "metis.swap_candles_cached" */
  metis_swap_candles_cached_aggregate: Metis_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "metis.swap_candles_cached" using primary key columns */
  metis_swap_candles_cached_by_pk?: Maybe<Metis_Swap_Candles_Cached>;
  /** fetch data from the table: "metis.swap_candles_tb" */
  metis_swap_candles_tb: Array<Metis_Swap_Candles_Tb>;
  /** fetch data from the table: "metis.tokens" */
  metis_tokens: Array<Metis_Tokens>;
  /** fetch data from the table: "metis.tokens" using primary key columns */
  metis_tokens_by_pk?: Maybe<Metis_Tokens>;
  /** fetch data from the table: "metis.tokenswaps_with_prices" */
  metis_tokenswaps_with_prices: Array<Metis_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "metis.tokenswaps_with_prices" */
  metis_tokenswaps_with_prices_aggregate: Metis_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "metis.tokenswaps_with_prices" using primary key columns */
  metis_tokenswaps_with_prices_by_pk?: Maybe<Metis_Tokenswaps_With_Prices>;
  /** fetch data from the table: "metis.usd_tokens" */
  metis_usd_tokens: Array<Metis_Usd_Tokens>;
  /** fetch data from the table: "metis.usd_tokens" using primary key columns */
  metis_usd_tokens_by_pk?: Maybe<Metis_Usd_Tokens>;
  /** fetch data from the table: "moonbeam.borrows" */
  moonbeam_borrows: Array<Moonbeam_Borrows>;
  /** fetch data from the table: "moonbeam.borrows" using primary key columns */
  moonbeam_borrows_by_pk?: Maybe<Moonbeam_Borrows>;
  /** execute function "moonbeam.get_lending_market_user_count" which returns "moonbeam.lending_market_user_count_tb" */
  moonbeam_get_lending_market_user_count: Array<Moonbeam_Lending_Market_User_Count_Tb>;
  /** execute function "moonbeam.get_pair_tx_count" which returns "moonbeam.pairs_tx_count" */
  moonbeam_get_pair_tx_count: Array<Moonbeam_Pairs_Tx_Count>;
  /** execute function "moonbeam.get_swap_candles" which returns "moonbeam.swap_candles_tb" */
  moonbeam_get_swap_candles: Array<Moonbeam_Swap_Candles_Tb>;
  /** fetch data from the table: "moonbeam.lending_market_daily_snapshots" */
  moonbeam_lending_market_daily_snapshots: Array<Moonbeam_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "moonbeam.lending_market_user_count_tb" */
  moonbeam_lending_market_user_count_tb: Array<Moonbeam_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "moonbeam.lending_supplies" */
  moonbeam_lending_supplies: Array<Moonbeam_Lending_Supplies>;
  /** fetch data from the table: "moonbeam.lending_supplies" using primary key columns */
  moonbeam_lending_supplies_by_pk?: Maybe<Moonbeam_Lending_Supplies>;
  /** fetch data from the table: "moonbeam.liquidity_changes" */
  moonbeam_liquidity_changes: Array<Moonbeam_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "moonbeam.liquidity_changes" */
  moonbeam_liquidity_changes_aggregate: Moonbeam_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "moonbeam.liquidity_changes" using primary key columns */
  moonbeam_liquidity_changes_by_pk?: Maybe<Moonbeam_Liquidity_Changes>;
  /** fetch data from the table: "moonbeam.liquidity_with_prices" */
  moonbeam_liquidity_with_prices: Array<Moonbeam_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "moonbeam.liquidity_with_prices" */
  moonbeam_liquidity_with_prices_aggregate: Moonbeam_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "moonbeam.liquidity_with_prices" using primary key columns */
  moonbeam_liquidity_with_prices_by_pk?: Maybe<Moonbeam_Liquidity_With_Prices>;
  /** fetch data from the table: "moonbeam.loan_liquidations" */
  moonbeam_loan_liquidations: Array<Moonbeam_Loan_Liquidations>;
  /** fetch data from the table: "moonbeam.loan_liquidations" using primary key columns */
  moonbeam_loan_liquidations_by_pk?: Maybe<Moonbeam_Loan_Liquidations>;
  /** fetch data from the table: "moonbeam.pair_search" */
  moonbeam_pair_search: Array<Moonbeam_Pair_Search>;
  /** fetch data from the table: "moonbeam.pair_summary" */
  moonbeam_pair_summary: Array<Moonbeam_Pair_Summary>;
  /** fetch data from the table: "moonbeam.pair_with_prices_tb" */
  moonbeam_pair_with_prices_tb: Array<Moonbeam_Pair_With_Prices_Tb>;
  /** fetch data from the table: "moonbeam.pairs" */
  moonbeam_pairs: Array<Moonbeam_Pairs>;
  /** fetch data from the table: "moonbeam.pairs" using primary key columns */
  moonbeam_pairs_by_pk?: Maybe<Moonbeam_Pairs>;
  /** fetch data from the table: "moonbeam.pairs_tx_count" */
  moonbeam_pairs_tx_count: Array<Moonbeam_Pairs_Tx_Count>;
  /** fetch data from the table: "moonbeam.pairs_tx_count" using primary key columns */
  moonbeam_pairs_tx_count_by_pk?: Maybe<Moonbeam_Pairs_Tx_Count>;
  /** fetch data from the table: "moonbeam.protocols" */
  moonbeam_protocols: Array<Moonbeam_Protocols>;
  /** fetch data from the table: "moonbeam.protocols" using primary key columns */
  moonbeam_protocols_by_pk?: Maybe<Moonbeam_Protocols>;
  /** fetch data from the table: "moonbeam.swap_candles_cached" */
  moonbeam_swap_candles_cached: Array<Moonbeam_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "moonbeam.swap_candles_cached" */
  moonbeam_swap_candles_cached_aggregate: Moonbeam_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "moonbeam.swap_candles_cached" using primary key columns */
  moonbeam_swap_candles_cached_by_pk?: Maybe<Moonbeam_Swap_Candles_Cached>;
  /** fetch data from the table: "moonbeam.swap_candles_tb" */
  moonbeam_swap_candles_tb: Array<Moonbeam_Swap_Candles_Tb>;
  /** fetch data from the table: "moonbeam.tokens" */
  moonbeam_tokens: Array<Moonbeam_Tokens>;
  /** fetch data from the table: "moonbeam.tokens" using primary key columns */
  moonbeam_tokens_by_pk?: Maybe<Moonbeam_Tokens>;
  /** fetch data from the table: "moonbeam.tokenswaps_with_prices" */
  moonbeam_tokenswaps_with_prices: Array<Moonbeam_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "moonbeam.tokenswaps_with_prices" */
  moonbeam_tokenswaps_with_prices_aggregate: Moonbeam_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "moonbeam.tokenswaps_with_prices" using primary key columns */
  moonbeam_tokenswaps_with_prices_by_pk?: Maybe<Moonbeam_Tokenswaps_With_Prices>;
  /** fetch data from the table: "moonriver.borrows" */
  moonriver_borrows: Array<Moonriver_Borrows>;
  /** fetch data from the table: "moonriver.borrows" using primary key columns */
  moonriver_borrows_by_pk?: Maybe<Moonriver_Borrows>;
  /** execute function "moonriver.get_lending_market_user_count" which returns "moonriver.lending_market_user_count_tb" */
  moonriver_get_lending_market_user_count: Array<Moonriver_Lending_Market_User_Count_Tb>;
  /** execute function "moonriver.get_pair_tx_count" which returns "moonriver.pairs_tx_count" */
  moonriver_get_pair_tx_count: Array<Moonriver_Pairs_Tx_Count>;
  /** execute function "moonriver.get_swap_candles" which returns "moonriver.swap_candles_tb" */
  moonriver_get_swap_candles: Array<Moonriver_Swap_Candles_Tb>;
  /** fetch data from the table: "moonriver.lending_market_daily_snapshots" */
  moonriver_lending_market_daily_snapshots: Array<Moonriver_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "moonriver.lending_market_user_count_tb" */
  moonriver_lending_market_user_count_tb: Array<Moonriver_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "moonriver.lending_supplies" */
  moonriver_lending_supplies: Array<Moonriver_Lending_Supplies>;
  /** fetch data from the table: "moonriver.lending_supplies" using primary key columns */
  moonriver_lending_supplies_by_pk?: Maybe<Moonriver_Lending_Supplies>;
  /** fetch data from the table: "moonriver.liquidity_changes" */
  moonriver_liquidity_changes: Array<Moonriver_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "moonriver.liquidity_changes" */
  moonriver_liquidity_changes_aggregate: Moonriver_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "moonriver.liquidity_changes" using primary key columns */
  moonriver_liquidity_changes_by_pk?: Maybe<Moonriver_Liquidity_Changes>;
  /** fetch data from the table: "moonriver.liquidity_with_prices" */
  moonriver_liquidity_with_prices: Array<Moonriver_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "moonriver.liquidity_with_prices" */
  moonriver_liquidity_with_prices_aggregate: Moonriver_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "moonriver.liquidity_with_prices" using primary key columns */
  moonriver_liquidity_with_prices_by_pk?: Maybe<Moonriver_Liquidity_With_Prices>;
  /** fetch data from the table: "moonriver.loan_liquidations" */
  moonriver_loan_liquidations: Array<Moonriver_Loan_Liquidations>;
  /** fetch data from the table: "moonriver.loan_liquidations" using primary key columns */
  moonriver_loan_liquidations_by_pk?: Maybe<Moonriver_Loan_Liquidations>;
  /** fetch data from the table: "moonriver.pair_search" */
  moonriver_pair_search: Array<Moonriver_Pair_Search>;
  /** fetch data from the table: "moonriver.pair_summary" */
  moonriver_pair_summary: Array<Moonriver_Pair_Summary>;
  /** fetch data from the table: "moonriver.pair_with_prices_tb" */
  moonriver_pair_with_prices_tb: Array<Moonriver_Pair_With_Prices_Tb>;
  /** fetch data from the table: "moonriver.pairs" */
  moonriver_pairs: Array<Moonriver_Pairs>;
  /** fetch data from the table: "moonriver.pairs" using primary key columns */
  moonriver_pairs_by_pk?: Maybe<Moonriver_Pairs>;
  /** fetch data from the table: "moonriver.pairs_tx_count" */
  moonriver_pairs_tx_count: Array<Moonriver_Pairs_Tx_Count>;
  /** fetch data from the table: "moonriver.pairs_tx_count" using primary key columns */
  moonriver_pairs_tx_count_by_pk?: Maybe<Moonriver_Pairs_Tx_Count>;
  /** fetch data from the table: "moonriver.protocols" */
  moonriver_protocols: Array<Moonriver_Protocols>;
  /** fetch data from the table: "moonriver.protocols" using primary key columns */
  moonriver_protocols_by_pk?: Maybe<Moonriver_Protocols>;
  /** fetch data from the table: "moonriver.swap_candles_cached" */
  moonriver_swap_candles_cached: Array<Moonriver_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "moonriver.swap_candles_cached" */
  moonriver_swap_candles_cached_aggregate: Moonriver_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "moonriver.swap_candles_cached" using primary key columns */
  moonriver_swap_candles_cached_by_pk?: Maybe<Moonriver_Swap_Candles_Cached>;
  /** fetch data from the table: "moonriver.swap_candles_tb" */
  moonriver_swap_candles_tb: Array<Moonriver_Swap_Candles_Tb>;
  /** fetch data from the table: "moonriver.tokens" */
  moonriver_tokens: Array<Moonriver_Tokens>;
  /** fetch data from the table: "moonriver.tokens" using primary key columns */
  moonriver_tokens_by_pk?: Maybe<Moonriver_Tokens>;
  /** fetch data from the table: "moonriver.tokenswaps_with_prices" */
  moonriver_tokenswaps_with_prices: Array<Moonriver_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "moonriver.tokenswaps_with_prices" */
  moonriver_tokenswaps_with_prices_aggregate: Moonriver_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "moonriver.tokenswaps_with_prices" using primary key columns */
  moonriver_tokenswaps_with_prices_by_pk?: Maybe<Moonriver_Tokenswaps_With_Prices>;
  /** fetch data from the table: "optimism.borrows" */
  optimism_borrows: Array<Optimism_Borrows>;
  /** fetch data from the table: "optimism.borrows" using primary key columns */
  optimism_borrows_by_pk?: Maybe<Optimism_Borrows>;
  /** execute function "optimism.get_lending_market_user_count" which returns "optimism.lending_market_user_count_tb" */
  optimism_get_lending_market_user_count: Array<Optimism_Lending_Market_User_Count_Tb>;
  /** execute function "optimism.get_pair_tx_count" which returns "optimism.pairs_tx_count" */
  optimism_get_pair_tx_count: Array<Optimism_Pairs_Tx_Count>;
  /** execute function "optimism.get_swap_candles" which returns "optimism.swap_candles_tb" */
  optimism_get_swap_candles: Array<Optimism_Swap_Candles_Tb>;
  /** fetch data from the table: "optimism.lending_market_daily_snapshots" */
  optimism_lending_market_daily_snapshots: Array<Optimism_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "optimism.lending_market_user_count_tb" */
  optimism_lending_market_user_count_tb: Array<Optimism_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "optimism.lending_supplies" */
  optimism_lending_supplies: Array<Optimism_Lending_Supplies>;
  /** fetch data from the table: "optimism.lending_supplies" using primary key columns */
  optimism_lending_supplies_by_pk?: Maybe<Optimism_Lending_Supplies>;
  /** fetch data from the table: "optimism.liquidity_changes" */
  optimism_liquidity_changes: Array<Optimism_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "optimism.liquidity_changes" */
  optimism_liquidity_changes_aggregate: Optimism_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "optimism.liquidity_changes" using primary key columns */
  optimism_liquidity_changes_by_pk?: Maybe<Optimism_Liquidity_Changes>;
  /** fetch data from the table: "optimism.liquidity_with_prices" */
  optimism_liquidity_with_prices: Array<Optimism_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "optimism.liquidity_with_prices" */
  optimism_liquidity_with_prices_aggregate: Optimism_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "optimism.liquidity_with_prices" using primary key columns */
  optimism_liquidity_with_prices_by_pk?: Maybe<Optimism_Liquidity_With_Prices>;
  /** fetch data from the table: "optimism.loan_liquidations" */
  optimism_loan_liquidations: Array<Optimism_Loan_Liquidations>;
  /** fetch data from the table: "optimism.loan_liquidations" using primary key columns */
  optimism_loan_liquidations_by_pk?: Maybe<Optimism_Loan_Liquidations>;
  /** fetch data from the table: "optimism.pair_search" */
  optimism_pair_search: Array<Optimism_Pair_Search>;
  /** fetch aggregated fields from the table: "optimism.pair_search" */
  optimism_pair_search_aggregate: Optimism_Pair_Search_Aggregate;
  /** fetch data from the table: "optimism.pair_summary" */
  optimism_pair_summary: Array<Optimism_Pair_Summary>;
  /** fetch aggregated fields from the table: "optimism.pair_summary" */
  optimism_pair_summary_aggregate: Optimism_Pair_Summary_Aggregate;
  /** fetch data from the table: "optimism.pair_with_prices_tb" */
  optimism_pair_with_prices_tb: Array<Optimism_Pair_With_Prices_Tb>;
  /** fetch data from the table: "optimism.pairs" */
  optimism_pairs: Array<Optimism_Pairs>;
  /** fetch data from the table: "optimism.pairs" using primary key columns */
  optimism_pairs_by_pk?: Maybe<Optimism_Pairs>;
  /** fetch data from the table: "optimism.pairs_tx_count" */
  optimism_pairs_tx_count: Array<Optimism_Pairs_Tx_Count>;
  /** fetch data from the table: "optimism.pairs_tx_count" using primary key columns */
  optimism_pairs_tx_count_by_pk?: Maybe<Optimism_Pairs_Tx_Count>;
  /** fetch data from the table: "optimism.protocols" */
  optimism_protocols: Array<Optimism_Protocols>;
  /** fetch data from the table: "optimism.protocols" using primary key columns */
  optimism_protocols_by_pk?: Maybe<Optimism_Protocols>;
  /** fetch data from the table: "optimism.swap_candles_cached" */
  optimism_swap_candles_cached: Array<Optimism_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "optimism.swap_candles_cached" */
  optimism_swap_candles_cached_aggregate: Optimism_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "optimism.swap_candles_cached" using primary key columns */
  optimism_swap_candles_cached_by_pk?: Maybe<Optimism_Swap_Candles_Cached>;
  /** fetch data from the table: "optimism.swap_candles_tb" */
  optimism_swap_candles_tb: Array<Optimism_Swap_Candles_Tb>;
  /** fetch data from the table: "optimism.tokens" */
  optimism_tokens: Array<Optimism_Tokens>;
  /** fetch data from the table: "optimism.tokens" using primary key columns */
  optimism_tokens_by_pk?: Maybe<Optimism_Tokens>;
  /** fetch data from the table: "optimism.tokenswaps_with_prices" */
  optimism_tokenswaps_with_prices: Array<Optimism_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "optimism.tokenswaps_with_prices" */
  optimism_tokenswaps_with_prices_aggregate: Optimism_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "optimism.tokenswaps_with_prices" using primary key columns */
  optimism_tokenswaps_with_prices_by_pk?: Maybe<Optimism_Tokenswaps_With_Prices>;
  /** fetch data from the table: "optimism.usd_tokens" */
  optimism_usd_tokens: Array<Optimism_Usd_Tokens>;
  /** fetch data from the table: "optimism.usd_tokens" using primary key columns */
  optimism_usd_tokens_by_pk?: Maybe<Optimism_Usd_Tokens>;
  /** fetch data from the table: "polygon.borrows" */
  polygon_borrows: Array<Polygon_Borrows>;
  /** fetch data from the table: "polygon.borrows" using primary key columns */
  polygon_borrows_by_pk?: Maybe<Polygon_Borrows>;
  /** execute function "polygon.get_lending_market_user_count" which returns "polygon.lending_market_user_count_tb" */
  polygon_get_lending_market_user_count: Array<Polygon_Lending_Market_User_Count_Tb>;
  /** execute function "polygon.get_pair_tx_count" which returns "polygon.pairs_tx_count" */
  polygon_get_pair_tx_count: Array<Polygon_Pairs_Tx_Count>;
  /** execute function "polygon.get_swap_candles" which returns "polygon.swap_candles_tb" */
  polygon_get_swap_candles: Array<Polygon_Swap_Candles_Tb>;
  /** fetch data from the table: "polygon.lending_market_daily_snapshots" */
  polygon_lending_market_daily_snapshots: Array<Polygon_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "polygon.lending_market_user_count_tb" */
  polygon_lending_market_user_count_tb: Array<Polygon_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "polygon.lending_supplies" */
  polygon_lending_supplies: Array<Polygon_Lending_Supplies>;
  /** fetch data from the table: "polygon.lending_supplies" using primary key columns */
  polygon_lending_supplies_by_pk?: Maybe<Polygon_Lending_Supplies>;
  /** fetch data from the table: "polygon.liquidity_changes" */
  polygon_liquidity_changes: Array<Polygon_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "polygon.liquidity_changes" */
  polygon_liquidity_changes_aggregate: Polygon_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "polygon.liquidity_changes" using primary key columns */
  polygon_liquidity_changes_by_pk?: Maybe<Polygon_Liquidity_Changes>;
  /** fetch data from the table: "polygon.liquidity_with_prices" */
  polygon_liquidity_with_prices: Array<Polygon_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "polygon.liquidity_with_prices" */
  polygon_liquidity_with_prices_aggregate: Polygon_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "polygon.liquidity_with_prices" using primary key columns */
  polygon_liquidity_with_prices_by_pk?: Maybe<Polygon_Liquidity_With_Prices>;
  /** fetch data from the table: "polygon.loan_liquidations" */
  polygon_loan_liquidations: Array<Polygon_Loan_Liquidations>;
  /** fetch data from the table: "polygon.loan_liquidations" using primary key columns */
  polygon_loan_liquidations_by_pk?: Maybe<Polygon_Loan_Liquidations>;
  /** fetch data from the table: "polygon.pair_search" */
  polygon_pair_search: Array<Polygon_Pair_Search>;
  /** fetch aggregated fields from the table: "polygon.pair_search" */
  polygon_pair_search_aggregate: Polygon_Pair_Search_Aggregate;
  /** fetch data from the table: "polygon.pair_summary" */
  polygon_pair_summary: Array<Polygon_Pair_Summary>;
  /** fetch aggregated fields from the table: "polygon.pair_summary" */
  polygon_pair_summary_aggregate: Polygon_Pair_Summary_Aggregate;
  /** fetch data from the table: "polygon.pair_with_prices_tb" */
  polygon_pair_with_prices_tb: Array<Polygon_Pair_With_Prices_Tb>;
  /** fetch data from the table: "polygon.pairs" */
  polygon_pairs: Array<Polygon_Pairs>;
  /** fetch data from the table: "polygon.pairs" using primary key columns */
  polygon_pairs_by_pk?: Maybe<Polygon_Pairs>;
  /** fetch data from the table: "polygon.pairs_tx_count" */
  polygon_pairs_tx_count: Array<Polygon_Pairs_Tx_Count>;
  /** fetch data from the table: "polygon.pairs_tx_count" using primary key columns */
  polygon_pairs_tx_count_by_pk?: Maybe<Polygon_Pairs_Tx_Count>;
  /** fetch data from the table: "polygon.protocols" */
  polygon_protocols: Array<Polygon_Protocols>;
  /** fetch data from the table: "polygon.protocols" using primary key columns */
  polygon_protocols_by_pk?: Maybe<Polygon_Protocols>;
  /** fetch data from the table: "polygon.swap_candles_cached" */
  polygon_swap_candles_cached: Array<Polygon_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "polygon.swap_candles_cached" */
  polygon_swap_candles_cached_aggregate: Polygon_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "polygon.swap_candles_cached" using primary key columns */
  polygon_swap_candles_cached_by_pk?: Maybe<Polygon_Swap_Candles_Cached>;
  /** fetch data from the table: "polygon.swap_candles_tb" */
  polygon_swap_candles_tb: Array<Polygon_Swap_Candles_Tb>;
  /** fetch data from the table: "polygon.tokens" */
  polygon_tokens: Array<Polygon_Tokens>;
  /** fetch data from the table: "polygon.tokens" using primary key columns */
  polygon_tokens_by_pk?: Maybe<Polygon_Tokens>;
  /** fetch data from the table: "polygon.tokenswaps_with_prices" */
  polygon_tokenswaps_with_prices: Array<Polygon_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "polygon.tokenswaps_with_prices" */
  polygon_tokenswaps_with_prices_aggregate: Polygon_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "polygon.tokenswaps_with_prices" using primary key columns */
  polygon_tokenswaps_with_prices_by_pk?: Maybe<Polygon_Tokenswaps_With_Prices>;
  /** fetch data from the table: "polygon.usd_tokens" */
  polygon_usd_tokens: Array<Polygon_Usd_Tokens>;
  /** fetch data from the table: "polygon.usd_tokens" using primary key columns */
  polygon_usd_tokens_by_pk?: Maybe<Polygon_Usd_Tokens>;
};


export type Query_RootArbitrum_BorrowsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Borrows_Order_By>>;
  where?: Maybe<Arbitrum_Borrows_Bool_Exp>;
};


export type Query_RootArbitrum_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Get_Lending_Market_User_CountArgs = {
  args: Arbitrum_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootArbitrum_Get_Pair_Tx_CountArgs = {
  args: Arbitrum_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootArbitrum_Get_Swap_CandlesArgs = {
  args: Arbitrum_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootArbitrum_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootArbitrum_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootArbitrum_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Supplies_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Supplies_Bool_Exp>;
};


export type Query_RootArbitrum_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootArbitrum_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootArbitrum_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootArbitrum_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootArbitrum_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Loan_Liquidations_Order_By>>;
  where?: Maybe<Arbitrum_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootArbitrum_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Search_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Search_Bool_Exp>;
};


export type Query_RootArbitrum_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Search_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Search_Bool_Exp>;
};


export type Query_RootArbitrum_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Summary_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Summary_Bool_Exp>;
};


export type Query_RootArbitrum_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Summary_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Summary_Bool_Exp>;
};


export type Query_RootArbitrum_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootArbitrum_PairsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Bool_Exp>;
};


export type Query_RootArbitrum_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootArbitrum_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootArbitrum_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootArbitrum_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Protocols_Order_By>>;
  where?: Maybe<Arbitrum_Protocols_Bool_Exp>;
};


export type Query_RootArbitrum_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootArbitrum_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootArbitrum_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootArbitrum_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootArbitrum_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootArbitrum_TokensArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokens_Order_By>>;
  where?: Maybe<Arbitrum_Tokens_Bool_Exp>;
};


export type Query_RootArbitrum_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootArbitrum_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootArbitrum_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootArbitrum_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootArbitrum_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Usd_Tokens_Order_By>>;
  where?: Maybe<Arbitrum_Usd_Tokens_Bool_Exp>;
};


export type Query_RootArbitrum_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootAvalanche_BorrowsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Borrows_Order_By>>;
  where?: Maybe<Avalanche_Borrows_Bool_Exp>;
};


export type Query_RootAvalanche_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Get_Lending_Market_User_CountArgs = {
  args: Avalanche_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootAvalanche_Get_Pair_Tx_CountArgs = {
  args: Avalanche_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Avalanche_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootAvalanche_Get_Swap_CandlesArgs = {
  args: Avalanche_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootAvalanche_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootAvalanche_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootAvalanche_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Supplies_Order_By>>;
  where?: Maybe<Avalanche_Lending_Supplies_Bool_Exp>;
};


export type Query_RootAvalanche_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_Changes_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootAvalanche_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_Changes_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootAvalanche_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootAvalanche_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootAvalanche_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Loan_Liquidations_Order_By>>;
  where?: Maybe<Avalanche_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootAvalanche_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Search_Order_By>>;
  where?: Maybe<Avalanche_Pair_Search_Bool_Exp>;
};


export type Query_RootAvalanche_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Search_Order_By>>;
  where?: Maybe<Avalanche_Pair_Search_Bool_Exp>;
};


export type Query_RootAvalanche_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Summary_Order_By>>;
  where?: Maybe<Avalanche_Pair_Summary_Bool_Exp>;
};


export type Query_RootAvalanche_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Summary_Order_By>>;
  where?: Maybe<Avalanche_Pair_Summary_Bool_Exp>;
};


export type Query_RootAvalanche_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Avalanche_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootAvalanche_PairsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Bool_Exp>;
};


export type Query_RootAvalanche_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootAvalanche_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootAvalanche_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootAvalanche_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Protocols_Order_By>>;
  where?: Maybe<Avalanche_Protocols_Bool_Exp>;
};


export type Query_RootAvalanche_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootAvalanche_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootAvalanche_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootAvalanche_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootAvalanche_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootAvalanche_TokensArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokens_Order_By>>;
  where?: Maybe<Avalanche_Tokens_Bool_Exp>;
};


export type Query_RootAvalanche_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootAvalanche_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootAvalanche_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootAvalanche_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootAvalanche_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Avalanche_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Usd_Tokens_Order_By>>;
  where?: Maybe<Avalanche_Usd_Tokens_Bool_Exp>;
};


export type Query_RootAvalanche_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootBsc_BorrowsArgs = {
  distinct_on?: Maybe<Array<Bsc_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Borrows_Order_By>>;
  where?: Maybe<Bsc_Borrows_Bool_Exp>;
};


export type Query_RootBsc_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootBsc_Get_Lending_Market_User_CountArgs = {
  args: Bsc_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootBsc_Get_Pair_Tx_CountArgs = {
  args: Bsc_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Bsc_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Bsc_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootBsc_Get_Swap_CandlesArgs = {
  args: Bsc_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootBsc_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootBsc_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootBsc_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Supplies_Order_By>>;
  where?: Maybe<Bsc_Lending_Supplies_Bool_Exp>;
};


export type Query_RootBsc_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootBsc_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_Changes_Order_By>>;
  where?: Maybe<Bsc_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootBsc_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_Changes_Order_By>>;
  where?: Maybe<Bsc_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootBsc_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootBsc_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootBsc_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootBsc_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootBsc_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Bsc_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Loan_Liquidations_Order_By>>;
  where?: Maybe<Bsc_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootBsc_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootBsc_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_Search_Order_By>>;
  where?: Maybe<Bsc_Pair_Search_Bool_Exp>;
};


export type Query_RootBsc_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_Summary_Order_By>>;
  where?: Maybe<Bsc_Pair_Summary_Bool_Exp>;
};


export type Query_RootBsc_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Bsc_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootBsc_PairsArgs = {
  distinct_on?: Maybe<Array<Bsc_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Order_By>>;
  where?: Maybe<Bsc_Pairs_Bool_Exp>;
};


export type Query_RootBsc_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootBsc_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Bsc_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Bsc_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootBsc_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootBsc_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Bsc_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Protocols_Order_By>>;
  where?: Maybe<Bsc_Protocols_Bool_Exp>;
};


export type Query_RootBsc_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootBsc_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootBsc_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootBsc_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootBsc_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootBsc_TokensArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokens_Order_By>>;
  where?: Maybe<Bsc_Tokens_Bool_Exp>;
};


export type Query_RootBsc_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootBsc_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootBsc_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootBsc_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_BorrowsArgs = {
  distinct_on?: Maybe<Array<Dfk_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Borrows_Order_By>>;
  where?: Maybe<Dfk_Borrows_Bool_Exp>;
};


export type Query_RootDfk_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Get_Lending_Market_User_CountArgs = {
  args: Dfk_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootDfk_Get_Pair_Tx_CountArgs = {
  args: Dfk_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Dfk_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Dfk_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootDfk_Get_Swap_CandlesArgs = {
  args: Dfk_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootDfk_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootDfk_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootDfk_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Supplies_Order_By>>;
  where?: Maybe<Dfk_Lending_Supplies_Bool_Exp>;
};


export type Query_RootDfk_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_Changes_Order_By>>;
  where?: Maybe<Dfk_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootDfk_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_Changes_Order_By>>;
  where?: Maybe<Dfk_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootDfk_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootDfk_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootDfk_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Dfk_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Loan_Liquidations_Order_By>>;
  where?: Maybe<Dfk_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootDfk_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Search_Order_By>>;
  where?: Maybe<Dfk_Pair_Search_Bool_Exp>;
};


export type Query_RootDfk_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Search_Order_By>>;
  where?: Maybe<Dfk_Pair_Search_Bool_Exp>;
};


export type Query_RootDfk_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Summary_Order_By>>;
  where?: Maybe<Dfk_Pair_Summary_Bool_Exp>;
};


export type Query_RootDfk_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Summary_Order_By>>;
  where?: Maybe<Dfk_Pair_Summary_Bool_Exp>;
};


export type Query_RootDfk_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Dfk_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootDfk_PairsArgs = {
  distinct_on?: Maybe<Array<Dfk_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Order_By>>;
  where?: Maybe<Dfk_Pairs_Bool_Exp>;
};


export type Query_RootDfk_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootDfk_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Dfk_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Dfk_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootDfk_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootDfk_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Dfk_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Protocols_Order_By>>;
  where?: Maybe<Dfk_Protocols_Bool_Exp>;
};


export type Query_RootDfk_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootDfk_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootDfk_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootDfk_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootDfk_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootDfk_TokensArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokens_Order_By>>;
  where?: Maybe<Dfk_Tokens_Bool_Exp>;
};


export type Query_RootDfk_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootDfk_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootDfk_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootDfk_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootDfk_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Dfk_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Usd_Tokens_Order_By>>;
  where?: Maybe<Dfk_Usd_Tokens_Bool_Exp>;
};


export type Query_RootDfk_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootEthereum_BorrowsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Borrows_Order_By>>;
  where?: Maybe<Ethereum_Borrows_Bool_Exp>;
};


export type Query_RootEthereum_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Get_Lending_Market_User_CountArgs = {
  args: Ethereum_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootEthereum_Get_Pair_Tx_CountArgs = {
  args: Ethereum_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Ethereum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootEthereum_Get_Swap_CandlesArgs = {
  args: Ethereum_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootEthereum_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootEthereum_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootEthereum_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Supplies_Order_By>>;
  where?: Maybe<Ethereum_Lending_Supplies_Bool_Exp>;
};


export type Query_RootEthereum_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootEthereum_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootEthereum_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootEthereum_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootEthereum_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Loan_Liquidations_Order_By>>;
  where?: Maybe<Ethereum_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootEthereum_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Search_Order_By>>;
  where?: Maybe<Ethereum_Pair_Search_Bool_Exp>;
};


export type Query_RootEthereum_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Search_Order_By>>;
  where?: Maybe<Ethereum_Pair_Search_Bool_Exp>;
};


export type Query_RootEthereum_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Summary_Order_By>>;
  where?: Maybe<Ethereum_Pair_Summary_Bool_Exp>;
};


export type Query_RootEthereum_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Summary_Order_By>>;
  where?: Maybe<Ethereum_Pair_Summary_Bool_Exp>;
};


export type Query_RootEthereum_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Ethereum_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootEthereum_PairsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Bool_Exp>;
};


export type Query_RootEthereum_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootEthereum_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootEthereum_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootEthereum_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Protocols_Order_By>>;
  where?: Maybe<Ethereum_Protocols_Bool_Exp>;
};


export type Query_RootEthereum_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootEthereum_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootEthereum_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootEthereum_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootEthereum_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootEthereum_TokensArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokens_Order_By>>;
  where?: Maybe<Ethereum_Tokens_Bool_Exp>;
};


export type Query_RootEthereum_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootEthereum_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootEthereum_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootEthereum_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootEthereum_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Ethereum_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Usd_Tokens_Order_By>>;
  where?: Maybe<Ethereum_Usd_Tokens_Bool_Exp>;
};


export type Query_RootEthereum_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootMetis_BorrowsArgs = {
  distinct_on?: Maybe<Array<Metis_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Borrows_Order_By>>;
  where?: Maybe<Metis_Borrows_Bool_Exp>;
};


export type Query_RootMetis_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Get_Lending_Market_User_CountArgs = {
  args: Metis_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Metis_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMetis_Get_Pair_Tx_CountArgs = {
  args: Metis_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Metis_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Metis_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMetis_Get_Swap_CandlesArgs = {
  args: Metis_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMetis_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Metis_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootMetis_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Metis_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMetis_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Supplies_Order_By>>;
  where?: Maybe<Metis_Lending_Supplies_Bool_Exp>;
};


export type Query_RootMetis_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_Changes_Order_By>>;
  where?: Maybe<Metis_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMetis_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_Changes_Order_By>>;
  where?: Maybe<Metis_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMetis_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Metis_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMetis_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Metis_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMetis_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Metis_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Loan_Liquidations_Order_By>>;
  where?: Maybe<Metis_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootMetis_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Search_Order_By>>;
  where?: Maybe<Metis_Pair_Search_Bool_Exp>;
};


export type Query_RootMetis_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Search_Order_By>>;
  where?: Maybe<Metis_Pair_Search_Bool_Exp>;
};


export type Query_RootMetis_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Summary_Order_By>>;
  where?: Maybe<Metis_Pair_Summary_Bool_Exp>;
};


export type Query_RootMetis_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Summary_Order_By>>;
  where?: Maybe<Metis_Pair_Summary_Bool_Exp>;
};


export type Query_RootMetis_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Metis_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootMetis_PairsArgs = {
  distinct_on?: Maybe<Array<Metis_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Order_By>>;
  where?: Maybe<Metis_Pairs_Bool_Exp>;
};


export type Query_RootMetis_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootMetis_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Metis_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Metis_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMetis_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootMetis_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Metis_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Protocols_Order_By>>;
  where?: Maybe<Metis_Protocols_Bool_Exp>;
};


export type Query_RootMetis_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootMetis_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMetis_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMetis_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootMetis_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMetis_TokensArgs = {
  distinct_on?: Maybe<Array<Metis_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokens_Order_By>>;
  where?: Maybe<Metis_Tokens_Bool_Exp>;
};


export type Query_RootMetis_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootMetis_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Metis_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Metis_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMetis_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Metis_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMetis_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootMetis_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Metis_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Usd_Tokens_Order_By>>;
  where?: Maybe<Metis_Usd_Tokens_Bool_Exp>;
};


export type Query_RootMetis_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootMoonbeam_BorrowsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Borrows_Order_By>>;
  where?: Maybe<Moonbeam_Borrows_Bool_Exp>;
};


export type Query_RootMoonbeam_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonbeam_Get_Lending_Market_User_CountArgs = {
  args: Moonbeam_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMoonbeam_Get_Pair_Tx_CountArgs = {
  args: Moonbeam_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMoonbeam_Get_Swap_CandlesArgs = {
  args: Moonbeam_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMoonbeam_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootMoonbeam_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMoonbeam_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Supplies_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Supplies_Bool_Exp>;
};


export type Query_RootMoonbeam_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonbeam_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMoonbeam_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMoonbeam_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonbeam_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMoonbeam_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMoonbeam_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonbeam_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Loan_Liquidations_Order_By>>;
  where?: Maybe<Moonbeam_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootMoonbeam_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonbeam_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_Search_Order_By>>;
  where?: Maybe<Moonbeam_Pair_Search_Bool_Exp>;
};


export type Query_RootMoonbeam_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_Summary_Order_By>>;
  where?: Maybe<Moonbeam_Pair_Summary_Bool_Exp>;
};


export type Query_RootMoonbeam_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootMoonbeam_PairsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Bool_Exp>;
};


export type Query_RootMoonbeam_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootMoonbeam_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMoonbeam_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootMoonbeam_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Protocols_Order_By>>;
  where?: Maybe<Moonbeam_Protocols_Bool_Exp>;
};


export type Query_RootMoonbeam_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootMoonbeam_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMoonbeam_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMoonbeam_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootMoonbeam_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMoonbeam_TokensArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokens_Order_By>>;
  where?: Maybe<Moonbeam_Tokens_Bool_Exp>;
};


export type Query_RootMoonbeam_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootMoonbeam_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMoonbeam_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMoonbeam_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_BorrowsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Borrows_Order_By>>;
  where?: Maybe<Moonriver_Borrows_Bool_Exp>;
};


export type Query_RootMoonriver_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_Get_Lending_Market_User_CountArgs = {
  args: Moonriver_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMoonriver_Get_Pair_Tx_CountArgs = {
  args: Moonriver_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Moonriver_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMoonriver_Get_Swap_CandlesArgs = {
  args: Moonriver_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMoonriver_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootMoonriver_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootMoonriver_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Supplies_Order_By>>;
  where?: Maybe<Moonriver_Lending_Supplies_Bool_Exp>;
};


export type Query_RootMoonriver_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMoonriver_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootMoonriver_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMoonriver_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootMoonriver_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Loan_Liquidations_Order_By>>;
  where?: Maybe<Moonriver_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootMoonriver_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootMoonriver_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_Search_Order_By>>;
  where?: Maybe<Moonriver_Pair_Search_Bool_Exp>;
};


export type Query_RootMoonriver_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_Summary_Order_By>>;
  where?: Maybe<Moonriver_Pair_Summary_Bool_Exp>;
};


export type Query_RootMoonriver_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Moonriver_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootMoonriver_PairsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Bool_Exp>;
};


export type Query_RootMoonriver_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootMoonriver_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootMoonriver_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootMoonriver_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Protocols_Order_By>>;
  where?: Maybe<Moonriver_Protocols_Bool_Exp>;
};


export type Query_RootMoonriver_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootMoonriver_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMoonriver_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootMoonriver_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootMoonriver_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootMoonriver_TokensArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokens_Order_By>>;
  where?: Maybe<Moonriver_Tokens_Bool_Exp>;
};


export type Query_RootMoonriver_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootMoonriver_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMoonriver_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootMoonriver_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_BorrowsArgs = {
  distinct_on?: Maybe<Array<Optimism_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Borrows_Order_By>>;
  where?: Maybe<Optimism_Borrows_Bool_Exp>;
};


export type Query_RootOptimism_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Get_Lending_Market_User_CountArgs = {
  args: Optimism_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootOptimism_Get_Pair_Tx_CountArgs = {
  args: Optimism_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Optimism_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Optimism_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootOptimism_Get_Swap_CandlesArgs = {
  args: Optimism_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootOptimism_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootOptimism_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootOptimism_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Supplies_Order_By>>;
  where?: Maybe<Optimism_Lending_Supplies_Bool_Exp>;
};


export type Query_RootOptimism_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_Changes_Order_By>>;
  where?: Maybe<Optimism_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootOptimism_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_Changes_Order_By>>;
  where?: Maybe<Optimism_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootOptimism_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootOptimism_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootOptimism_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Optimism_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Loan_Liquidations_Order_By>>;
  where?: Maybe<Optimism_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootOptimism_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Search_Order_By>>;
  where?: Maybe<Optimism_Pair_Search_Bool_Exp>;
};


export type Query_RootOptimism_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Search_Order_By>>;
  where?: Maybe<Optimism_Pair_Search_Bool_Exp>;
};


export type Query_RootOptimism_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Summary_Order_By>>;
  where?: Maybe<Optimism_Pair_Summary_Bool_Exp>;
};


export type Query_RootOptimism_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Summary_Order_By>>;
  where?: Maybe<Optimism_Pair_Summary_Bool_Exp>;
};


export type Query_RootOptimism_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Optimism_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootOptimism_PairsArgs = {
  distinct_on?: Maybe<Array<Optimism_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Order_By>>;
  where?: Maybe<Optimism_Pairs_Bool_Exp>;
};


export type Query_RootOptimism_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootOptimism_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Optimism_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Optimism_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootOptimism_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootOptimism_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Optimism_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Protocols_Order_By>>;
  where?: Maybe<Optimism_Protocols_Bool_Exp>;
};


export type Query_RootOptimism_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootOptimism_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootOptimism_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootOptimism_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootOptimism_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootOptimism_TokensArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokens_Order_By>>;
  where?: Maybe<Optimism_Tokens_Bool_Exp>;
};


export type Query_RootOptimism_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootOptimism_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootOptimism_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootOptimism_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootOptimism_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Optimism_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Usd_Tokens_Order_By>>;
  where?: Maybe<Optimism_Usd_Tokens_Bool_Exp>;
};


export type Query_RootOptimism_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Query_RootPolygon_BorrowsArgs = {
  distinct_on?: Maybe<Array<Polygon_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Borrows_Order_By>>;
  where?: Maybe<Polygon_Borrows_Bool_Exp>;
};


export type Query_RootPolygon_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Get_Lending_Market_User_CountArgs = {
  args: Polygon_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootPolygon_Get_Pair_Tx_CountArgs = {
  args: Polygon_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Polygon_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Polygon_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootPolygon_Get_Swap_CandlesArgs = {
  args: Polygon_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootPolygon_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Query_RootPolygon_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Query_RootPolygon_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Supplies_Order_By>>;
  where?: Maybe<Polygon_Lending_Supplies_Bool_Exp>;
};


export type Query_RootPolygon_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_Changes_Order_By>>;
  where?: Maybe<Polygon_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootPolygon_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_Changes_Order_By>>;
  where?: Maybe<Polygon_Liquidity_Changes_Bool_Exp>;
};


export type Query_RootPolygon_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootPolygon_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Liquidity_With_Prices_Bool_Exp>;
};


export type Query_RootPolygon_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Polygon_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Loan_Liquidations_Order_By>>;
  where?: Maybe<Polygon_Loan_Liquidations_Bool_Exp>;
};


export type Query_RootPolygon_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Search_Order_By>>;
  where?: Maybe<Polygon_Pair_Search_Bool_Exp>;
};


export type Query_RootPolygon_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Search_Order_By>>;
  where?: Maybe<Polygon_Pair_Search_Bool_Exp>;
};


export type Query_RootPolygon_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Summary_Order_By>>;
  where?: Maybe<Polygon_Pair_Summary_Bool_Exp>;
};


export type Query_RootPolygon_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Summary_Order_By>>;
  where?: Maybe<Polygon_Pair_Summary_Bool_Exp>;
};


export type Query_RootPolygon_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Polygon_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Query_RootPolygon_PairsArgs = {
  distinct_on?: Maybe<Array<Polygon_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Order_By>>;
  where?: Maybe<Polygon_Pairs_Bool_Exp>;
};


export type Query_RootPolygon_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Query_RootPolygon_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Polygon_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Polygon_Pairs_Tx_Count_Bool_Exp>;
};


export type Query_RootPolygon_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Query_RootPolygon_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Polygon_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Protocols_Order_By>>;
  where?: Maybe<Polygon_Protocols_Bool_Exp>;
};


export type Query_RootPolygon_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Query_RootPolygon_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootPolygon_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Cached_Bool_Exp>;
};


export type Query_RootPolygon_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Query_RootPolygon_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Tb_Bool_Exp>;
};


export type Query_RootPolygon_TokensArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokens_Order_By>>;
  where?: Maybe<Polygon_Tokens_Bool_Exp>;
};


export type Query_RootPolygon_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Query_RootPolygon_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootPolygon_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Query_RootPolygon_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Query_RootPolygon_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Polygon_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Usd_Tokens_Order_By>>;
  where?: Maybe<Polygon_Usd_Tokens_Bool_Exp>;
};


export type Query_RootPolygon_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "arbitrum.borrows" */
  arbitrum_borrows: Array<Arbitrum_Borrows>;
  /** fetch data from the table: "arbitrum.borrows" using primary key columns */
  arbitrum_borrows_by_pk?: Maybe<Arbitrum_Borrows>;
  /** execute function "arbitrum.get_lending_market_user_count" which returns "arbitrum.lending_market_user_count_tb" */
  arbitrum_get_lending_market_user_count: Array<Arbitrum_Lending_Market_User_Count_Tb>;
  /** execute function "arbitrum.get_pair_tx_count" which returns "arbitrum.pairs_tx_count" */
  arbitrum_get_pair_tx_count: Array<Arbitrum_Pairs_Tx_Count>;
  /** execute function "arbitrum.get_swap_candles" which returns "arbitrum.swap_candles_tb" */
  arbitrum_get_swap_candles: Array<Arbitrum_Swap_Candles_Tb>;
  /** fetch data from the table: "arbitrum.lending_market_daily_snapshots" */
  arbitrum_lending_market_daily_snapshots: Array<Arbitrum_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "arbitrum.lending_market_user_count_tb" */
  arbitrum_lending_market_user_count_tb: Array<Arbitrum_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "arbitrum.lending_supplies" */
  arbitrum_lending_supplies: Array<Arbitrum_Lending_Supplies>;
  /** fetch data from the table: "arbitrum.lending_supplies" using primary key columns */
  arbitrum_lending_supplies_by_pk?: Maybe<Arbitrum_Lending_Supplies>;
  /** fetch data from the table: "arbitrum.liquidity_changes" */
  arbitrum_liquidity_changes: Array<Arbitrum_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "arbitrum.liquidity_changes" */
  arbitrum_liquidity_changes_aggregate: Arbitrum_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "arbitrum.liquidity_changes" using primary key columns */
  arbitrum_liquidity_changes_by_pk?: Maybe<Arbitrum_Liquidity_Changes>;
  /** fetch data from the table: "arbitrum.liquidity_with_prices" */
  arbitrum_liquidity_with_prices: Array<Arbitrum_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "arbitrum.liquidity_with_prices" */
  arbitrum_liquidity_with_prices_aggregate: Arbitrum_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "arbitrum.liquidity_with_prices" using primary key columns */
  arbitrum_liquidity_with_prices_by_pk?: Maybe<Arbitrum_Liquidity_With_Prices>;
  /** fetch data from the table: "arbitrum.loan_liquidations" */
  arbitrum_loan_liquidations: Array<Arbitrum_Loan_Liquidations>;
  /** fetch data from the table: "arbitrum.loan_liquidations" using primary key columns */
  arbitrum_loan_liquidations_by_pk?: Maybe<Arbitrum_Loan_Liquidations>;
  /** fetch data from the table: "arbitrum.pair_search" */
  arbitrum_pair_search: Array<Arbitrum_Pair_Search>;
  /** fetch aggregated fields from the table: "arbitrum.pair_search" */
  arbitrum_pair_search_aggregate: Arbitrum_Pair_Search_Aggregate;
  /** fetch data from the table: "arbitrum.pair_summary" */
  arbitrum_pair_summary: Array<Arbitrum_Pair_Summary>;
  /** fetch aggregated fields from the table: "arbitrum.pair_summary" */
  arbitrum_pair_summary_aggregate: Arbitrum_Pair_Summary_Aggregate;
  /** fetch data from the table: "arbitrum.pair_with_prices_tb" */
  arbitrum_pair_with_prices_tb: Array<Arbitrum_Pair_With_Prices_Tb>;
  /** fetch data from the table: "arbitrum.pairs" */
  arbitrum_pairs: Array<Arbitrum_Pairs>;
  /** fetch data from the table: "arbitrum.pairs" using primary key columns */
  arbitrum_pairs_by_pk?: Maybe<Arbitrum_Pairs>;
  /** fetch data from the table: "arbitrum.pairs_tx_count" */
  arbitrum_pairs_tx_count: Array<Arbitrum_Pairs_Tx_Count>;
  /** fetch data from the table: "arbitrum.pairs_tx_count" using primary key columns */
  arbitrum_pairs_tx_count_by_pk?: Maybe<Arbitrum_Pairs_Tx_Count>;
  /** fetch data from the table: "arbitrum.protocols" */
  arbitrum_protocols: Array<Arbitrum_Protocols>;
  /** fetch data from the table: "arbitrum.protocols" using primary key columns */
  arbitrum_protocols_by_pk?: Maybe<Arbitrum_Protocols>;
  /** fetch data from the table: "arbitrum.swap_candles_cached" */
  arbitrum_swap_candles_cached: Array<Arbitrum_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "arbitrum.swap_candles_cached" */
  arbitrum_swap_candles_cached_aggregate: Arbitrum_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "arbitrum.swap_candles_cached" using primary key columns */
  arbitrum_swap_candles_cached_by_pk?: Maybe<Arbitrum_Swap_Candles_Cached>;
  /** fetch data from the table: "arbitrum.swap_candles_tb" */
  arbitrum_swap_candles_tb: Array<Arbitrum_Swap_Candles_Tb>;
  /** fetch data from the table: "arbitrum.tokens" */
  arbitrum_tokens: Array<Arbitrum_Tokens>;
  /** fetch data from the table: "arbitrum.tokens" using primary key columns */
  arbitrum_tokens_by_pk?: Maybe<Arbitrum_Tokens>;
  /** fetch data from the table: "arbitrum.tokenswaps_with_prices" */
  arbitrum_tokenswaps_with_prices: Array<Arbitrum_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "arbitrum.tokenswaps_with_prices" */
  arbitrum_tokenswaps_with_prices_aggregate: Arbitrum_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "arbitrum.tokenswaps_with_prices" using primary key columns */
  arbitrum_tokenswaps_with_prices_by_pk?: Maybe<Arbitrum_Tokenswaps_With_Prices>;
  /** fetch data from the table: "arbitrum.usd_tokens" */
  arbitrum_usd_tokens: Array<Arbitrum_Usd_Tokens>;
  /** fetch data from the table: "arbitrum.usd_tokens" using primary key columns */
  arbitrum_usd_tokens_by_pk?: Maybe<Arbitrum_Usd_Tokens>;
  /** fetch data from the table: "avalanche.borrows" */
  avalanche_borrows: Array<Avalanche_Borrows>;
  /** fetch data from the table: "avalanche.borrows" using primary key columns */
  avalanche_borrows_by_pk?: Maybe<Avalanche_Borrows>;
  /** execute function "avalanche.get_lending_market_user_count" which returns "avalanche.lending_market_user_count_tb" */
  avalanche_get_lending_market_user_count: Array<Avalanche_Lending_Market_User_Count_Tb>;
  /** execute function "avalanche.get_pair_tx_count" which returns "avalanche.pairs_tx_count" */
  avalanche_get_pair_tx_count: Array<Avalanche_Pairs_Tx_Count>;
  /** execute function "avalanche.get_swap_candles" which returns "avalanche.swap_candles_tb" */
  avalanche_get_swap_candles: Array<Avalanche_Swap_Candles_Tb>;
  /** fetch data from the table: "avalanche.lending_market_daily_snapshots" */
  avalanche_lending_market_daily_snapshots: Array<Avalanche_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "avalanche.lending_market_user_count_tb" */
  avalanche_lending_market_user_count_tb: Array<Avalanche_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "avalanche.lending_supplies" */
  avalanche_lending_supplies: Array<Avalanche_Lending_Supplies>;
  /** fetch data from the table: "avalanche.lending_supplies" using primary key columns */
  avalanche_lending_supplies_by_pk?: Maybe<Avalanche_Lending_Supplies>;
  /** fetch data from the table: "avalanche.liquidity_changes" */
  avalanche_liquidity_changes: Array<Avalanche_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "avalanche.liquidity_changes" */
  avalanche_liquidity_changes_aggregate: Avalanche_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "avalanche.liquidity_changes" using primary key columns */
  avalanche_liquidity_changes_by_pk?: Maybe<Avalanche_Liquidity_Changes>;
  /** fetch data from the table: "avalanche.liquidity_with_prices" */
  avalanche_liquidity_with_prices: Array<Avalanche_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "avalanche.liquidity_with_prices" */
  avalanche_liquidity_with_prices_aggregate: Avalanche_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "avalanche.liquidity_with_prices" using primary key columns */
  avalanche_liquidity_with_prices_by_pk?: Maybe<Avalanche_Liquidity_With_Prices>;
  /** fetch data from the table: "avalanche.loan_liquidations" */
  avalanche_loan_liquidations: Array<Avalanche_Loan_Liquidations>;
  /** fetch data from the table: "avalanche.loan_liquidations" using primary key columns */
  avalanche_loan_liquidations_by_pk?: Maybe<Avalanche_Loan_Liquidations>;
  /** fetch data from the table: "avalanche.pair_search" */
  avalanche_pair_search: Array<Avalanche_Pair_Search>;
  /** fetch aggregated fields from the table: "avalanche.pair_search" */
  avalanche_pair_search_aggregate: Avalanche_Pair_Search_Aggregate;
  /** fetch data from the table: "avalanche.pair_summary" */
  avalanche_pair_summary: Array<Avalanche_Pair_Summary>;
  /** fetch aggregated fields from the table: "avalanche.pair_summary" */
  avalanche_pair_summary_aggregate: Avalanche_Pair_Summary_Aggregate;
  /** fetch data from the table: "avalanche.pair_with_prices_tb" */
  avalanche_pair_with_prices_tb: Array<Avalanche_Pair_With_Prices_Tb>;
  /** fetch data from the table: "avalanche.pairs" */
  avalanche_pairs: Array<Avalanche_Pairs>;
  /** fetch data from the table: "avalanche.pairs" using primary key columns */
  avalanche_pairs_by_pk?: Maybe<Avalanche_Pairs>;
  /** fetch data from the table: "avalanche.pairs_tx_count" */
  avalanche_pairs_tx_count: Array<Avalanche_Pairs_Tx_Count>;
  /** fetch data from the table: "avalanche.pairs_tx_count" using primary key columns */
  avalanche_pairs_tx_count_by_pk?: Maybe<Avalanche_Pairs_Tx_Count>;
  /** fetch data from the table: "avalanche.protocols" */
  avalanche_protocols: Array<Avalanche_Protocols>;
  /** fetch data from the table: "avalanche.protocols" using primary key columns */
  avalanche_protocols_by_pk?: Maybe<Avalanche_Protocols>;
  /** fetch data from the table: "avalanche.swap_candles_cached" */
  avalanche_swap_candles_cached: Array<Avalanche_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "avalanche.swap_candles_cached" */
  avalanche_swap_candles_cached_aggregate: Avalanche_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "avalanche.swap_candles_cached" using primary key columns */
  avalanche_swap_candles_cached_by_pk?: Maybe<Avalanche_Swap_Candles_Cached>;
  /** fetch data from the table: "avalanche.swap_candles_tb" */
  avalanche_swap_candles_tb: Array<Avalanche_Swap_Candles_Tb>;
  /** fetch data from the table: "avalanche.tokens" */
  avalanche_tokens: Array<Avalanche_Tokens>;
  /** fetch data from the table: "avalanche.tokens" using primary key columns */
  avalanche_tokens_by_pk?: Maybe<Avalanche_Tokens>;
  /** fetch data from the table: "avalanche.tokenswaps_with_prices" */
  avalanche_tokenswaps_with_prices: Array<Avalanche_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "avalanche.tokenswaps_with_prices" */
  avalanche_tokenswaps_with_prices_aggregate: Avalanche_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "avalanche.tokenswaps_with_prices" using primary key columns */
  avalanche_tokenswaps_with_prices_by_pk?: Maybe<Avalanche_Tokenswaps_With_Prices>;
  /** fetch data from the table: "avalanche.usd_tokens" */
  avalanche_usd_tokens: Array<Avalanche_Usd_Tokens>;
  /** fetch data from the table: "avalanche.usd_tokens" using primary key columns */
  avalanche_usd_tokens_by_pk?: Maybe<Avalanche_Usd_Tokens>;
  /** fetch data from the table: "bsc.borrows" */
  bsc_borrows: Array<Bsc_Borrows>;
  /** fetch data from the table: "bsc.borrows" using primary key columns */
  bsc_borrows_by_pk?: Maybe<Bsc_Borrows>;
  /** execute function "bsc.get_lending_market_user_count" which returns "bsc.lending_market_user_count_tb" */
  bsc_get_lending_market_user_count: Array<Bsc_Lending_Market_User_Count_Tb>;
  /** execute function "bsc.get_pair_tx_count" which returns "bsc.pairs_tx_count" */
  bsc_get_pair_tx_count: Array<Bsc_Pairs_Tx_Count>;
  /** execute function "bsc.get_swap_candles" which returns "bsc.swap_candles_tb" */
  bsc_get_swap_candles: Array<Bsc_Swap_Candles_Tb>;
  /** fetch data from the table: "bsc.lending_market_daily_snapshots" */
  bsc_lending_market_daily_snapshots: Array<Bsc_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "bsc.lending_market_user_count_tb" */
  bsc_lending_market_user_count_tb: Array<Bsc_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "bsc.lending_supplies" */
  bsc_lending_supplies: Array<Bsc_Lending_Supplies>;
  /** fetch data from the table: "bsc.lending_supplies" using primary key columns */
  bsc_lending_supplies_by_pk?: Maybe<Bsc_Lending_Supplies>;
  /** fetch data from the table: "bsc.liquidity_changes" */
  bsc_liquidity_changes: Array<Bsc_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "bsc.liquidity_changes" */
  bsc_liquidity_changes_aggregate: Bsc_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "bsc.liquidity_changes" using primary key columns */
  bsc_liquidity_changes_by_pk?: Maybe<Bsc_Liquidity_Changes>;
  /** fetch data from the table: "bsc.liquidity_with_prices" */
  bsc_liquidity_with_prices: Array<Bsc_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "bsc.liquidity_with_prices" */
  bsc_liquidity_with_prices_aggregate: Bsc_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "bsc.liquidity_with_prices" using primary key columns */
  bsc_liquidity_with_prices_by_pk?: Maybe<Bsc_Liquidity_With_Prices>;
  /** fetch data from the table: "bsc.loan_liquidations" */
  bsc_loan_liquidations: Array<Bsc_Loan_Liquidations>;
  /** fetch data from the table: "bsc.loan_liquidations" using primary key columns */
  bsc_loan_liquidations_by_pk?: Maybe<Bsc_Loan_Liquidations>;
  /** fetch data from the table: "bsc.pair_search" */
  bsc_pair_search: Array<Bsc_Pair_Search>;
  /** fetch data from the table: "bsc.pair_summary" */
  bsc_pair_summary: Array<Bsc_Pair_Summary>;
  /** fetch data from the table: "bsc.pair_with_prices_tb" */
  bsc_pair_with_prices_tb: Array<Bsc_Pair_With_Prices_Tb>;
  /** fetch data from the table: "bsc.pairs" */
  bsc_pairs: Array<Bsc_Pairs>;
  /** fetch data from the table: "bsc.pairs" using primary key columns */
  bsc_pairs_by_pk?: Maybe<Bsc_Pairs>;
  /** fetch data from the table: "bsc.pairs_tx_count" */
  bsc_pairs_tx_count: Array<Bsc_Pairs_Tx_Count>;
  /** fetch data from the table: "bsc.pairs_tx_count" using primary key columns */
  bsc_pairs_tx_count_by_pk?: Maybe<Bsc_Pairs_Tx_Count>;
  /** fetch data from the table: "bsc.protocols" */
  bsc_protocols: Array<Bsc_Protocols>;
  /** fetch data from the table: "bsc.protocols" using primary key columns */
  bsc_protocols_by_pk?: Maybe<Bsc_Protocols>;
  /** fetch data from the table: "bsc.swap_candles_cached" */
  bsc_swap_candles_cached: Array<Bsc_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "bsc.swap_candles_cached" */
  bsc_swap_candles_cached_aggregate: Bsc_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "bsc.swap_candles_cached" using primary key columns */
  bsc_swap_candles_cached_by_pk?: Maybe<Bsc_Swap_Candles_Cached>;
  /** fetch data from the table: "bsc.swap_candles_tb" */
  bsc_swap_candles_tb: Array<Bsc_Swap_Candles_Tb>;
  /** fetch data from the table: "bsc.tokens" */
  bsc_tokens: Array<Bsc_Tokens>;
  /** fetch data from the table: "bsc.tokens" using primary key columns */
  bsc_tokens_by_pk?: Maybe<Bsc_Tokens>;
  /** fetch data from the table: "bsc.tokenswaps_with_prices" */
  bsc_tokenswaps_with_prices: Array<Bsc_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "bsc.tokenswaps_with_prices" */
  bsc_tokenswaps_with_prices_aggregate: Bsc_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "bsc.tokenswaps_with_prices" using primary key columns */
  bsc_tokenswaps_with_prices_by_pk?: Maybe<Bsc_Tokenswaps_With_Prices>;
  /** fetch data from the table: "dfk.borrows" */
  dfk_borrows: Array<Dfk_Borrows>;
  /** fetch data from the table: "dfk.borrows" using primary key columns */
  dfk_borrows_by_pk?: Maybe<Dfk_Borrows>;
  /** execute function "dfk.get_lending_market_user_count" which returns "dfk.lending_market_user_count_tb" */
  dfk_get_lending_market_user_count: Array<Dfk_Lending_Market_User_Count_Tb>;
  /** execute function "dfk.get_pair_tx_count" which returns "dfk.pairs_tx_count" */
  dfk_get_pair_tx_count: Array<Dfk_Pairs_Tx_Count>;
  /** execute function "dfk.get_swap_candles" which returns "dfk.swap_candles_tb" */
  dfk_get_swap_candles: Array<Dfk_Swap_Candles_Tb>;
  /** fetch data from the table: "dfk.lending_market_daily_snapshots" */
  dfk_lending_market_daily_snapshots: Array<Dfk_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "dfk.lending_market_user_count_tb" */
  dfk_lending_market_user_count_tb: Array<Dfk_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "dfk.lending_supplies" */
  dfk_lending_supplies: Array<Dfk_Lending_Supplies>;
  /** fetch data from the table: "dfk.lending_supplies" using primary key columns */
  dfk_lending_supplies_by_pk?: Maybe<Dfk_Lending_Supplies>;
  /** fetch data from the table: "dfk.liquidity_changes" */
  dfk_liquidity_changes: Array<Dfk_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "dfk.liquidity_changes" */
  dfk_liquidity_changes_aggregate: Dfk_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "dfk.liquidity_changes" using primary key columns */
  dfk_liquidity_changes_by_pk?: Maybe<Dfk_Liquidity_Changes>;
  /** fetch data from the table: "dfk.liquidity_with_prices" */
  dfk_liquidity_with_prices: Array<Dfk_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "dfk.liquidity_with_prices" */
  dfk_liquidity_with_prices_aggregate: Dfk_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "dfk.liquidity_with_prices" using primary key columns */
  dfk_liquidity_with_prices_by_pk?: Maybe<Dfk_Liquidity_With_Prices>;
  /** fetch data from the table: "dfk.loan_liquidations" */
  dfk_loan_liquidations: Array<Dfk_Loan_Liquidations>;
  /** fetch data from the table: "dfk.loan_liquidations" using primary key columns */
  dfk_loan_liquidations_by_pk?: Maybe<Dfk_Loan_Liquidations>;
  /** fetch data from the table: "dfk.pair_search" */
  dfk_pair_search: Array<Dfk_Pair_Search>;
  /** fetch aggregated fields from the table: "dfk.pair_search" */
  dfk_pair_search_aggregate: Dfk_Pair_Search_Aggregate;
  /** fetch data from the table: "dfk.pair_summary" */
  dfk_pair_summary: Array<Dfk_Pair_Summary>;
  /** fetch aggregated fields from the table: "dfk.pair_summary" */
  dfk_pair_summary_aggregate: Dfk_Pair_Summary_Aggregate;
  /** fetch data from the table: "dfk.pair_with_prices_tb" */
  dfk_pair_with_prices_tb: Array<Dfk_Pair_With_Prices_Tb>;
  /** fetch data from the table: "dfk.pairs" */
  dfk_pairs: Array<Dfk_Pairs>;
  /** fetch data from the table: "dfk.pairs" using primary key columns */
  dfk_pairs_by_pk?: Maybe<Dfk_Pairs>;
  /** fetch data from the table: "dfk.pairs_tx_count" */
  dfk_pairs_tx_count: Array<Dfk_Pairs_Tx_Count>;
  /** fetch data from the table: "dfk.pairs_tx_count" using primary key columns */
  dfk_pairs_tx_count_by_pk?: Maybe<Dfk_Pairs_Tx_Count>;
  /** fetch data from the table: "dfk.protocols" */
  dfk_protocols: Array<Dfk_Protocols>;
  /** fetch data from the table: "dfk.protocols" using primary key columns */
  dfk_protocols_by_pk?: Maybe<Dfk_Protocols>;
  /** fetch data from the table: "dfk.swap_candles_cached" */
  dfk_swap_candles_cached: Array<Dfk_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "dfk.swap_candles_cached" */
  dfk_swap_candles_cached_aggregate: Dfk_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "dfk.swap_candles_cached" using primary key columns */
  dfk_swap_candles_cached_by_pk?: Maybe<Dfk_Swap_Candles_Cached>;
  /** fetch data from the table: "dfk.swap_candles_tb" */
  dfk_swap_candles_tb: Array<Dfk_Swap_Candles_Tb>;
  /** fetch data from the table: "dfk.tokens" */
  dfk_tokens: Array<Dfk_Tokens>;
  /** fetch data from the table: "dfk.tokens" using primary key columns */
  dfk_tokens_by_pk?: Maybe<Dfk_Tokens>;
  /** fetch data from the table: "dfk.tokenswaps_with_prices" */
  dfk_tokenswaps_with_prices: Array<Dfk_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "dfk.tokenswaps_with_prices" */
  dfk_tokenswaps_with_prices_aggregate: Dfk_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "dfk.tokenswaps_with_prices" using primary key columns */
  dfk_tokenswaps_with_prices_by_pk?: Maybe<Dfk_Tokenswaps_With_Prices>;
  /** fetch data from the table: "dfk.usd_tokens" */
  dfk_usd_tokens: Array<Dfk_Usd_Tokens>;
  /** fetch data from the table: "dfk.usd_tokens" using primary key columns */
  dfk_usd_tokens_by_pk?: Maybe<Dfk_Usd_Tokens>;
  /** fetch data from the table: "ethereum.borrows" */
  ethereum_borrows: Array<Ethereum_Borrows>;
  /** fetch data from the table: "ethereum.borrows" using primary key columns */
  ethereum_borrows_by_pk?: Maybe<Ethereum_Borrows>;
  /** execute function "ethereum.get_lending_market_user_count" which returns "ethereum.lending_market_user_count_tb" */
  ethereum_get_lending_market_user_count: Array<Ethereum_Lending_Market_User_Count_Tb>;
  /** execute function "ethereum.get_pair_tx_count" which returns "ethereum.pairs_tx_count" */
  ethereum_get_pair_tx_count: Array<Ethereum_Pairs_Tx_Count>;
  /** execute function "ethereum.get_swap_candles" which returns "ethereum.swap_candles_tb" */
  ethereum_get_swap_candles: Array<Ethereum_Swap_Candles_Tb>;
  /** fetch data from the table: "ethereum.lending_market_daily_snapshots" */
  ethereum_lending_market_daily_snapshots: Array<Ethereum_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "ethereum.lending_market_user_count_tb" */
  ethereum_lending_market_user_count_tb: Array<Ethereum_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "ethereum.lending_supplies" */
  ethereum_lending_supplies: Array<Ethereum_Lending_Supplies>;
  /** fetch data from the table: "ethereum.lending_supplies" using primary key columns */
  ethereum_lending_supplies_by_pk?: Maybe<Ethereum_Lending_Supplies>;
  /** fetch data from the table: "ethereum.liquidity_changes" */
  ethereum_liquidity_changes: Array<Ethereum_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "ethereum.liquidity_changes" */
  ethereum_liquidity_changes_aggregate: Ethereum_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "ethereum.liquidity_changes" using primary key columns */
  ethereum_liquidity_changes_by_pk?: Maybe<Ethereum_Liquidity_Changes>;
  /** fetch data from the table: "ethereum.liquidity_with_prices" */
  ethereum_liquidity_with_prices: Array<Ethereum_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "ethereum.liquidity_with_prices" */
  ethereum_liquidity_with_prices_aggregate: Ethereum_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "ethereum.liquidity_with_prices" using primary key columns */
  ethereum_liquidity_with_prices_by_pk?: Maybe<Ethereum_Liquidity_With_Prices>;
  /** fetch data from the table: "ethereum.loan_liquidations" */
  ethereum_loan_liquidations: Array<Ethereum_Loan_Liquidations>;
  /** fetch data from the table: "ethereum.loan_liquidations" using primary key columns */
  ethereum_loan_liquidations_by_pk?: Maybe<Ethereum_Loan_Liquidations>;
  /** fetch data from the table: "ethereum.pair_search" */
  ethereum_pair_search: Array<Ethereum_Pair_Search>;
  /** fetch aggregated fields from the table: "ethereum.pair_search" */
  ethereum_pair_search_aggregate: Ethereum_Pair_Search_Aggregate;
  /** fetch data from the table: "ethereum.pair_summary" */
  ethereum_pair_summary: Array<Ethereum_Pair_Summary>;
  /** fetch aggregated fields from the table: "ethereum.pair_summary" */
  ethereum_pair_summary_aggregate: Ethereum_Pair_Summary_Aggregate;
  /** fetch data from the table: "ethereum.pair_with_prices_tb" */
  ethereum_pair_with_prices_tb: Array<Ethereum_Pair_With_Prices_Tb>;
  /** fetch data from the table: "ethereum.pairs" */
  ethereum_pairs: Array<Ethereum_Pairs>;
  /** fetch data from the table: "ethereum.pairs" using primary key columns */
  ethereum_pairs_by_pk?: Maybe<Ethereum_Pairs>;
  /** fetch data from the table: "ethereum.pairs_tx_count" */
  ethereum_pairs_tx_count: Array<Ethereum_Pairs_Tx_Count>;
  /** fetch data from the table: "ethereum.pairs_tx_count" using primary key columns */
  ethereum_pairs_tx_count_by_pk?: Maybe<Ethereum_Pairs_Tx_Count>;
  /** fetch data from the table: "ethereum.protocols" */
  ethereum_protocols: Array<Ethereum_Protocols>;
  /** fetch data from the table: "ethereum.protocols" using primary key columns */
  ethereum_protocols_by_pk?: Maybe<Ethereum_Protocols>;
  /** fetch data from the table: "ethereum.swap_candles_cached" */
  ethereum_swap_candles_cached: Array<Ethereum_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "ethereum.swap_candles_cached" */
  ethereum_swap_candles_cached_aggregate: Ethereum_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "ethereum.swap_candles_cached" using primary key columns */
  ethereum_swap_candles_cached_by_pk?: Maybe<Ethereum_Swap_Candles_Cached>;
  /** fetch data from the table: "ethereum.swap_candles_tb" */
  ethereum_swap_candles_tb: Array<Ethereum_Swap_Candles_Tb>;
  /** fetch data from the table: "ethereum.tokens" */
  ethereum_tokens: Array<Ethereum_Tokens>;
  /** fetch data from the table: "ethereum.tokens" using primary key columns */
  ethereum_tokens_by_pk?: Maybe<Ethereum_Tokens>;
  /** fetch data from the table: "ethereum.tokenswaps_with_prices" */
  ethereum_tokenswaps_with_prices: Array<Ethereum_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "ethereum.tokenswaps_with_prices" */
  ethereum_tokenswaps_with_prices_aggregate: Ethereum_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "ethereum.tokenswaps_with_prices" using primary key columns */
  ethereum_tokenswaps_with_prices_by_pk?: Maybe<Ethereum_Tokenswaps_With_Prices>;
  /** fetch data from the table: "ethereum.usd_tokens" */
  ethereum_usd_tokens: Array<Ethereum_Usd_Tokens>;
  /** fetch data from the table: "ethereum.usd_tokens" using primary key columns */
  ethereum_usd_tokens_by_pk?: Maybe<Ethereum_Usd_Tokens>;
  /** fetch data from the table: "metis.borrows" */
  metis_borrows: Array<Metis_Borrows>;
  /** fetch data from the table: "metis.borrows" using primary key columns */
  metis_borrows_by_pk?: Maybe<Metis_Borrows>;
  /** execute function "metis.get_lending_market_user_count" which returns "metis.lending_market_user_count_tb" */
  metis_get_lending_market_user_count: Array<Metis_Lending_Market_User_Count_Tb>;
  /** execute function "metis.get_pair_tx_count" which returns "metis.pairs_tx_count" */
  metis_get_pair_tx_count: Array<Metis_Pairs_Tx_Count>;
  /** execute function "metis.get_swap_candles" which returns "metis.swap_candles_tb" */
  metis_get_swap_candles: Array<Metis_Swap_Candles_Tb>;
  /** fetch data from the table: "metis.lending_market_daily_snapshots" */
  metis_lending_market_daily_snapshots: Array<Metis_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "metis.lending_market_user_count_tb" */
  metis_lending_market_user_count_tb: Array<Metis_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "metis.lending_supplies" */
  metis_lending_supplies: Array<Metis_Lending_Supplies>;
  /** fetch data from the table: "metis.lending_supplies" using primary key columns */
  metis_lending_supplies_by_pk?: Maybe<Metis_Lending_Supplies>;
  /** fetch data from the table: "metis.liquidity_changes" */
  metis_liquidity_changes: Array<Metis_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "metis.liquidity_changes" */
  metis_liquidity_changes_aggregate: Metis_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "metis.liquidity_changes" using primary key columns */
  metis_liquidity_changes_by_pk?: Maybe<Metis_Liquidity_Changes>;
  /** fetch data from the table: "metis.liquidity_with_prices" */
  metis_liquidity_with_prices: Array<Metis_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "metis.liquidity_with_prices" */
  metis_liquidity_with_prices_aggregate: Metis_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "metis.liquidity_with_prices" using primary key columns */
  metis_liquidity_with_prices_by_pk?: Maybe<Metis_Liquidity_With_Prices>;
  /** fetch data from the table: "metis.loan_liquidations" */
  metis_loan_liquidations: Array<Metis_Loan_Liquidations>;
  /** fetch data from the table: "metis.loan_liquidations" using primary key columns */
  metis_loan_liquidations_by_pk?: Maybe<Metis_Loan_Liquidations>;
  /** fetch data from the table: "metis.pair_search" */
  metis_pair_search: Array<Metis_Pair_Search>;
  /** fetch aggregated fields from the table: "metis.pair_search" */
  metis_pair_search_aggregate: Metis_Pair_Search_Aggregate;
  /** fetch data from the table: "metis.pair_summary" */
  metis_pair_summary: Array<Metis_Pair_Summary>;
  /** fetch aggregated fields from the table: "metis.pair_summary" */
  metis_pair_summary_aggregate: Metis_Pair_Summary_Aggregate;
  /** fetch data from the table: "metis.pair_with_prices_tb" */
  metis_pair_with_prices_tb: Array<Metis_Pair_With_Prices_Tb>;
  /** fetch data from the table: "metis.pairs" */
  metis_pairs: Array<Metis_Pairs>;
  /** fetch data from the table: "metis.pairs" using primary key columns */
  metis_pairs_by_pk?: Maybe<Metis_Pairs>;
  /** fetch data from the table: "metis.pairs_tx_count" */
  metis_pairs_tx_count: Array<Metis_Pairs_Tx_Count>;
  /** fetch data from the table: "metis.pairs_tx_count" using primary key columns */
  metis_pairs_tx_count_by_pk?: Maybe<Metis_Pairs_Tx_Count>;
  /** fetch data from the table: "metis.protocols" */
  metis_protocols: Array<Metis_Protocols>;
  /** fetch data from the table: "metis.protocols" using primary key columns */
  metis_protocols_by_pk?: Maybe<Metis_Protocols>;
  /** fetch data from the table: "metis.swap_candles_cached" */
  metis_swap_candles_cached: Array<Metis_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "metis.swap_candles_cached" */
  metis_swap_candles_cached_aggregate: Metis_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "metis.swap_candles_cached" using primary key columns */
  metis_swap_candles_cached_by_pk?: Maybe<Metis_Swap_Candles_Cached>;
  /** fetch data from the table: "metis.swap_candles_tb" */
  metis_swap_candles_tb: Array<Metis_Swap_Candles_Tb>;
  /** fetch data from the table: "metis.tokens" */
  metis_tokens: Array<Metis_Tokens>;
  /** fetch data from the table: "metis.tokens" using primary key columns */
  metis_tokens_by_pk?: Maybe<Metis_Tokens>;
  /** fetch data from the table: "metis.tokenswaps_with_prices" */
  metis_tokenswaps_with_prices: Array<Metis_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "metis.tokenswaps_with_prices" */
  metis_tokenswaps_with_prices_aggregate: Metis_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "metis.tokenswaps_with_prices" using primary key columns */
  metis_tokenswaps_with_prices_by_pk?: Maybe<Metis_Tokenswaps_With_Prices>;
  /** fetch data from the table: "metis.usd_tokens" */
  metis_usd_tokens: Array<Metis_Usd_Tokens>;
  /** fetch data from the table: "metis.usd_tokens" using primary key columns */
  metis_usd_tokens_by_pk?: Maybe<Metis_Usd_Tokens>;
  /** fetch data from the table: "moonbeam.borrows" */
  moonbeam_borrows: Array<Moonbeam_Borrows>;
  /** fetch data from the table: "moonbeam.borrows" using primary key columns */
  moonbeam_borrows_by_pk?: Maybe<Moonbeam_Borrows>;
  /** execute function "moonbeam.get_lending_market_user_count" which returns "moonbeam.lending_market_user_count_tb" */
  moonbeam_get_lending_market_user_count: Array<Moonbeam_Lending_Market_User_Count_Tb>;
  /** execute function "moonbeam.get_pair_tx_count" which returns "moonbeam.pairs_tx_count" */
  moonbeam_get_pair_tx_count: Array<Moonbeam_Pairs_Tx_Count>;
  /** execute function "moonbeam.get_swap_candles" which returns "moonbeam.swap_candles_tb" */
  moonbeam_get_swap_candles: Array<Moonbeam_Swap_Candles_Tb>;
  /** fetch data from the table: "moonbeam.lending_market_daily_snapshots" */
  moonbeam_lending_market_daily_snapshots: Array<Moonbeam_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "moonbeam.lending_market_user_count_tb" */
  moonbeam_lending_market_user_count_tb: Array<Moonbeam_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "moonbeam.lending_supplies" */
  moonbeam_lending_supplies: Array<Moonbeam_Lending_Supplies>;
  /** fetch data from the table: "moonbeam.lending_supplies" using primary key columns */
  moonbeam_lending_supplies_by_pk?: Maybe<Moonbeam_Lending_Supplies>;
  /** fetch data from the table: "moonbeam.liquidity_changes" */
  moonbeam_liquidity_changes: Array<Moonbeam_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "moonbeam.liquidity_changes" */
  moonbeam_liquidity_changes_aggregate: Moonbeam_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "moonbeam.liquidity_changes" using primary key columns */
  moonbeam_liquidity_changes_by_pk?: Maybe<Moonbeam_Liquidity_Changes>;
  /** fetch data from the table: "moonbeam.liquidity_with_prices" */
  moonbeam_liquidity_with_prices: Array<Moonbeam_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "moonbeam.liquidity_with_prices" */
  moonbeam_liquidity_with_prices_aggregate: Moonbeam_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "moonbeam.liquidity_with_prices" using primary key columns */
  moonbeam_liquidity_with_prices_by_pk?: Maybe<Moonbeam_Liquidity_With_Prices>;
  /** fetch data from the table: "moonbeam.loan_liquidations" */
  moonbeam_loan_liquidations: Array<Moonbeam_Loan_Liquidations>;
  /** fetch data from the table: "moonbeam.loan_liquidations" using primary key columns */
  moonbeam_loan_liquidations_by_pk?: Maybe<Moonbeam_Loan_Liquidations>;
  /** fetch data from the table: "moonbeam.pair_search" */
  moonbeam_pair_search: Array<Moonbeam_Pair_Search>;
  /** fetch data from the table: "moonbeam.pair_summary" */
  moonbeam_pair_summary: Array<Moonbeam_Pair_Summary>;
  /** fetch data from the table: "moonbeam.pair_with_prices_tb" */
  moonbeam_pair_with_prices_tb: Array<Moonbeam_Pair_With_Prices_Tb>;
  /** fetch data from the table: "moonbeam.pairs" */
  moonbeam_pairs: Array<Moonbeam_Pairs>;
  /** fetch data from the table: "moonbeam.pairs" using primary key columns */
  moonbeam_pairs_by_pk?: Maybe<Moonbeam_Pairs>;
  /** fetch data from the table: "moonbeam.pairs_tx_count" */
  moonbeam_pairs_tx_count: Array<Moonbeam_Pairs_Tx_Count>;
  /** fetch data from the table: "moonbeam.pairs_tx_count" using primary key columns */
  moonbeam_pairs_tx_count_by_pk?: Maybe<Moonbeam_Pairs_Tx_Count>;
  /** fetch data from the table: "moonbeam.protocols" */
  moonbeam_protocols: Array<Moonbeam_Protocols>;
  /** fetch data from the table: "moonbeam.protocols" using primary key columns */
  moonbeam_protocols_by_pk?: Maybe<Moonbeam_Protocols>;
  /** fetch data from the table: "moonbeam.swap_candles_cached" */
  moonbeam_swap_candles_cached: Array<Moonbeam_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "moonbeam.swap_candles_cached" */
  moonbeam_swap_candles_cached_aggregate: Moonbeam_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "moonbeam.swap_candles_cached" using primary key columns */
  moonbeam_swap_candles_cached_by_pk?: Maybe<Moonbeam_Swap_Candles_Cached>;
  /** fetch data from the table: "moonbeam.swap_candles_tb" */
  moonbeam_swap_candles_tb: Array<Moonbeam_Swap_Candles_Tb>;
  /** fetch data from the table: "moonbeam.tokens" */
  moonbeam_tokens: Array<Moonbeam_Tokens>;
  /** fetch data from the table: "moonbeam.tokens" using primary key columns */
  moonbeam_tokens_by_pk?: Maybe<Moonbeam_Tokens>;
  /** fetch data from the table: "moonbeam.tokenswaps_with_prices" */
  moonbeam_tokenswaps_with_prices: Array<Moonbeam_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "moonbeam.tokenswaps_with_prices" */
  moonbeam_tokenswaps_with_prices_aggregate: Moonbeam_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "moonbeam.tokenswaps_with_prices" using primary key columns */
  moonbeam_tokenswaps_with_prices_by_pk?: Maybe<Moonbeam_Tokenswaps_With_Prices>;
  /** fetch data from the table: "moonriver.borrows" */
  moonriver_borrows: Array<Moonriver_Borrows>;
  /** fetch data from the table: "moonriver.borrows" using primary key columns */
  moonriver_borrows_by_pk?: Maybe<Moonriver_Borrows>;
  /** execute function "moonriver.get_lending_market_user_count" which returns "moonriver.lending_market_user_count_tb" */
  moonriver_get_lending_market_user_count: Array<Moonriver_Lending_Market_User_Count_Tb>;
  /** execute function "moonriver.get_pair_tx_count" which returns "moonriver.pairs_tx_count" */
  moonriver_get_pair_tx_count: Array<Moonriver_Pairs_Tx_Count>;
  /** execute function "moonriver.get_swap_candles" which returns "moonriver.swap_candles_tb" */
  moonriver_get_swap_candles: Array<Moonriver_Swap_Candles_Tb>;
  /** fetch data from the table: "moonriver.lending_market_daily_snapshots" */
  moonriver_lending_market_daily_snapshots: Array<Moonriver_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "moonriver.lending_market_user_count_tb" */
  moonriver_lending_market_user_count_tb: Array<Moonriver_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "moonriver.lending_supplies" */
  moonriver_lending_supplies: Array<Moonriver_Lending_Supplies>;
  /** fetch data from the table: "moonriver.lending_supplies" using primary key columns */
  moonriver_lending_supplies_by_pk?: Maybe<Moonriver_Lending_Supplies>;
  /** fetch data from the table: "moonriver.liquidity_changes" */
  moonriver_liquidity_changes: Array<Moonriver_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "moonriver.liquidity_changes" */
  moonriver_liquidity_changes_aggregate: Moonriver_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "moonriver.liquidity_changes" using primary key columns */
  moonriver_liquidity_changes_by_pk?: Maybe<Moonriver_Liquidity_Changes>;
  /** fetch data from the table: "moonriver.liquidity_with_prices" */
  moonriver_liquidity_with_prices: Array<Moonriver_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "moonriver.liquidity_with_prices" */
  moonriver_liquidity_with_prices_aggregate: Moonriver_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "moonriver.liquidity_with_prices" using primary key columns */
  moonriver_liquidity_with_prices_by_pk?: Maybe<Moonriver_Liquidity_With_Prices>;
  /** fetch data from the table: "moonriver.loan_liquidations" */
  moonriver_loan_liquidations: Array<Moonriver_Loan_Liquidations>;
  /** fetch data from the table: "moonriver.loan_liquidations" using primary key columns */
  moonriver_loan_liquidations_by_pk?: Maybe<Moonriver_Loan_Liquidations>;
  /** fetch data from the table: "moonriver.pair_search" */
  moonriver_pair_search: Array<Moonriver_Pair_Search>;
  /** fetch data from the table: "moonriver.pair_summary" */
  moonriver_pair_summary: Array<Moonriver_Pair_Summary>;
  /** fetch data from the table: "moonriver.pair_with_prices_tb" */
  moonriver_pair_with_prices_tb: Array<Moonriver_Pair_With_Prices_Tb>;
  /** fetch data from the table: "moonriver.pairs" */
  moonriver_pairs: Array<Moonriver_Pairs>;
  /** fetch data from the table: "moonriver.pairs" using primary key columns */
  moonriver_pairs_by_pk?: Maybe<Moonriver_Pairs>;
  /** fetch data from the table: "moonriver.pairs_tx_count" */
  moonriver_pairs_tx_count: Array<Moonriver_Pairs_Tx_Count>;
  /** fetch data from the table: "moonriver.pairs_tx_count" using primary key columns */
  moonriver_pairs_tx_count_by_pk?: Maybe<Moonriver_Pairs_Tx_Count>;
  /** fetch data from the table: "moonriver.protocols" */
  moonriver_protocols: Array<Moonriver_Protocols>;
  /** fetch data from the table: "moonriver.protocols" using primary key columns */
  moonriver_protocols_by_pk?: Maybe<Moonriver_Protocols>;
  /** fetch data from the table: "moonriver.swap_candles_cached" */
  moonriver_swap_candles_cached: Array<Moonriver_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "moonriver.swap_candles_cached" */
  moonriver_swap_candles_cached_aggregate: Moonriver_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "moonriver.swap_candles_cached" using primary key columns */
  moonriver_swap_candles_cached_by_pk?: Maybe<Moonriver_Swap_Candles_Cached>;
  /** fetch data from the table: "moonriver.swap_candles_tb" */
  moonriver_swap_candles_tb: Array<Moonriver_Swap_Candles_Tb>;
  /** fetch data from the table: "moonriver.tokens" */
  moonriver_tokens: Array<Moonriver_Tokens>;
  /** fetch data from the table: "moonriver.tokens" using primary key columns */
  moonriver_tokens_by_pk?: Maybe<Moonriver_Tokens>;
  /** fetch data from the table: "moonriver.tokenswaps_with_prices" */
  moonriver_tokenswaps_with_prices: Array<Moonriver_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "moonriver.tokenswaps_with_prices" */
  moonriver_tokenswaps_with_prices_aggregate: Moonriver_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "moonriver.tokenswaps_with_prices" using primary key columns */
  moonriver_tokenswaps_with_prices_by_pk?: Maybe<Moonriver_Tokenswaps_With_Prices>;
  /** fetch data from the table: "optimism.borrows" */
  optimism_borrows: Array<Optimism_Borrows>;
  /** fetch data from the table: "optimism.borrows" using primary key columns */
  optimism_borrows_by_pk?: Maybe<Optimism_Borrows>;
  /** execute function "optimism.get_lending_market_user_count" which returns "optimism.lending_market_user_count_tb" */
  optimism_get_lending_market_user_count: Array<Optimism_Lending_Market_User_Count_Tb>;
  /** execute function "optimism.get_pair_tx_count" which returns "optimism.pairs_tx_count" */
  optimism_get_pair_tx_count: Array<Optimism_Pairs_Tx_Count>;
  /** execute function "optimism.get_swap_candles" which returns "optimism.swap_candles_tb" */
  optimism_get_swap_candles: Array<Optimism_Swap_Candles_Tb>;
  /** fetch data from the table: "optimism.lending_market_daily_snapshots" */
  optimism_lending_market_daily_snapshots: Array<Optimism_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "optimism.lending_market_user_count_tb" */
  optimism_lending_market_user_count_tb: Array<Optimism_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "optimism.lending_supplies" */
  optimism_lending_supplies: Array<Optimism_Lending_Supplies>;
  /** fetch data from the table: "optimism.lending_supplies" using primary key columns */
  optimism_lending_supplies_by_pk?: Maybe<Optimism_Lending_Supplies>;
  /** fetch data from the table: "optimism.liquidity_changes" */
  optimism_liquidity_changes: Array<Optimism_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "optimism.liquidity_changes" */
  optimism_liquidity_changes_aggregate: Optimism_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "optimism.liquidity_changes" using primary key columns */
  optimism_liquidity_changes_by_pk?: Maybe<Optimism_Liquidity_Changes>;
  /** fetch data from the table: "optimism.liquidity_with_prices" */
  optimism_liquidity_with_prices: Array<Optimism_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "optimism.liquidity_with_prices" */
  optimism_liquidity_with_prices_aggregate: Optimism_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "optimism.liquidity_with_prices" using primary key columns */
  optimism_liquidity_with_prices_by_pk?: Maybe<Optimism_Liquidity_With_Prices>;
  /** fetch data from the table: "optimism.loan_liquidations" */
  optimism_loan_liquidations: Array<Optimism_Loan_Liquidations>;
  /** fetch data from the table: "optimism.loan_liquidations" using primary key columns */
  optimism_loan_liquidations_by_pk?: Maybe<Optimism_Loan_Liquidations>;
  /** fetch data from the table: "optimism.pair_search" */
  optimism_pair_search: Array<Optimism_Pair_Search>;
  /** fetch aggregated fields from the table: "optimism.pair_search" */
  optimism_pair_search_aggregate: Optimism_Pair_Search_Aggregate;
  /** fetch data from the table: "optimism.pair_summary" */
  optimism_pair_summary: Array<Optimism_Pair_Summary>;
  /** fetch aggregated fields from the table: "optimism.pair_summary" */
  optimism_pair_summary_aggregate: Optimism_Pair_Summary_Aggregate;
  /** fetch data from the table: "optimism.pair_with_prices_tb" */
  optimism_pair_with_prices_tb: Array<Optimism_Pair_With_Prices_Tb>;
  /** fetch data from the table: "optimism.pairs" */
  optimism_pairs: Array<Optimism_Pairs>;
  /** fetch data from the table: "optimism.pairs" using primary key columns */
  optimism_pairs_by_pk?: Maybe<Optimism_Pairs>;
  /** fetch data from the table: "optimism.pairs_tx_count" */
  optimism_pairs_tx_count: Array<Optimism_Pairs_Tx_Count>;
  /** fetch data from the table: "optimism.pairs_tx_count" using primary key columns */
  optimism_pairs_tx_count_by_pk?: Maybe<Optimism_Pairs_Tx_Count>;
  /** fetch data from the table: "optimism.protocols" */
  optimism_protocols: Array<Optimism_Protocols>;
  /** fetch data from the table: "optimism.protocols" using primary key columns */
  optimism_protocols_by_pk?: Maybe<Optimism_Protocols>;
  /** fetch data from the table: "optimism.swap_candles_cached" */
  optimism_swap_candles_cached: Array<Optimism_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "optimism.swap_candles_cached" */
  optimism_swap_candles_cached_aggregate: Optimism_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "optimism.swap_candles_cached" using primary key columns */
  optimism_swap_candles_cached_by_pk?: Maybe<Optimism_Swap_Candles_Cached>;
  /** fetch data from the table: "optimism.swap_candles_tb" */
  optimism_swap_candles_tb: Array<Optimism_Swap_Candles_Tb>;
  /** fetch data from the table: "optimism.tokens" */
  optimism_tokens: Array<Optimism_Tokens>;
  /** fetch data from the table: "optimism.tokens" using primary key columns */
  optimism_tokens_by_pk?: Maybe<Optimism_Tokens>;
  /** fetch data from the table: "optimism.tokenswaps_with_prices" */
  optimism_tokenswaps_with_prices: Array<Optimism_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "optimism.tokenswaps_with_prices" */
  optimism_tokenswaps_with_prices_aggregate: Optimism_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "optimism.tokenswaps_with_prices" using primary key columns */
  optimism_tokenswaps_with_prices_by_pk?: Maybe<Optimism_Tokenswaps_With_Prices>;
  /** fetch data from the table: "optimism.usd_tokens" */
  optimism_usd_tokens: Array<Optimism_Usd_Tokens>;
  /** fetch data from the table: "optimism.usd_tokens" using primary key columns */
  optimism_usd_tokens_by_pk?: Maybe<Optimism_Usd_Tokens>;
  /** fetch data from the table: "polygon.borrows" */
  polygon_borrows: Array<Polygon_Borrows>;
  /** fetch data from the table: "polygon.borrows" using primary key columns */
  polygon_borrows_by_pk?: Maybe<Polygon_Borrows>;
  /** execute function "polygon.get_lending_market_user_count" which returns "polygon.lending_market_user_count_tb" */
  polygon_get_lending_market_user_count: Array<Polygon_Lending_Market_User_Count_Tb>;
  /** execute function "polygon.get_pair_tx_count" which returns "polygon.pairs_tx_count" */
  polygon_get_pair_tx_count: Array<Polygon_Pairs_Tx_Count>;
  /** execute function "polygon.get_swap_candles" which returns "polygon.swap_candles_tb" */
  polygon_get_swap_candles: Array<Polygon_Swap_Candles_Tb>;
  /** fetch data from the table: "polygon.lending_market_daily_snapshots" */
  polygon_lending_market_daily_snapshots: Array<Polygon_Lending_Market_Daily_Snapshots>;
  /** fetch data from the table: "polygon.lending_market_user_count_tb" */
  polygon_lending_market_user_count_tb: Array<Polygon_Lending_Market_User_Count_Tb>;
  /** fetch data from the table: "polygon.lending_supplies" */
  polygon_lending_supplies: Array<Polygon_Lending_Supplies>;
  /** fetch data from the table: "polygon.lending_supplies" using primary key columns */
  polygon_lending_supplies_by_pk?: Maybe<Polygon_Lending_Supplies>;
  /** fetch data from the table: "polygon.liquidity_changes" */
  polygon_liquidity_changes: Array<Polygon_Liquidity_Changes>;
  /** fetch aggregated fields from the table: "polygon.liquidity_changes" */
  polygon_liquidity_changes_aggregate: Polygon_Liquidity_Changes_Aggregate;
  /** fetch data from the table: "polygon.liquidity_changes" using primary key columns */
  polygon_liquidity_changes_by_pk?: Maybe<Polygon_Liquidity_Changes>;
  /** fetch data from the table: "polygon.liquidity_with_prices" */
  polygon_liquidity_with_prices: Array<Polygon_Liquidity_With_Prices>;
  /** fetch aggregated fields from the table: "polygon.liquidity_with_prices" */
  polygon_liquidity_with_prices_aggregate: Polygon_Liquidity_With_Prices_Aggregate;
  /** fetch data from the table: "polygon.liquidity_with_prices" using primary key columns */
  polygon_liquidity_with_prices_by_pk?: Maybe<Polygon_Liquidity_With_Prices>;
  /** fetch data from the table: "polygon.loan_liquidations" */
  polygon_loan_liquidations: Array<Polygon_Loan_Liquidations>;
  /** fetch data from the table: "polygon.loan_liquidations" using primary key columns */
  polygon_loan_liquidations_by_pk?: Maybe<Polygon_Loan_Liquidations>;
  /** fetch data from the table: "polygon.pair_search" */
  polygon_pair_search: Array<Polygon_Pair_Search>;
  /** fetch aggregated fields from the table: "polygon.pair_search" */
  polygon_pair_search_aggregate: Polygon_Pair_Search_Aggregate;
  /** fetch data from the table: "polygon.pair_summary" */
  polygon_pair_summary: Array<Polygon_Pair_Summary>;
  /** fetch aggregated fields from the table: "polygon.pair_summary" */
  polygon_pair_summary_aggregate: Polygon_Pair_Summary_Aggregate;
  /** fetch data from the table: "polygon.pair_with_prices_tb" */
  polygon_pair_with_prices_tb: Array<Polygon_Pair_With_Prices_Tb>;
  /** fetch data from the table: "polygon.pairs" */
  polygon_pairs: Array<Polygon_Pairs>;
  /** fetch data from the table: "polygon.pairs" using primary key columns */
  polygon_pairs_by_pk?: Maybe<Polygon_Pairs>;
  /** fetch data from the table: "polygon.pairs_tx_count" */
  polygon_pairs_tx_count: Array<Polygon_Pairs_Tx_Count>;
  /** fetch data from the table: "polygon.pairs_tx_count" using primary key columns */
  polygon_pairs_tx_count_by_pk?: Maybe<Polygon_Pairs_Tx_Count>;
  /** fetch data from the table: "polygon.protocols" */
  polygon_protocols: Array<Polygon_Protocols>;
  /** fetch data from the table: "polygon.protocols" using primary key columns */
  polygon_protocols_by_pk?: Maybe<Polygon_Protocols>;
  /** fetch data from the table: "polygon.swap_candles_cached" */
  polygon_swap_candles_cached: Array<Polygon_Swap_Candles_Cached>;
  /** fetch aggregated fields from the table: "polygon.swap_candles_cached" */
  polygon_swap_candles_cached_aggregate: Polygon_Swap_Candles_Cached_Aggregate;
  /** fetch data from the table: "polygon.swap_candles_cached" using primary key columns */
  polygon_swap_candles_cached_by_pk?: Maybe<Polygon_Swap_Candles_Cached>;
  /** fetch data from the table: "polygon.swap_candles_tb" */
  polygon_swap_candles_tb: Array<Polygon_Swap_Candles_Tb>;
  /** fetch data from the table: "polygon.tokens" */
  polygon_tokens: Array<Polygon_Tokens>;
  /** fetch data from the table: "polygon.tokens" using primary key columns */
  polygon_tokens_by_pk?: Maybe<Polygon_Tokens>;
  /** fetch data from the table: "polygon.tokenswaps_with_prices" */
  polygon_tokenswaps_with_prices: Array<Polygon_Tokenswaps_With_Prices>;
  /** fetch aggregated fields from the table: "polygon.tokenswaps_with_prices" */
  polygon_tokenswaps_with_prices_aggregate: Polygon_Tokenswaps_With_Prices_Aggregate;
  /** fetch data from the table: "polygon.tokenswaps_with_prices" using primary key columns */
  polygon_tokenswaps_with_prices_by_pk?: Maybe<Polygon_Tokenswaps_With_Prices>;
  /** fetch data from the table: "polygon.usd_tokens" */
  polygon_usd_tokens: Array<Polygon_Usd_Tokens>;
  /** fetch data from the table: "polygon.usd_tokens" using primary key columns */
  polygon_usd_tokens_by_pk?: Maybe<Polygon_Usd_Tokens>;
};


export type Subscription_RootArbitrum_BorrowsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Borrows_Order_By>>;
  where?: Maybe<Arbitrum_Borrows_Bool_Exp>;
};


export type Subscription_RootArbitrum_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Get_Lending_Market_User_CountArgs = {
  args: Arbitrum_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootArbitrum_Get_Pair_Tx_CountArgs = {
  args: Arbitrum_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootArbitrum_Get_Swap_CandlesArgs = {
  args: Arbitrum_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootArbitrum_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootArbitrum_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootArbitrum_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Lending_Supplies_Order_By>>;
  where?: Maybe<Arbitrum_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootArbitrum_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootArbitrum_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootArbitrum_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootArbitrum_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootArbitrum_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Loan_Liquidations_Order_By>>;
  where?: Maybe<Arbitrum_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootArbitrum_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Search_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Search_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Search_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Search_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Summary_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_Summary_Order_By>>;
  where?: Maybe<Arbitrum_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootArbitrum_PairsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootArbitrum_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Arbitrum_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootArbitrum_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootArbitrum_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Protocols_Order_By>>;
  where?: Maybe<Arbitrum_Protocols_Bool_Exp>;
};


export type Subscription_RootArbitrum_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootArbitrum_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootArbitrum_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootArbitrum_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootArbitrum_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Arbitrum_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootArbitrum_TokensArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokens_Order_By>>;
  where?: Maybe<Arbitrum_Tokens_Bool_Exp>;
};


export type Subscription_RootArbitrum_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootArbitrum_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootArbitrum_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Arbitrum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootArbitrum_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootArbitrum_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Arbitrum_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Arbitrum_Usd_Tokens_Order_By>>;
  where?: Maybe<Arbitrum_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootArbitrum_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootAvalanche_BorrowsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Borrows_Order_By>>;
  where?: Maybe<Avalanche_Borrows_Bool_Exp>;
};


export type Subscription_RootAvalanche_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Get_Lending_Market_User_CountArgs = {
  args: Avalanche_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootAvalanche_Get_Pair_Tx_CountArgs = {
  args: Avalanche_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Avalanche_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootAvalanche_Get_Swap_CandlesArgs = {
  args: Avalanche_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootAvalanche_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootAvalanche_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Avalanche_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootAvalanche_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Lending_Supplies_Order_By>>;
  where?: Maybe<Avalanche_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootAvalanche_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_Changes_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootAvalanche_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_Changes_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootAvalanche_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootAvalanche_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootAvalanche_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Loan_Liquidations_Order_By>>;
  where?: Maybe<Avalanche_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootAvalanche_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Search_Order_By>>;
  where?: Maybe<Avalanche_Pair_Search_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Search_Order_By>>;
  where?: Maybe<Avalanche_Pair_Search_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Summary_Order_By>>;
  where?: Maybe<Avalanche_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_Summary_Order_By>>;
  where?: Maybe<Avalanche_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Avalanche_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootAvalanche_PairsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootAvalanche_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Avalanche_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Avalanche_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootAvalanche_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootAvalanche_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Avalanche_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Protocols_Order_By>>;
  where?: Maybe<Avalanche_Protocols_Bool_Exp>;
};


export type Subscription_RootAvalanche_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootAvalanche_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootAvalanche_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootAvalanche_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootAvalanche_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Avalanche_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Avalanche_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootAvalanche_TokensArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokens_Order_By>>;
  where?: Maybe<Avalanche_Tokens_Bool_Exp>;
};


export type Subscription_RootAvalanche_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootAvalanche_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootAvalanche_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Avalanche_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootAvalanche_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootAvalanche_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Avalanche_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Avalanche_Usd_Tokens_Order_By>>;
  where?: Maybe<Avalanche_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootAvalanche_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootBsc_BorrowsArgs = {
  distinct_on?: Maybe<Array<Bsc_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Borrows_Order_By>>;
  where?: Maybe<Bsc_Borrows_Bool_Exp>;
};


export type Subscription_RootBsc_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootBsc_Get_Lending_Market_User_CountArgs = {
  args: Bsc_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootBsc_Get_Pair_Tx_CountArgs = {
  args: Bsc_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Bsc_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Bsc_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootBsc_Get_Swap_CandlesArgs = {
  args: Bsc_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootBsc_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootBsc_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Bsc_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootBsc_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Bsc_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Lending_Supplies_Order_By>>;
  where?: Maybe<Bsc_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootBsc_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootBsc_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_Changes_Order_By>>;
  where?: Maybe<Bsc_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootBsc_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_Changes_Order_By>>;
  where?: Maybe<Bsc_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootBsc_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootBsc_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootBsc_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootBsc_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootBsc_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Bsc_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Loan_Liquidations_Order_By>>;
  where?: Maybe<Bsc_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootBsc_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootBsc_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_Search_Order_By>>;
  where?: Maybe<Bsc_Pair_Search_Bool_Exp>;
};


export type Subscription_RootBsc_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_Summary_Order_By>>;
  where?: Maybe<Bsc_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootBsc_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Bsc_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootBsc_PairsArgs = {
  distinct_on?: Maybe<Array<Bsc_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Order_By>>;
  where?: Maybe<Bsc_Pairs_Bool_Exp>;
};


export type Subscription_RootBsc_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootBsc_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Bsc_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Bsc_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootBsc_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootBsc_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Bsc_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Protocols_Order_By>>;
  where?: Maybe<Bsc_Protocols_Bool_Exp>;
};


export type Subscription_RootBsc_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootBsc_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootBsc_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootBsc_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootBsc_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Bsc_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Bsc_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootBsc_TokensArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokens_Order_By>>;
  where?: Maybe<Bsc_Tokens_Bool_Exp>;
};


export type Subscription_RootBsc_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootBsc_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootBsc_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Bsc_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Bsc_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootBsc_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_BorrowsArgs = {
  distinct_on?: Maybe<Array<Dfk_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Borrows_Order_By>>;
  where?: Maybe<Dfk_Borrows_Bool_Exp>;
};


export type Subscription_RootDfk_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Get_Lending_Market_User_CountArgs = {
  args: Dfk_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootDfk_Get_Pair_Tx_CountArgs = {
  args: Dfk_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Dfk_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Dfk_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootDfk_Get_Swap_CandlesArgs = {
  args: Dfk_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootDfk_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootDfk_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Dfk_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootDfk_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Dfk_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Lending_Supplies_Order_By>>;
  where?: Maybe<Dfk_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootDfk_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_Changes_Order_By>>;
  where?: Maybe<Dfk_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootDfk_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_Changes_Order_By>>;
  where?: Maybe<Dfk_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootDfk_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootDfk_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootDfk_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Dfk_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Loan_Liquidations_Order_By>>;
  where?: Maybe<Dfk_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootDfk_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Search_Order_By>>;
  where?: Maybe<Dfk_Pair_Search_Bool_Exp>;
};


export type Subscription_RootDfk_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Search_Order_By>>;
  where?: Maybe<Dfk_Pair_Search_Bool_Exp>;
};


export type Subscription_RootDfk_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Summary_Order_By>>;
  where?: Maybe<Dfk_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootDfk_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_Summary_Order_By>>;
  where?: Maybe<Dfk_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootDfk_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Dfk_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootDfk_PairsArgs = {
  distinct_on?: Maybe<Array<Dfk_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Order_By>>;
  where?: Maybe<Dfk_Pairs_Bool_Exp>;
};


export type Subscription_RootDfk_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootDfk_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Dfk_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Dfk_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootDfk_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootDfk_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Dfk_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Protocols_Order_By>>;
  where?: Maybe<Dfk_Protocols_Bool_Exp>;
};


export type Subscription_RootDfk_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootDfk_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootDfk_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootDfk_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootDfk_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Dfk_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Dfk_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootDfk_TokensArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokens_Order_By>>;
  where?: Maybe<Dfk_Tokens_Bool_Exp>;
};


export type Subscription_RootDfk_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootDfk_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootDfk_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Dfk_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootDfk_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootDfk_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Dfk_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dfk_Usd_Tokens_Order_By>>;
  where?: Maybe<Dfk_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootDfk_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootEthereum_BorrowsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Borrows_Order_By>>;
  where?: Maybe<Ethereum_Borrows_Bool_Exp>;
};


export type Subscription_RootEthereum_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Get_Lending_Market_User_CountArgs = {
  args: Ethereum_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootEthereum_Get_Pair_Tx_CountArgs = {
  args: Ethereum_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Ethereum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootEthereum_Get_Swap_CandlesArgs = {
  args: Ethereum_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootEthereum_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootEthereum_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Ethereum_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootEthereum_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Lending_Supplies_Order_By>>;
  where?: Maybe<Ethereum_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootEthereum_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootEthereum_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_Changes_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootEthereum_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootEthereum_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootEthereum_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Loan_Liquidations_Order_By>>;
  where?: Maybe<Ethereum_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootEthereum_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Search_Order_By>>;
  where?: Maybe<Ethereum_Pair_Search_Bool_Exp>;
};


export type Subscription_RootEthereum_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Search_Order_By>>;
  where?: Maybe<Ethereum_Pair_Search_Bool_Exp>;
};


export type Subscription_RootEthereum_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Summary_Order_By>>;
  where?: Maybe<Ethereum_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootEthereum_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_Summary_Order_By>>;
  where?: Maybe<Ethereum_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootEthereum_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Ethereum_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootEthereum_PairsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Bool_Exp>;
};


export type Subscription_RootEthereum_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootEthereum_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Ethereum_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Ethereum_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootEthereum_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootEthereum_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Ethereum_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Protocols_Order_By>>;
  where?: Maybe<Ethereum_Protocols_Bool_Exp>;
};


export type Subscription_RootEthereum_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootEthereum_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootEthereum_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootEthereum_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootEthereum_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Ethereum_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Ethereum_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootEthereum_TokensArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokens_Order_By>>;
  where?: Maybe<Ethereum_Tokens_Bool_Exp>;
};


export type Subscription_RootEthereum_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootEthereum_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootEthereum_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Ethereum_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootEthereum_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootEthereum_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Ethereum_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ethereum_Usd_Tokens_Order_By>>;
  where?: Maybe<Ethereum_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootEthereum_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootMetis_BorrowsArgs = {
  distinct_on?: Maybe<Array<Metis_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Borrows_Order_By>>;
  where?: Maybe<Metis_Borrows_Bool_Exp>;
};


export type Subscription_RootMetis_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Get_Lending_Market_User_CountArgs = {
  args: Metis_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Metis_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMetis_Get_Pair_Tx_CountArgs = {
  args: Metis_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Metis_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Metis_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMetis_Get_Swap_CandlesArgs = {
  args: Metis_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMetis_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Metis_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootMetis_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Metis_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMetis_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Metis_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Lending_Supplies_Order_By>>;
  where?: Maybe<Metis_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootMetis_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_Changes_Order_By>>;
  where?: Maybe<Metis_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMetis_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_Changes_Order_By>>;
  where?: Maybe<Metis_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMetis_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Metis_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMetis_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Metis_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMetis_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Metis_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Loan_Liquidations_Order_By>>;
  where?: Maybe<Metis_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootMetis_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Search_Order_By>>;
  where?: Maybe<Metis_Pair_Search_Bool_Exp>;
};


export type Subscription_RootMetis_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Search_Order_By>>;
  where?: Maybe<Metis_Pair_Search_Bool_Exp>;
};


export type Subscription_RootMetis_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Summary_Order_By>>;
  where?: Maybe<Metis_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootMetis_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_Summary_Order_By>>;
  where?: Maybe<Metis_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootMetis_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Metis_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootMetis_PairsArgs = {
  distinct_on?: Maybe<Array<Metis_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Order_By>>;
  where?: Maybe<Metis_Pairs_Bool_Exp>;
};


export type Subscription_RootMetis_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootMetis_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Metis_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Metis_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMetis_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootMetis_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Metis_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Protocols_Order_By>>;
  where?: Maybe<Metis_Protocols_Bool_Exp>;
};


export type Subscription_RootMetis_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootMetis_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMetis_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMetis_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootMetis_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Metis_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Metis_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMetis_TokensArgs = {
  distinct_on?: Maybe<Array<Metis_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokens_Order_By>>;
  where?: Maybe<Metis_Tokens_Bool_Exp>;
};


export type Subscription_RootMetis_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootMetis_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Metis_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Metis_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMetis_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Metis_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Metis_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMetis_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootMetis_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Metis_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Metis_Usd_Tokens_Order_By>>;
  where?: Maybe<Metis_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootMetis_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootMoonbeam_BorrowsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Borrows_Order_By>>;
  where?: Maybe<Moonbeam_Borrows_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonbeam_Get_Lending_Market_User_CountArgs = {
  args: Moonbeam_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Get_Pair_Tx_CountArgs = {
  args: Moonbeam_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Get_Swap_CandlesArgs = {
  args: Moonbeam_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Lending_Supplies_Order_By>>;
  where?: Maybe<Moonbeam_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonbeam_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonbeam_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonbeam_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Loan_Liquidations_Order_By>>;
  where?: Maybe<Moonbeam_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonbeam_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_Search_Order_By>>;
  where?: Maybe<Moonbeam_Pair_Search_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_Summary_Order_By>>;
  where?: Maybe<Moonbeam_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootMoonbeam_PairsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootMoonbeam_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonbeam_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootMoonbeam_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Protocols_Order_By>>;
  where?: Maybe<Moonbeam_Protocols_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootMoonbeam_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootMoonbeam_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonbeam_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMoonbeam_TokensArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokens_Order_By>>;
  where?: Maybe<Moonbeam_Tokens_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootMoonbeam_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonbeam_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonbeam_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonbeam_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_BorrowsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Borrows_Order_By>>;
  where?: Maybe<Moonriver_Borrows_Bool_Exp>;
};


export type Subscription_RootMoonriver_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_Get_Lending_Market_User_CountArgs = {
  args: Moonriver_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMoonriver_Get_Pair_Tx_CountArgs = {
  args: Moonriver_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Moonriver_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMoonriver_Get_Swap_CandlesArgs = {
  args: Moonriver_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMoonriver_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootMoonriver_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Moonriver_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootMoonriver_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Lending_Supplies_Order_By>>;
  where?: Maybe<Moonriver_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootMoonriver_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMoonriver_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_Changes_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootMoonriver_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonriver_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonriver_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Loan_Liquidations_Order_By>>;
  where?: Maybe<Moonriver_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootMoonriver_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootMoonriver_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_Search_Order_By>>;
  where?: Maybe<Moonriver_Pair_Search_Bool_Exp>;
};


export type Subscription_RootMoonriver_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_Summary_Order_By>>;
  where?: Maybe<Moonriver_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootMoonriver_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Moonriver_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootMoonriver_PairsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Bool_Exp>;
};


export type Subscription_RootMoonriver_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootMoonriver_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Moonriver_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Moonriver_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootMoonriver_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootMoonriver_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Moonriver_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Protocols_Order_By>>;
  where?: Maybe<Moonriver_Protocols_Bool_Exp>;
};


export type Subscription_RootMoonriver_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootMoonriver_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMoonriver_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootMoonriver_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootMoonriver_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Moonriver_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Moonriver_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootMoonriver_TokensArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokens_Order_By>>;
  where?: Maybe<Moonriver_Tokens_Bool_Exp>;
};


export type Subscription_RootMoonriver_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootMoonriver_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonriver_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Moonriver_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Moonriver_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootMoonriver_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_BorrowsArgs = {
  distinct_on?: Maybe<Array<Optimism_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Borrows_Order_By>>;
  where?: Maybe<Optimism_Borrows_Bool_Exp>;
};


export type Subscription_RootOptimism_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Get_Lending_Market_User_CountArgs = {
  args: Optimism_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootOptimism_Get_Pair_Tx_CountArgs = {
  args: Optimism_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Optimism_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Optimism_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootOptimism_Get_Swap_CandlesArgs = {
  args: Optimism_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootOptimism_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootOptimism_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Optimism_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootOptimism_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Optimism_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Lending_Supplies_Order_By>>;
  where?: Maybe<Optimism_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootOptimism_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_Changes_Order_By>>;
  where?: Maybe<Optimism_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootOptimism_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_Changes_Order_By>>;
  where?: Maybe<Optimism_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootOptimism_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootOptimism_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootOptimism_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Optimism_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Loan_Liquidations_Order_By>>;
  where?: Maybe<Optimism_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootOptimism_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Search_Order_By>>;
  where?: Maybe<Optimism_Pair_Search_Bool_Exp>;
};


export type Subscription_RootOptimism_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Search_Order_By>>;
  where?: Maybe<Optimism_Pair_Search_Bool_Exp>;
};


export type Subscription_RootOptimism_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Summary_Order_By>>;
  where?: Maybe<Optimism_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootOptimism_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_Summary_Order_By>>;
  where?: Maybe<Optimism_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootOptimism_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Optimism_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootOptimism_PairsArgs = {
  distinct_on?: Maybe<Array<Optimism_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Order_By>>;
  where?: Maybe<Optimism_Pairs_Bool_Exp>;
};


export type Subscription_RootOptimism_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootOptimism_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Optimism_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Optimism_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootOptimism_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootOptimism_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Optimism_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Protocols_Order_By>>;
  where?: Maybe<Optimism_Protocols_Bool_Exp>;
};


export type Subscription_RootOptimism_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootOptimism_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootOptimism_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootOptimism_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootOptimism_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Optimism_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Optimism_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootOptimism_TokensArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokens_Order_By>>;
  where?: Maybe<Optimism_Tokens_Bool_Exp>;
};


export type Subscription_RootOptimism_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootOptimism_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootOptimism_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Optimism_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootOptimism_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootOptimism_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Optimism_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Optimism_Usd_Tokens_Order_By>>;
  where?: Maybe<Optimism_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootOptimism_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};


export type Subscription_RootPolygon_BorrowsArgs = {
  distinct_on?: Maybe<Array<Polygon_Borrows_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Borrows_Order_By>>;
  where?: Maybe<Polygon_Borrows_Bool_Exp>;
};


export type Subscription_RootPolygon_Borrows_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Get_Lending_Market_User_CountArgs = {
  args: Polygon_Get_Lending_Market_User_Count_Args;
  distinct_on?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootPolygon_Get_Pair_Tx_CountArgs = {
  args: Polygon_Get_Pair_Tx_Count_Args;
  distinct_on?: Maybe<Array<Polygon_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Polygon_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootPolygon_Get_Swap_CandlesArgs = {
  args: Polygon_Get_Swap_Candles_Args;
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootPolygon_Lending_Market_Daily_SnapshotsArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_Daily_Snapshots_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_Daily_Snapshots_Bool_Exp>;
};


export type Subscription_RootPolygon_Lending_Market_User_Count_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Market_User_Count_Tb_Order_By>>;
  where?: Maybe<Polygon_Lending_Market_User_Count_Tb_Bool_Exp>;
};


export type Subscription_RootPolygon_Lending_SuppliesArgs = {
  distinct_on?: Maybe<Array<Polygon_Lending_Supplies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Lending_Supplies_Order_By>>;
  where?: Maybe<Polygon_Lending_Supplies_Bool_Exp>;
};


export type Subscription_RootPolygon_Lending_Supplies_By_PkArgs = {
  direction: Scalars['String'];
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Liquidity_ChangesArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_Changes_Order_By>>;
  where?: Maybe<Polygon_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootPolygon_Liquidity_Changes_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_Changes_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_Changes_Order_By>>;
  where?: Maybe<Polygon_Liquidity_Changes_Bool_Exp>;
};


export type Subscription_RootPolygon_Liquidity_Changes_By_PkArgs = {
  eventindex: Scalars['Int'];
  exchange: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Liquidity_With_PricesArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootPolygon_Liquidity_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Liquidity_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Liquidity_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Liquidity_With_Prices_Bool_Exp>;
};


export type Subscription_RootPolygon_Liquidity_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  eventindex: Scalars['numeric'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Loan_LiquidationsArgs = {
  distinct_on?: Maybe<Array<Polygon_Loan_Liquidations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Loan_Liquidations_Order_By>>;
  where?: Maybe<Polygon_Loan_Liquidations_Bool_Exp>;
};


export type Subscription_RootPolygon_Loan_Liquidations_By_PkArgs = {
  event_index: Scalars['numeric'];
  market_address: Scalars['String'];
  protocol: Scalars['String'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Pair_SearchArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Search_Order_By>>;
  where?: Maybe<Polygon_Pair_Search_Bool_Exp>;
};


export type Subscription_RootPolygon_Pair_Search_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Search_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Search_Order_By>>;
  where?: Maybe<Polygon_Pair_Search_Bool_Exp>;
};


export type Subscription_RootPolygon_Pair_SummaryArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Summary_Order_By>>;
  where?: Maybe<Polygon_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootPolygon_Pair_Summary_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_Summary_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_Summary_Order_By>>;
  where?: Maybe<Polygon_Pair_Summary_Bool_Exp>;
};


export type Subscription_RootPolygon_Pair_With_Prices_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pair_With_Prices_Tb_Order_By>>;
  where?: Maybe<Polygon_Pair_With_Prices_Tb_Bool_Exp>;
};


export type Subscription_RootPolygon_PairsArgs = {
  distinct_on?: Maybe<Array<Polygon_Pairs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Order_By>>;
  where?: Maybe<Polygon_Pairs_Bool_Exp>;
};


export type Subscription_RootPolygon_Pairs_By_PkArgs = {
  pair_address: Scalars['String'];
};


export type Subscription_RootPolygon_Pairs_Tx_CountArgs = {
  distinct_on?: Maybe<Array<Polygon_Pairs_Tx_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Pairs_Tx_Count_Order_By>>;
  where?: Maybe<Polygon_Pairs_Tx_Count_Bool_Exp>;
};


export type Subscription_RootPolygon_Pairs_Tx_Count_By_PkArgs = {
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
};


export type Subscription_RootPolygon_ProtocolsArgs = {
  distinct_on?: Maybe<Array<Polygon_Protocols_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Protocols_Order_By>>;
  where?: Maybe<Polygon_Protocols_Bool_Exp>;
};


export type Subscription_RootPolygon_Protocols_By_PkArgs = {
  name: Scalars['String'];
  type: Scalars['String'];
};


export type Subscription_RootPolygon_Swap_Candles_CachedArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootPolygon_Swap_Candles_Cached_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Cached_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Cached_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Cached_Bool_Exp>;
};


export type Subscription_RootPolygon_Swap_Candles_Cached_By_PkArgs = {
  base_token: Scalars['String'];
  candle_start: Scalars['Int'];
  exchange: Scalars['String'];
  pair_address: Scalars['String'];
  quote_token: Scalars['String'];
  resolution_seconds: Scalars['Int'];
};


export type Subscription_RootPolygon_Swap_Candles_TbArgs = {
  distinct_on?: Maybe<Array<Polygon_Swap_Candles_Tb_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Swap_Candles_Tb_Order_By>>;
  where?: Maybe<Polygon_Swap_Candles_Tb_Bool_Exp>;
};


export type Subscription_RootPolygon_TokensArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokens_Order_By>>;
  where?: Maybe<Polygon_Tokens_Bool_Exp>;
};


export type Subscription_RootPolygon_Tokens_By_PkArgs = {
  address: Scalars['String'];
};


export type Subscription_RootPolygon_Tokenswaps_With_PricesArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootPolygon_Tokenswaps_With_Prices_AggregateArgs = {
  distinct_on?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Tokenswaps_With_Prices_Order_By>>;
  where?: Maybe<Polygon_Tokenswaps_With_Prices_Bool_Exp>;
};


export type Subscription_RootPolygon_Tokenswaps_With_Prices_By_PkArgs = {
  direction: Scalars['String'];
  exchange: Scalars['String'];
  swapindex: Scalars['Int'];
  txhash: Scalars['String'];
};


export type Subscription_RootPolygon_Usd_TokensArgs = {
  distinct_on?: Maybe<Array<Polygon_Usd_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Polygon_Usd_Tokens_Order_By>>;
  where?: Maybe<Polygon_Usd_Tokens_Bool_Exp>;
};


export type Subscription_RootPolygon_Usd_Tokens_By_PkArgs = {
  usd_token: Scalars['String'];
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamptz']>;
  _gt?: Maybe<Scalars['timestamptz']>;
  _gte?: Maybe<Scalars['timestamptz']>;
  _in?: Maybe<Array<Scalars['timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamptz']>;
  _lte?: Maybe<Scalars['timestamptz']>;
  _neq?: Maybe<Scalars['timestamptz']>;
  _nin?: Maybe<Array<Scalars['timestamptz']>>;
};

export type SearchPairByTokensQueryVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  token0?: Maybe<Scalars['String']>;
  token1?: Maybe<Scalars['String']>;
}>;


export type SearchPairByTokensQuery = { __typename?: 'query_root', pairs: Array<{ __typename?: 'avalanche_pair_search', exchange?: string | null | undefined, pair_address?: string | null | undefined, token1_address?: string | null | undefined, token0_address?: string | null | undefined, last_24hour_usd_volume?: any | null | undefined, token0?: { __typename?: 'avalanche_tokens', primary_img_uri?: string | null | undefined, name?: string | null | undefined, symbol?: string | null | undefined, decimals?: number | null | undefined } | null | undefined, token1?: { __typename?: 'avalanche_tokens', primary_img_uri?: string | null | undefined, name?: string | null | undefined, symbol?: string | null | undefined, decimals?: number | null | undefined } | null | undefined }> };

export type PricesQueryVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  baseToken?: Maybe<Scalars['String']>;
  quoteToken?: Maybe<Scalars['String']>;
  pairAddress?: Maybe<Scalars['String']>;
  fromDate?: Maybe<Scalars['Int']>;
  toDate?: Maybe<Scalars['Int']>;
  resolution?: Maybe<Scalars['Int']>;
  isUSDView: Scalars['Boolean'];
}>;


export type PricesQuery = { __typename?: 'query_root', prices: Array<{ __typename?: 'avalanche_swap_candles_cached', candle_start: number, close?: any | null | undefined, high?: any | null | undefined, low?: any | null | undefined, open?: any | null | undefined, close_usd?: any | null | undefined, high_usd?: any | null | undefined, low_usd?: any | null | undefined, open_usd?: any | null | undefined, usd_volume?: any | null | undefined, generation_time?: number | null | undefined }> };

export type LatestPriceQueryVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  baseToken?: Maybe<Scalars['String']>;
  quoteToken?: Maybe<Scalars['String']>;
  pairAddress?: Maybe<Scalars['String']>;
  resolution?: Maybe<Scalars['Int']>;
  isUSDView: Scalars['Boolean'];
}>;


export type LatestPriceQuery = { __typename?: 'query_root', prices: Array<{ __typename?: 'avalanche_swap_candles_cached', candle_start: number, close?: any | null | undefined, high?: any | null | undefined, low?: any | null | undefined, open?: any | null | undefined, close_usd?: any | null | undefined, high_usd?: any | null | undefined, low_usd?: any | null | undefined, open_usd?: any | null | undefined }> };

export type SubscribePricesSubscriptionVariables = Exact<{
  exchange: Scalars['String'];
  pairAddress?: Maybe<Scalars['String']>;
  baseToken: Scalars['String'];
  quoteToken: Scalars['String'];
  resolution: Scalars['Int'];
  isUSDView: Scalars['Boolean'];
}>;


export type SubscribePricesSubscription = { __typename?: 'subscription_root', prices: Array<{ __typename?: 'avalanche_swap_candles_tb', candle_start?: number | null | undefined, close?: any | null | undefined, high?: any | null | undefined, low?: any | null | undefined, open?: any | null | undefined, close_usd?: any | null | undefined, high_usd?: any | null | undefined, low_usd?: any | null | undefined, open_usd?: any | null | undefined, usd_volume?: any | null | undefined, generation_time: number }> };

export type MinTimestampQueryVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  pairAddress?: Maybe<Scalars['String']>;
  token0?: Maybe<Scalars['String']>;
  token1?: Maybe<Scalars['String']>;
  resolutionSeconds?: Maybe<Scalars['Int']>;
}>;


export type MinTimestampQuery = { __typename?: 'query_root', prices: { __typename?: 'avalanche_swap_candles_cached_aggregate', aggregate?: { __typename?: 'avalanche_swap_candles_cached_aggregate_fields', min?: { __typename?: 'avalanche_swap_candles_cached_min_fields', candle_start?: number | null | undefined } | null | undefined } | null | undefined } };

export type GetSwapQueryVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  baseToken?: Maybe<Scalars['String']>;
  quoteToken?: Maybe<Scalars['String']>;
  pairAddress?: Maybe<Scalars['String']>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<Avalanche_Tokenswaps_With_Prices_Order_By> | Avalanche_Tokenswaps_With_Prices_Order_By>;
}>;


export type GetSwapQuery = { __typename?: 'query_root', swap: Array<{ __typename?: 'avalanche_tokenswaps_with_prices', txhash: string, timestamp: number, direction: string, base_token: string, quote_token: string, price?: any | null | undefined, base_amount: any, quote_amount: any, native_price?: any | null | undefined, usd_price?: any | null | undefined, base_decimals: number, quote_decimals: number }> };

export type OnSwapSubscriptionVariables = Exact<{
  exchange?: Maybe<Scalars['String']>;
  pairAddress?: Maybe<Scalars['String']>;
  baseToken?: Maybe<Scalars['String']>;
  quoteToken?: Maybe<Scalars['String']>;
  limit?: Maybe<Scalars['Int']>;
}>;


export type OnSwapSubscription = { __typename?: 'subscription_root', swap: Array<{ __typename?: 'avalanche_tokenswaps_with_prices', txhash: string, timestamp: number, direction: string, base_token: string, quote_token: string, price?: any | null | undefined, base_amount: any, swapindex: number, quote_amount: any, native_price?: any | null | undefined, usd_price?: any | null | undefined, base_decimals: number, quote_decimals: number }> };

export type TokenDetailsQueryVariables = Exact<{
  base_token_lc: Scalars['String'];
  quote_token_lc: Scalars['String'];
  pair_address: Scalars['String'];
  exchange: Scalars['String'];
}>;


export type TokenDetailsQuery = { __typename?: 'query_root', pair: Array<{ __typename?: 'avalanche_pair_summary', exchange?: string | null | undefined, start_pair_price?: any | null | undefined, start_token1_native_price?: any | null | undefined, start_token1_usd_price?: any | null | undefined, start_token0_native_price?: any | null | undefined, start_token0_usd_price?: any | null | undefined, last_24hour_native_volume?: any | null | undefined, last_24hour_usd_volume?: any | null | undefined, latest_pair_price?: any | null | undefined, latest_token1_native_price?: any | null | undefined, latest_token1_usd_price?: any | null | undefined, latest_token0_native_price?: any | null | undefined, latest_token0_usd_price?: any | null | undefined, pair_address?: string | null | undefined, pair_creation_date?: any | null | undefined, token0_address?: string | null | undefined, token0_name?: string | null | undefined, token0_pooled?: any | null | undefined, token0_symbol?: string | null | undefined, token0_total_supply?: any | null | undefined, token1_address?: string | null | undefined, token1_name?: string | null | undefined, token1_pooled?: any | null | undefined, token1_symbol?: string | null | undefined, token1_total_supply?: any | null | undefined }>, all_txs: Array<{ __typename?: 'avalanche_pairs_tx_count', tx_count: any }> };


export const SearchPairByTokensDocument = gql`
    query SearchPairByTokens($exchange: String, $token0: String, $token1: String) {
  pairs: avalanche_pair_search(
    where: {exchange: {_eq: $exchange}, token0: {address: {_eq: $token0}}, token1: {address: {_eq: $token1}}}
  ) {
    exchange
    pair_address
    token1_address
    token0_address
    token0 {
      primary_img_uri
      name
      symbol
      decimals
    }
    token1 {
      primary_img_uri
      name
      symbol
      decimals
    }
    last_24hour_usd_volume
  }
}
    `;

/**
 * __useSearchPairByTokensQuery__
 *
 * To run a query within a React component, call `useSearchPairByTokensQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPairByTokensQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPairByTokensQuery({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      token0: // value for 'token0'
 *      token1: // value for 'token1'
 *   },
 * });
 */
export function useSearchPairByTokensQuery(baseOptions?: Apollo.QueryHookOptions<SearchPairByTokensQuery, SearchPairByTokensQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPairByTokensQuery, SearchPairByTokensQueryVariables>(SearchPairByTokensDocument, options);
      }
export function useSearchPairByTokensLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPairByTokensQuery, SearchPairByTokensQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPairByTokensQuery, SearchPairByTokensQueryVariables>(SearchPairByTokensDocument, options);
        }
export type SearchPairByTokensQueryHookResult = ReturnType<typeof useSearchPairByTokensQuery>;
export type SearchPairByTokensLazyQueryHookResult = ReturnType<typeof useSearchPairByTokensLazyQuery>;
export type SearchPairByTokensQueryResult = Apollo.QueryResult<SearchPairByTokensQuery, SearchPairByTokensQueryVariables>;
export const PricesDocument = gql`
    query Prices($exchange: String, $baseToken: String, $quoteToken: String, $pairAddress: String, $fromDate: Int, $toDate: Int, $resolution: Int, $isUSDView: Boolean!) {
  prices: avalanche_swap_candles_cached(
    order_by: {candle_start: asc}
    where: {exchange: {_eq: $exchange}, base_token: {_eq: $baseToken}, quote_token: {_eq: $quoteToken}, pair_address: {_eq: $pairAddress}, resolution_seconds: {_eq: $resolution}, candle_start: {_gte: $fromDate, _lte: $toDate}}
  ) {
    candle_start
    close @skip(if: $isUSDView)
    high @skip(if: $isUSDView)
    low @skip(if: $isUSDView)
    open @skip(if: $isUSDView)
    close_usd @include(if: $isUSDView)
    high_usd @include(if: $isUSDView)
    low_usd @include(if: $isUSDView)
    open_usd @include(if: $isUSDView)
    usd_volume
    generation_time
  }
}
    `;

/**
 * __usePricesQuery__
 *
 * To run a query within a React component, call `usePricesQuery` and pass it any options that fit your needs.
 * When your component renders, `usePricesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePricesQuery({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      baseToken: // value for 'baseToken'
 *      quoteToken: // value for 'quoteToken'
 *      pairAddress: // value for 'pairAddress'
 *      fromDate: // value for 'fromDate'
 *      toDate: // value for 'toDate'
 *      resolution: // value for 'resolution'
 *      isUSDView: // value for 'isUSDView'
 *   },
 * });
 */
export function usePricesQuery(baseOptions: Apollo.QueryHookOptions<PricesQuery, PricesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PricesQuery, PricesQueryVariables>(PricesDocument, options);
      }
export function usePricesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PricesQuery, PricesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PricesQuery, PricesQueryVariables>(PricesDocument, options);
        }
export type PricesQueryHookResult = ReturnType<typeof usePricesQuery>;
export type PricesLazyQueryHookResult = ReturnType<typeof usePricesLazyQuery>;
export type PricesQueryResult = Apollo.QueryResult<PricesQuery, PricesQueryVariables>;
export const LatestPriceDocument = gql`
    query LatestPrice($exchange: String, $baseToken: String, $quoteToken: String, $pairAddress: String, $resolution: Int, $isUSDView: Boolean!) {
  prices: avalanche_swap_candles_cached(
    order_by: {candle_start: desc}
    limit: 1
    where: {exchange: {_eq: $exchange}, base_token: {_eq: $baseToken}, quote_token: {_eq: $quoteToken}, pair_address: {_eq: $pairAddress}, resolution_seconds: {_eq: $resolution}}
  ) {
    candle_start
    close @skip(if: $isUSDView)
    high @skip(if: $isUSDView)
    low @skip(if: $isUSDView)
    open @skip(if: $isUSDView)
    close_usd @include(if: $isUSDView)
    high_usd @include(if: $isUSDView)
    low_usd @include(if: $isUSDView)
    open_usd @include(if: $isUSDView)
  }
}
    `;

/**
 * __useLatestPriceQuery__
 *
 * To run a query within a React component, call `useLatestPriceQuery` and pass it any options that fit your needs.
 * When your component renders, `useLatestPriceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLatestPriceQuery({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      baseToken: // value for 'baseToken'
 *      quoteToken: // value for 'quoteToken'
 *      pairAddress: // value for 'pairAddress'
 *      resolution: // value for 'resolution'
 *      isUSDView: // value for 'isUSDView'
 *   },
 * });
 */
export function useLatestPriceQuery(baseOptions: Apollo.QueryHookOptions<LatestPriceQuery, LatestPriceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LatestPriceQuery, LatestPriceQueryVariables>(LatestPriceDocument, options);
      }
export function useLatestPriceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LatestPriceQuery, LatestPriceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LatestPriceQuery, LatestPriceQueryVariables>(LatestPriceDocument, options);
        }
export type LatestPriceQueryHookResult = ReturnType<typeof useLatestPriceQuery>;
export type LatestPriceLazyQueryHookResult = ReturnType<typeof useLatestPriceLazyQuery>;
export type LatestPriceQueryResult = Apollo.QueryResult<LatestPriceQuery, LatestPriceQueryVariables>;
export const SubscribePricesDocument = gql`
    subscription SubscribePrices($exchange: String!, $pairAddress: String, $baseToken: String!, $quoteToken: String!, $resolution: Int!, $isUSDView: Boolean!) {
  prices: avalanche_get_swap_candles(
    order_by: {candle_start: desc}
    limit: 4
    args: {_exchange: $exchange, _pair_address: $pairAddress, _base_token: $baseToken, _quote_token: $quoteToken, _resolution: $resolution}
  ) {
    candle_start
    close @skip(if: $isUSDView)
    high @skip(if: $isUSDView)
    low @skip(if: $isUSDView)
    open @skip(if: $isUSDView)
    close_usd @include(if: $isUSDView)
    high_usd @include(if: $isUSDView)
    low_usd @include(if: $isUSDView)
    open_usd @include(if: $isUSDView)
    usd_volume
    generation_time
  }
}
    `;

/**
 * __useSubscribePricesSubscription__
 *
 * To run a query within a React component, call `useSubscribePricesSubscription` and pass it any options that fit your needs.
 * When your component renders, `useSubscribePricesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubscribePricesSubscription({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      pairAddress: // value for 'pairAddress'
 *      baseToken: // value for 'baseToken'
 *      quoteToken: // value for 'quoteToken'
 *      resolution: // value for 'resolution'
 *      isUSDView: // value for 'isUSDView'
 *   },
 * });
 */
export function useSubscribePricesSubscription(baseOptions: Apollo.SubscriptionHookOptions<SubscribePricesSubscription, SubscribePricesSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<SubscribePricesSubscription, SubscribePricesSubscriptionVariables>(SubscribePricesDocument, options);
      }
export type SubscribePricesSubscriptionHookResult = ReturnType<typeof useSubscribePricesSubscription>;
export type SubscribePricesSubscriptionResult = Apollo.SubscriptionResult<SubscribePricesSubscription>;
export const MinTimestampDocument = gql`
    query minTimestamp($exchange: String, $pairAddress: String, $token0: String, $token1: String, $resolutionSeconds: Int) @cached {
  prices: avalanche_swap_candles_cached_aggregate(
    where: {exchange: {_eq: $exchange}, resolution_seconds: {_eq: $resolutionSeconds}, base_token: {_eq: $token0}, quote_token: {_eq: $token1}, pair_address: {_eq: $pairAddress}}
  ) {
    aggregate {
      min {
        candle_start
      }
    }
  }
}
    `;

/**
 * __useMinTimestampQuery__
 *
 * To run a query within a React component, call `useMinTimestampQuery` and pass it any options that fit your needs.
 * When your component renders, `useMinTimestampQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMinTimestampQuery({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      pairAddress: // value for 'pairAddress'
 *      token0: // value for 'token0'
 *      token1: // value for 'token1'
 *      resolutionSeconds: // value for 'resolutionSeconds'
 *   },
 * });
 */
export function useMinTimestampQuery(baseOptions?: Apollo.QueryHookOptions<MinTimestampQuery, MinTimestampQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MinTimestampQuery, MinTimestampQueryVariables>(MinTimestampDocument, options);
      }
export function useMinTimestampLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MinTimestampQuery, MinTimestampQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MinTimestampQuery, MinTimestampQueryVariables>(MinTimestampDocument, options);
        }
export type MinTimestampQueryHookResult = ReturnType<typeof useMinTimestampQuery>;
export type MinTimestampLazyQueryHookResult = ReturnType<typeof useMinTimestampLazyQuery>;
export type MinTimestampQueryResult = Apollo.QueryResult<MinTimestampQuery, MinTimestampQueryVariables>;
export const GetSwapDocument = gql`
    query GetSwap($exchange: String, $baseToken: String, $quoteToken: String, $pairAddress: String, $limit: Int, $offset: Int, $orderBy: [avalanche_tokenswaps_with_prices_order_by!]) {
  swap: avalanche_tokenswaps_with_prices(
    order_by: $orderBy
    where: {exchange: {_eq: $exchange}, pair_address: {_eq: $pairAddress}, base_token: {_eq: $baseToken}, quote_token: {_eq: $quoteToken}, swapindex: {_gte: 0}, unusual: {_eq: false}}
    limit: $limit
    offset: $offset
  ) {
    txhash
    timestamp
    direction
    base_token
    quote_token
    price
    base_amount
    quote_amount
    native_price
    usd_price
    base_decimals
    quote_decimals
  }
}
    `;

/**
 * __useGetSwapQuery__
 *
 * To run a query within a React component, call `useGetSwapQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSwapQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSwapQuery({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      baseToken: // value for 'baseToken'
 *      quoteToken: // value for 'quoteToken'
 *      pairAddress: // value for 'pairAddress'
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *      orderBy: // value for 'orderBy'
 *   },
 * });
 */
export function useGetSwapQuery(baseOptions?: Apollo.QueryHookOptions<GetSwapQuery, GetSwapQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSwapQuery, GetSwapQueryVariables>(GetSwapDocument, options);
      }
export function useGetSwapLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSwapQuery, GetSwapQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSwapQuery, GetSwapQueryVariables>(GetSwapDocument, options);
        }
export type GetSwapQueryHookResult = ReturnType<typeof useGetSwapQuery>;
export type GetSwapLazyQueryHookResult = ReturnType<typeof useGetSwapLazyQuery>;
export type GetSwapQueryResult = Apollo.QueryResult<GetSwapQuery, GetSwapQueryVariables>;
export const OnSwapDocument = gql`
    subscription OnSwap($exchange: String, $pairAddress: String, $baseToken: String, $quoteToken: String, $limit: Int) {
  swap: avalanche_tokenswaps_with_prices(
    order_by: {timestamp: desc}
    limit: $limit
    where: {exchange: {_eq: $exchange}, pair_address: {_eq: $pairAddress}, base_token: {_eq: $baseToken}, quote_token: {_eq: $quoteToken}, swapindex: {_gte: 0}, unusual: {_eq: false}}
  ) {
    txhash
    timestamp
    direction
    base_token
    quote_token
    price
    base_amount
    swapindex
    quote_amount
    native_price
    usd_price
    base_decimals
    quote_decimals
  }
}
    `;

/**
 * __useOnSwapSubscription__
 *
 * To run a query within a React component, call `useOnSwapSubscription` and pass it any options that fit your needs.
 * When your component renders, `useOnSwapSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnSwapSubscription({
 *   variables: {
 *      exchange: // value for 'exchange'
 *      pairAddress: // value for 'pairAddress'
 *      baseToken: // value for 'baseToken'
 *      quoteToken: // value for 'quoteToken'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useOnSwapSubscription(baseOptions?: Apollo.SubscriptionHookOptions<OnSwapSubscription, OnSwapSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<OnSwapSubscription, OnSwapSubscriptionVariables>(OnSwapDocument, options);
      }
export type OnSwapSubscriptionHookResult = ReturnType<typeof useOnSwapSubscription>;
export type OnSwapSubscriptionResult = Apollo.SubscriptionResult<OnSwapSubscription>;
export const TokenDetailsDocument = gql`
    query TokenDetails($base_token_lc: String!, $quote_token_lc: String!, $pair_address: String!, $exchange: String!) @cached {
  pair: avalanche_pair_summary(
    where: {exchange: {_eq: $exchange}, pair_address: {_eq: $pair_address}}
  ) {
    exchange
    start_pair_price
    start_token1_native_price
    start_token1_usd_price
    start_token0_native_price
    start_token0_usd_price
    last_24hour_native_volume
    last_24hour_usd_volume
    latest_pair_price
    latest_token1_native_price
    latest_token1_usd_price
    latest_token0_native_price
    latest_token0_usd_price
    pair_address
    pair_creation_date
    token0_address
    token0_name
    token0_pooled
    token0_symbol
    token0_total_supply
    token1_address
    token1_name
    token1_pooled
    token1_symbol
    token1_total_supply
  }
  all_txs: avalanche_get_pair_tx_count(
    args: {_exchange: $exchange, _pair_address: $pair_address}
  ) {
    tx_count
  }
}
    `;

/**
 * __useTokenDetailsQuery__
 *
 * To run a query within a React component, call `useTokenDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTokenDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTokenDetailsQuery({
 *   variables: {
 *      base_token_lc: // value for 'base_token_lc'
 *      quote_token_lc: // value for 'quote_token_lc'
 *      pair_address: // value for 'pair_address'
 *      exchange: // value for 'exchange'
 *   },
 * });
 */
export function useTokenDetailsQuery(baseOptions: Apollo.QueryHookOptions<TokenDetailsQuery, TokenDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TokenDetailsQuery, TokenDetailsQueryVariables>(TokenDetailsDocument, options);
      }
export function useTokenDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TokenDetailsQuery, TokenDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TokenDetailsQuery, TokenDetailsQueryVariables>(TokenDetailsDocument, options);
        }
export type TokenDetailsQueryHookResult = ReturnType<typeof useTokenDetailsQuery>;
export type TokenDetailsLazyQueryHookResult = ReturnType<typeof useTokenDetailsLazyQuery>;
export type TokenDetailsQueryResult = Apollo.QueryResult<TokenDetailsQuery, TokenDetailsQueryVariables>;